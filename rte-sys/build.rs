#[macro_use]
extern crate log;
extern crate env_logger;
extern crate gcc;
extern crate regex;

use std::env;
use std::env::consts::*;
use std::io::Cursor;
use std::io::prelude::*;
use std::fs::File;
use std::path::PathBuf;
use std::process::Command;
use std::collections::HashMap;

fn build_dpdk(base_dir: &PathBuf) {
    let target = base_dir.file_name().unwrap().to_str().unwrap();

    debug!("building DPDK for target {} @ {}",
           target,
           base_dir.to_str().unwrap());

    Command::new("make")
        .args(&["install",
                format!("T={}", target).as_str(),
                "CONFIG_RTE_BUILD_COMBINE_LIBS=y",
                "EXTRA_CFLAGS='-fPIC -g -ggdb'",
                "-j 4"])
        .current_dir(base_dir.parent().unwrap())
        .status()
        .unwrap_or_else(|e| panic!("failed to execute process: {}", e));
}

fn gen_rte_config(base_dir: &PathBuf) {
    let dest_path = PathBuf::from("src/rte_config.rs");

    debug!("generating rte_config.rs @ {}", dest_path.to_str().unwrap());

    let mut cmd = gcc::Config::new()
                      .include(base_dir.join("include"))
                      .flag("-dM")
                      .flag("-E")
                      .flag("-march=native")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSE")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSE2")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSE3")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSSE3")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSE4_1")
                      .flag("-DRTE_MACHINE_CPUFLAG_SSE4_2")
                      .flag("-DRTE_MACHINE_CPUFLAG_AES")
                      .flag("-DRTE_MACHINE_CPUFLAG_PCLMULQDQ")
                      .flag("-DRTE_MACHINE_CPUFLAG_AVX")
                      .flag("-DRTE_MACHINE_CPUFLAG_RDRAND")
                      .flag("-DRTE_MACHINE_CPUFLAG_FSGSBASE")
                      .flag("-DRTE_MACHINE_CPUFLAG_F16C")
                      .flag("-DRTE_MACHINE_CPUFLAG_AVX2")
                      .flag("-DRTE_COMPILE_TIME_CPUFLAGS=RTE_CPUFLAG_SSE,RTE_CPUFLAG_SSE2,\
                             RTE_CPUFLAG_SSE3,RTE_CPUFLAG_SSSE3,RTE_CPUFLAG_SSE4_1,\
                             RTE_CPUFLAG_SSE4_2,RTE_CPUFLAG_AES,RTE_CPUFLAG_PCLMULQDQ,\
                             RTE_CPUFLAG_AVX,RTE_CPUFLAG_RDRAND,RTE_CPUFLAG_FSGSBASE,\
                             RTE_CPUFLAG_F16C,RTE_CPUFLAG_AVX2")
                      .get_compiler()
                      .to_command();

    cmd.arg("src/rte.h");

    let re_num = regex::Regex::new(r"^[\({]?\s*(?:\([:word:]+\))?\(?(?P<value>-?[:digit:]+)(?P<suffix>[Uu]?[Ll]*)\s*[\)}]?$")
                     .unwrap();
    let re_hex = regex::Regex::new(r"^[\({]?\s*(?:\([:word:]+\))?\(?(?P<value>0x[:xdigit:]+)(?P<suffix>[Uu]?[Ll]*)\s*[\)}]?$")
                     .unwrap();
    let re_shift = regex::Regex::new(r"^\(?(?P<value>[:digit:]+\s*<<\s*[:digit:]+)\)?$").unwrap();

    debug!("executing: {:?}", cmd);

    let output = cmd.output()
                    .unwrap_or_else(|err| panic!("failed to generate rte_config.rs, {}", err));

    let f = File::create(&dest_path).unwrap();

    let name_prefixes = &["RTE_", "ETHER_"];

    fn value_types(sign: bool, long: bool) -> &'static str {
        match (sign, long) {
            (true, true) => "i64",
            (false, true) => "u64",
            (true, false) => "i32",
            (false, false) => "u32",
        }
    }

    write!(&f,
           r#"// automatically generated by build.rs script

"#)
        .unwrap();

    let keyvalues = Cursor::new(output.stdout)
                        .lines()
                        .filter_map(|r| r.ok())
                        .filter_map(|line| {
                            let vars: Vec<&str> = line.splitn(3, " ")
                                                      .collect();

                            if vars[0] == "#define" {
                                Some((String::from(vars[1]), String::from(vars[2])))
                            } else {
                                None
                            }
                        })
                        .filter(|&(ref name, _)| {
                            name_prefixes.iter().any(|prefix| name.starts_with(prefix))
                        })
                        .collect::<HashMap<String, String>>();

    let mut skipped_keyvalues = HashMap::<String, String>::new();

    let mut lines = keyvalues.iter()
                             .filter_map(|(name, raw_value)| {
                                 if raw_value.starts_with("\"") && raw_value.ends_with("\"") {
                                     Some((name, raw_value, raw_value.clone(), "&'static str"))
                                 } else if let Some(caps) = re_num.captures(raw_value.as_str()) {
                                     let value = caps.name("value").expect("`value` not found");

                                     Some((name,
                                           raw_value,
                                           String::from(value),
                                           value_types(value.starts_with("-"),
                                                       caps.name("suffix")
                                                           .map_or_else(|| false, |suffix| {
                                                               suffix.to_uppercase() == "ULL"
                                                           }))))
                                 } else if let Some(caps) = re_hex.captures(raw_value.as_str()) {
                                     let value = caps.name("value").expect("`value` not found");

                                     Some((name,
                                           raw_value,
                                           String::from(value),
                                           value_types(value.starts_with("-"),
                                                       caps.name("suffix")
                                                           .map_or_else(|| false, |suffix| {
                                                               suffix.to_uppercase() == "ULL"
                                                           }))))
                                 } else if let Some(caps) = re_shift.captures(raw_value.as_str()) {
                                     let value = caps.name("value").expect("`value` not found");

                                     Some((name, raw_value, String::from(value), "u32"))
                                 } else {
                                     skipped_keyvalues.insert(name.clone(), raw_value.clone());

                                     None
                                 }
                             })
                             .map(|(name, raw_value, value, value_type)| {
                                 format!("pub const {}: {} = {}; // {}",
                                         name.to_uppercase(),
                                         value_type,
                                         value,
                                         raw_value)
                             })
                             .collect::<Vec<String>>();

    lines.sort();

    for line in &lines {
        write!(&f, "{}\n", line).unwrap();
    }

    write!(&f,
           r#"
// skipped

"#)
        .unwrap();

    let mut skipped_lines = skipped_keyvalues.iter()
                                             .map(|(name, value)| {
                                                 format!("#define {}\t{}", name, value)
                                             })
                                             .collect::<Vec<String>>();

    skipped_lines.sort();

    for line in &skipped_lines {
        write!(&f, "// {}\n", line).unwrap();
    }
}

fn gen_cargo_config(base_dir: &PathBuf) {
    let libs = vec!["ethdev",
                    "rte_acl",
                    "rte_cfgfile",
                    "rte_cmdline",
                    "rte_cryptodev",
                    "rte_distributor",
                    "rte_eal",
                    "rte_hash",
                    "rte_ip_frag",
                    "rte_jobstats",
                    "rte_kni",
                    "rte_kvargs",
                    "rte_lpm",
                    "rte_mbuf",
                    "rte_mempool",
                    "rte_meter",
                    "rte_pipeline",
                    "rte_port",
                    "rte_ring",
                    "rte_table",
                    "rte_timer",
                    "rte_vhost"];

    for lib in libs {
        println!("cargo:rustc-link-lib=static={}", lib);
    }

    println!("cargo:rustc-link-search=native={}",
             base_dir.join("lib").to_str().unwrap());
    println!("cargo:include={}",
             base_dir.join("include").to_str().unwrap());
}

fn main() {
    env_logger::init().unwrap();

    let root_dir = env::var("RTE_SDK")
                       .expect("RTE_SDK - Points to the DPDK installation directory.");
    let target = env::var("RTE_TARGET")
                     .unwrap_or(String::from(format!("{}-native-{}app-gcc", ARCH, OS)));

    let base_dir = PathBuf::from(root_dir).join(target);

    if !base_dir.exists() {
        build_dpdk(&base_dir);
    }

    gen_rte_config(&base_dir);

    gen_cargo_config(&base_dir);
}
