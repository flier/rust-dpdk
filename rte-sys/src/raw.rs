/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BASEBAND_ACC100: u32 = 1;
pub const RTE_BASEBAND_FPGA_5GNR_FEC: u32 = 1;
pub const RTE_BASEBAND_FPGA_LTE_FEC: u32 = 1;
pub const RTE_BASEBAND_NULL: u32 = 1;
pub const RTE_BASEBAND_TURBO_SW: u32 = 1;
pub const RTE_BUS_DPAA: u32 = 1;
pub const RTE_BUS_FSLMC: u32 = 1;
pub const RTE_BUS_IFPGA: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_CPT: u32 = 1;
pub const RTE_COMMON_DPAAX: u32 = 1;
pub const RTE_COMMON_IAVF: u32 = 1;
pub const RTE_COMMON_OCTEONTX: u32 = 1;
pub const RTE_COMMON_OCTEONTX2: u32 = 1;
pub const RTE_COMMON_QAT: u32 = 1;
pub const RTE_COMMON_SFC_EFX: u32 = 1;
pub const RTE_COMPRESS_OCTEONTX: u32 = 1;
pub const RTE_COMPRESS_ZLIB: u32 = 1;
pub const RTE_CRYPTO_BCMFS: u32 = 1;
pub const RTE_CRYPTO_CAAM_JR: u32 = 1;
pub const RTE_CRYPTO_CCP: u32 = 1;
pub const RTE_CRYPTO_DPAA2_SEC: u32 = 1;
pub const RTE_CRYPTO_DPAA_SEC: u32 = 1;
pub const RTE_CRYPTO_NITROX: u32 = 1;
pub const RTE_CRYPTO_NULL: u32 = 1;
pub const RTE_CRYPTO_OCTEONTX: u32 = 1;
pub const RTE_CRYPTO_OCTEONTX2: u32 = 1;
pub const RTE_CRYPTO_OPENSSL: u32 = 1;
pub const RTE_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 62usize] = b"/home/jack/codes/rust-dpdk/build/install/lib64/dpdk/pmds-21.0\0";
pub const RTE_EVENT_DLB: u32 = 1;
pub const RTE_EVENT_DLB2: u32 = 1;
pub const RTE_EVENT_DPAA: u32 = 1;
pub const RTE_EVENT_DPAA2: u32 = 1;
pub const RTE_EVENT_DSW: u32 = 1;
pub const RTE_EVENT_OCTEONTX: u32 = 1;
pub const RTE_EVENT_OCTEONTX2: u32 = 1;
pub const RTE_EVENT_OPDL: u32 = 1;
pub const RTE_EVENT_SKELETON: u32 = 1;
pub const RTE_EVENT_SW: u32 = 1;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_AF_PACKET_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_LIBRTE_BCMFS_PMD: u32 = 1;
pub const RTE_LIBRTE_BITRATESTATS: u32 = 1;
pub const RTE_LIBRTE_BNX2X_PMD: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_BOND_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_LIBRTE_BPF_ELF: u32 = 1;
pub const RTE_LIBRTE_BUCKET_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_CAAM_JR_PMD: u32 = 1;
pub const RTE_LIBRTE_CCP_PMD: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_LIBRTE_CPT_COMMON: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_LIBRTE_CRYPTO_SCHEDULER_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_DLB2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DLB_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA2_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAAX_COMMON: u32 = 1;
pub const RTE_LIBRTE_DPAA_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DSW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_E1000_PMD: u32 = 1;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENETC_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_ETHDEV: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_FAILSAFE_PMD: u32 = 1;
pub const RTE_LIBRTE_FIB: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FSLMC_BUS: u32 = 1;
pub const RTE_LIBRTE_GRAPH: u32 = 1;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_HINIC_PMD: u32 = 1;
pub const RTE_LIBRTE_HNS3_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_IAVF_COMMON: u32 = 1;
pub const RTE_LIBRTE_IAVF_PMD: u32 = 1;
pub const RTE_LIBRTE_ICE_PMD: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_IGC_PMD: u32 = 1;
pub const RTE_LIBRTE_IPSEC: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_KNI_PMD: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_LATENCYSTATS: u32 = 1;
pub const RTE_LIBRTE_LIQUIDIO_PMD: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_MEMIF_PMD: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_NITROX_PMD: u32 = 1;
pub const RTE_LIBRTE_NODE: u32 = 1;
pub const RTE_LIBRTE_NULL_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_REGEX_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMPRESS_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_OPDL_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OPENSSL_PMD: u32 = 1;
pub const RTE_LIBRTE_PCAP_PMD: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_PFE_PMD: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_ACC100: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_FPGA_5GNR_FEC: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_FPGA_LTE_FEC: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_TURBO_SW: u32 = 1;
pub const RTE_LIBRTE_PMD_BCMFS: u32 = 1;
pub const RTE_LIBRTE_PMD_CAAM_JR: u32 = 1;
pub const RTE_LIBRTE_PMD_CCP: u32 = 1;
pub const RTE_LIBRTE_PMD_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_LIBRTE_PMD_DLB2_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DLB_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_CMDIF_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_QDMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_SEC: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA_SEC: u32 = 1;
pub const RTE_LIBRTE_PMD_DSW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IOAT_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_NITROX: u32 = 1;
pub const RTE_LIBRTE_PMD_NTB_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_DMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_EP_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_COMPRESS: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OPDL_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OPENSSL: u32 = 1;
pub const RTE_LIBRTE_PMD_SKELETON_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_VIRTIO_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_ZLIB: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_LIBRTE_QAT_COMMON: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RCU: u32 = 1;
pub const RTE_LIBRTE_REGEXDEV: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_RIB: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_RING_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_RING_PMD: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_SFC_EFX_COMMON: u32 = 1;
pub const RTE_LIBRTE_SFC_PMD: u32 = 1;
pub const RTE_LIBRTE_SKELETON_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_SOFTNIC_PMD: u32 = 1;
pub const RTE_LIBRTE_STACK: u32 = 1;
pub const RTE_LIBRTE_STACK_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_SW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_TAP_PMD: u32 = 1;
pub const RTE_LIBRTE_TELEMETRY: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_PMD: u32 = 1;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_TXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIBRTE_VHOST_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_LIBRTE_VMBUS_BUS: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_LIBRTE_ZLIB_PMD: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KNI: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 4;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_DPAA: u32 = 1;
pub const RTE_MEMPOOL_DPAA2: u32 = 1;
pub const RTE_MEMPOOL_OCTEONTX: u32 = 1;
pub const RTE_MEMPOOL_OCTEONTX2: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_NET_AF_PACKET: u32 = 1;
pub const RTE_NET_ARK: u32 = 1;
pub const RTE_NET_ATLANTIC: u32 = 1;
pub const RTE_NET_AVP: u32 = 1;
pub const RTE_NET_AXGBE: u32 = 1;
pub const RTE_NET_BNX2X: u32 = 1;
pub const RTE_NET_BNXT: u32 = 1;
pub const RTE_NET_BOND: u32 = 1;
pub const RTE_NET_CXGBE: u32 = 1;
pub const RTE_NET_DPAA: u32 = 1;
pub const RTE_NET_DPAA2: u32 = 1;
pub const RTE_NET_E1000: u32 = 1;
pub const RTE_NET_ENA: u32 = 1;
pub const RTE_NET_ENETC: u32 = 1;
pub const RTE_NET_ENIC: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_FM10K: u32 = 1;
pub const RTE_NET_HINIC: u32 = 1;
pub const RTE_NET_HNS3: u32 = 1;
pub const RTE_NET_I40E: u32 = 1;
pub const RTE_NET_IAVF: u32 = 1;
pub const RTE_NET_ICE: u32 = 1;
pub const RTE_NET_IGC: u32 = 1;
pub const RTE_NET_IXGBE: u32 = 1;
pub const RTE_NET_KNI: u32 = 1;
pub const RTE_NET_LIQUIDIO: u32 = 1;
pub const RTE_NET_MEMIF: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_NFP: u32 = 1;
pub const RTE_NET_NULL: u32 = 1;
pub const RTE_NET_OCTEONTX: u32 = 1;
pub const RTE_NET_OCTEONTX2: u32 = 1;
pub const RTE_NET_PCAP: u32 = 1;
pub const RTE_NET_PFE: u32 = 1;
pub const RTE_NET_QEDE: u32 = 1;
pub const RTE_NET_RING: u32 = 1;
pub const RTE_NET_SFC: u32 = 1;
pub const RTE_NET_SOFTNIC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_THUNDERX: u32 = 1;
pub const RTE_NET_TXGBE: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VHOST: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_NET_VMXNET3: u32 = 1;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_RAW_DPAA2_CMDIF: u32 = 1;
pub const RTE_RAW_DPAA2_QDMA: u32 = 1;
pub const RTE_RAW_IOAT: u32 = 1;
pub const RTE_RAW_NTB: u32 = 1;
pub const RTE_RAW_OCTEONTX2_DMA: u32 = 1;
pub const RTE_RAW_OCTEONTX2_EP: u32 = 1;
pub const RTE_RAW_SKELETON: u32 = 1;
pub const RTE_REGEX_OCTEONTX2: u32 = 1;
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_VDPA_IFC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 0;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const RTE_VER_YEAR: u32 = 20;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\0";
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_PMD_DLB_POLL_INTERVAL: u32 = 1000;
pub const RTE_LIBRTE_PMD_DLB_UMWAIT_CTL_STATE: u32 = 0;
pub const RTE_LIBRTE_PMD_DLB_SW_CREDIT_QUANTA: u32 = 32;
pub const RTE_LIBRTE_PMD_DLB2_POLL_INTERVAL: u32 = 1000;
pub const RTE_LIBRTE_PMD_DLB2_UMWAIT_CTL_STATE: u32 = 0;
pub const RTE_LIBRTE_PMD_DLB2_SW_CREDIT_QUANTA: u32 = 32;
pub const RTE_PMD_DLB2_DEFAULT_DEPTH_THRESH: u32 = 256;
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_UUID_STRLEN: u32 = 37;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const RTE_MEMSEG_FLAG_DO_NOT_FREE: u32 = 1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_BITMAP_SLAB_BIT_SIZE: u32 = 64;
pub const RTE_BITMAP_SLAB_BIT_SIZE_LOG2: u32 = 6;
pub const RTE_BITMAP_SLAB_BIT_MASK: u32 = 63;
pub const RTE_BITMAP_CL_BIT_SIZE: u32 = 512;
pub const RTE_BITMAP_CL_BIT_SIZE_LOG2: u32 = 9;
pub const RTE_BITMAP_CL_BIT_MASK: u32 = 511;
pub const RTE_BITMAP_CL_SLAB_SIZE: u32 = 8;
pub const RTE_BITMAP_CL_SLAB_SIZE_LOG2: u32 = 3;
pub const RTE_BITMAP_CL_SLAB_MASK: u32 = 7;
pub const RTE_KEEPALIVE_MAXCORES: u32 = 128;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\0";
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\0";
pub const MEMPOOL_PG_NUM_DEFAULT: u32 = 1;
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const PKT_RX_VLAN: u32 = 1;
pub const PKT_RX_RSS_HASH: u32 = 2;
pub const PKT_RX_FDIR: u32 = 4;
pub const PKT_RX_L4_CKSUM_BAD: u32 = 8;
pub const PKT_RX_IP_CKSUM_BAD: u32 = 16;
pub const PKT_RX_EIP_CKSUM_BAD: u32 = 32;
pub const PKT_RX_VLAN_STRIPPED: u32 = 64;
pub const PKT_RX_IP_CKSUM_MASK: u32 = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_IP_CKSUM_GOOD: u32 = 128;
pub const PKT_RX_IP_CKSUM_NONE: u32 = 144;
pub const PKT_RX_L4_CKSUM_MASK: u32 = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_L4_CKSUM_GOOD: u32 = 256;
pub const PKT_RX_L4_CKSUM_NONE: u32 = 264;
pub const PKT_RX_IEEE1588_PTP: u32 = 512;
pub const PKT_RX_IEEE1588_TMST: u32 = 1024;
pub const PKT_RX_FDIR_ID: u32 = 8192;
pub const PKT_RX_FDIR_FLX: u32 = 16384;
pub const PKT_RX_QINQ_STRIPPED: u32 = 32768;
pub const PKT_RX_LRO: u32 = 65536;
pub const PKT_RX_SEC_OFFLOAD: u32 = 262144;
pub const PKT_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const PKT_RX_QINQ: u32 = 1048576;
pub const PKT_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const PKT_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const PKT_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const PKT_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const PKT_FIRST_FREE: u32 = 8388608;
pub const PKT_LAST_FREE: u64 = 1099511627776;
pub const PKT_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const PKT_TX_UDP_SEG: u64 = 4398046511104;
pub const PKT_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const PKT_TX_MACSEC: u64 = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const PKT_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const PKT_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const PKT_TX_TUNNEL_IP: u64 = 457396837154816;
pub const PKT_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const PKT_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const PKT_TX_QINQ: u64 = 562949953421312;
pub const PKT_TX_QINQ_PKT: u64 = 562949953421312;
pub const PKT_TX_TCP_SEG: u64 = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: u32 = 0;
pub const PKT_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const PKT_TX_L4_MASK: u64 = 13510798882111488;
pub const PKT_TX_IP_CKSUM: u64 = 18014398509481984;
pub const PKT_TX_IPV4: u64 = 36028797018963968;
pub const PKT_TX_IPV6: u64 = 72057594037927936;
pub const PKT_TX_VLAN: u64 = 144115188075855872;
pub const PKT_TX_VLAN_PKT: u64 = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const PKT_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const EXT_ATTACHED_MBUF: u64 = 2305843009213693952;
pub const IND_ATTACHED_MBUF: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub const RTE_TIMER_STOP: u32 = 0;
pub const RTE_TIMER_PENDING: u32 = 1;
pub const RTE_TIMER_RUNNING: u32 = 2;
pub const RTE_TIMER_CONFIG: u32 = 3;
pub const RTE_TIMER_NO_OWNER: i32 = -2;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_PCI_CFG_SPACE_SIZE: u32 = 256;
pub const RTE_PCI_CFG_SPACE_EXP_SIZE: u32 = 4096;
pub const RTE_PCI_VENDOR_ID: u32 = 0;
pub const RTE_PCI_DEVICE_ID: u32 = 2;
pub const RTE_PCI_EXP_DEVCTL: u32 = 8;
pub const RTE_PCI_EXT_CAP_ID_ERR: u32 = 1;
pub const RTE_PCI_EXT_CAP_ID_DSN: u32 = 3;
pub const RTE_PCI_EXT_CAP_ID_SRIOV: u32 = 16;
pub const RTE_PCI_SRIOV_CAP: u32 = 4;
pub const RTE_PCI_SRIOV_CTRL: u32 = 8;
pub const RTE_PCI_SRIOV_INITIAL_VF: u32 = 12;
pub const RTE_PCI_SRIOV_TOTAL_VF: u32 = 14;
pub const RTE_PCI_SRIOV_NUM_VF: u32 = 16;
pub const RTE_PCI_SRIOV_FUNC_LINK: u32 = 18;
pub const RTE_PCI_SRIOV_VF_OFFSET: u32 = 20;
pub const RTE_PCI_SRIOV_VF_STRIDE: u32 = 22;
pub const RTE_PCI_SRIOV_VF_DID: u32 = 26;
pub const RTE_PCI_SRIOV_SUP_PGSIZE: u32 = 28;
pub const RTE_CLASS_ANY_ID: u32 = 16777215;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_QINQ1: u32 = 37120;
pub const RTE_ETHER_TYPE_QINQ2: u32 = 37376;
pub const RTE_ETHER_TYPE_QINQ3: u32 = 37632;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETHER_TYPE_ECPRI: u32 = 44798;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const RTE_ETH_LINK_MAX_STR_LEN: u32 = 40;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const RTE_ETH_RSS_L3_PRE32: u64 = 144115188075855872;
pub const RTE_ETH_RSS_L3_PRE40: u64 = 72057594037927936;
pub const RTE_ETH_RSS_L3_PRE48: u64 = 36028797018963968;
pub const RTE_ETH_RSS_L3_PRE56: u64 = 18014398509481984;
pub const RTE_ETH_RSS_L3_PRE64: u64 = 9007199254740992;
pub const RTE_ETH_RSS_L3_PRE96: u64 = 4503599627370496;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_IP_ICMP_ECHO_REPLY: u32 = 0;
pub const RTE_IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_MIN_MTU: u32 = 1280;
pub const RTE_IPV6_EHDR_MF_SHIFT: u32 = 0;
pub const RTE_IPV6_EHDR_MF_MASK: u32 = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV6_EHDR_FO_MASK: i32 = -8;
pub const RTE_IPV6_EHDR_FO_ALIGN: u32 = 8;
pub const RTE_IPV6_FRAG_USED_MASK: i32 = -7;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_ECPRI_REV_UP_TO_20: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_IQ_DATA: u32 = 0;
pub const RTE_ECPRI_MSG_TYPE_BIT_SEQ: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_RTC_CTRL: u32 = 2;
pub const RTE_ECPRI_MSG_TYPE_GEN_DATA: u32 = 3;
pub const RTE_ECPRI_MSG_TYPE_RM_ACC: u32 = 4;
pub const RTE_ECPRI_MSG_TYPE_DLY_MSR: u32 = 5;
pub const RTE_ECPRI_MSG_TYPE_RMT_RST: u32 = 6;
pub const RTE_ECPRI_MSG_TYPE_EVT_IND: u32 = 7;
pub const RTE_ECPRI_MSG_TYPE_IWF_UP: u32 = 8;
pub const RTE_ECPRI_MSG_TYPE_IWF_OPT: u32 = 9;
pub const RTE_ECPRI_MSG_TYPE_IWF_MAP: u32 = 10;
pub const RTE_ECPRI_MSG_TYPE_IWF_DCTRL: u32 = 11;
pub const RTE_ECPRI_EVT_IND_FAULT_IND: u32 = 0;
pub const RTE_ECPRI_EVT_IND_FAULT_ACK: u32 = 1;
pub const RTE_ECPRI_EVT_IND_NTFY_IND: u32 = 2;
pub const RTE_ECPRI_EVT_IND_SYNC_REQ: u32 = 3;
pub const RTE_ECPRI_EVT_IND_SYNC_ACK: u32 = 4;
pub const RTE_ECPRI_EVT_IND_SYNC_END: u32 = 5;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &'static [u8; 27usize] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &'static [u8; 26usize] = b"rte_flow_dynflag_metadata\0";
pub const RTE_MBUF_DYNFIELD_TIMESTAMP_NAME: &'static [u8; 23usize] = b"rte_dynfield_timestamp\0";
pub const RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME: &'static [u8; 25usize] = b"rte_dynflag_rx_timestamp\0";
pub const RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME: &'static [u8; 25usize] = b"rte_dynflag_tx_timestamp\0";
pub const RTE_FLOW_RESTORE_INFO_TUNNEL: u32 = 1;
pub const RTE_FLOW_RESTORE_INFO_ENCAPSULATED: u32 = 2;
pub const RTE_FLOW_RESTORE_INFO_GROUP_ID: u32 = 4;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT: u32 = 1048576;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_BURST_FLAG_PER_QUEUE: u32 = 1;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_FLOW_OPS_THREAD_SAFE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub const RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS: u32 = 64;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_KNI_NAMESIZE: u32 = 16;
pub const BONDING_MODE_ROUND_ROBIN: u32 = 0;
pub const BONDING_MODE_ACTIVE_BACKUP: u32 = 1;
pub const BONDING_MODE_BALANCE: u32 = 2;
pub const BONDING_MODE_BROADCAST: u32 = 3;
pub const BONDING_MODE_8023AD: u32 = 4;
pub const BONDING_MODE_TLB: u32 = 5;
pub const BONDING_MODE_ALB: u32 = 6;
pub const RTE_VXLAN_DEFAULT_PORT: u32 = 4789;
pub const RTE_VXLAN_GPE_DEFAULT_PORT: u32 = 4790;
pub const RTE_VXLAN_GPE_TYPE_IPV4: u32 = 1;
pub const RTE_VXLAN_GPE_TYPE_IPV6: u32 = 2;
pub const RTE_VXLAN_GPE_TYPE_ETH: u32 = 3;
pub const RTE_VXLAN_GPE_TYPE_NSH: u32 = 4;
pub const RTE_VXLAN_GPE_TYPE_MPLS: u32 = 5;
pub const RTE_VXLAN_GPE_TYPE_GBP: u32 = 6;
pub const RTE_VXLAN_GPE_TYPE_VBNG: u32 = 7;
pub const CMDLINE_KEY_UP_ARR: u32 = 0;
pub const CMDLINE_KEY_DOWN_ARR: u32 = 1;
pub const CMDLINE_KEY_RIGHT_ARR: u32 = 2;
pub const CMDLINE_KEY_LEFT_ARR: u32 = 3;
pub const CMDLINE_KEY_BKSPACE: u32 = 4;
pub const CMDLINE_KEY_RETURN: u32 = 5;
pub const CMDLINE_KEY_CTRL_A: u32 = 6;
pub const CMDLINE_KEY_CTRL_E: u32 = 7;
pub const CMDLINE_KEY_CTRL_K: u32 = 8;
pub const CMDLINE_KEY_CTRL_Y: u32 = 9;
pub const CMDLINE_KEY_CTRL_C: u32 = 10;
pub const CMDLINE_KEY_CTRL_F: u32 = 11;
pub const CMDLINE_KEY_CTRL_B: u32 = 12;
pub const CMDLINE_KEY_SUPPR: u32 = 13;
pub const CMDLINE_KEY_TAB: u32 = 14;
pub const CMDLINE_KEY_CTRL_D: u32 = 15;
pub const CMDLINE_KEY_CTRL_L: u32 = 16;
pub const CMDLINE_KEY_RETURN2: u32 = 17;
pub const CMDLINE_KEY_META_BKSPACE: u32 = 18;
pub const CMDLINE_KEY_WLEFT: u32 = 19;
pub const CMDLINE_KEY_WRIGHT: u32 = 20;
pub const CMDLINE_KEY_HELP: u32 = 21;
pub const CMDLINE_KEY_CTRL_W: u32 = 22;
pub const CMDLINE_KEY_CTRL_P: u32 = 23;
pub const CMDLINE_KEY_CTRL_N: u32 = 24;
pub const CMDLINE_KEY_META_D: u32 = 25;
pub const CMDLINE_KEY_BKSPACE2: u32 = 26;
pub const CMDLINE_VT100_BUF_SIZE: u32 = 8;
pub const CMDLINE_PARSE_SUCCESS: u32 = 0;
pub const CMDLINE_PARSE_AMBIGUOUS: i32 = -1;
pub const CMDLINE_PARSE_NOMATCH: i32 = -2;
pub const CMDLINE_PARSE_BAD_ARGS: i32 = -3;
pub const CMDLINE_PARSE_COMPLETE_FINISHED: u32 = 0;
pub const CMDLINE_PARSE_COMPLETE_AGAIN: u32 = 1;
pub const CMDLINE_PARSE_COMPLETED_BUFFER: u32 = 2;
pub const CMDLINE_PARSE_RESULT_BUFSIZE: u32 = 8192;
pub const CMDLINE_IPADDR_V4: u32 = 1;
pub const CMDLINE_IPADDR_V6: u32 = 2;
pub const CMDLINE_IPADDR_NETWORK: u32 = 4;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_sec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_nsec))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cpu_set_t), "::", stringify!(__bits))
    );
}
pub type rte_cpuset_t = cpu_set_t;
#[doc = " Physical address"]
pub type phys_addr_t = u64;
#[doc = " IO virtual address type."]
#[doc = " When the physical addressing mode (IOVA as PA) is in use,"]
#[doc = " the translation from an IO virtual address (IOVA) to a physical address"]
#[doc = " is a direct mapping, i.e. the same value."]
#[doc = " Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Generic marker for any place in a structure."]
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
#[doc = " Marker for 8B alignment in a structure."]
pub type RTE_MARKER64 = [u64; 0usize];
extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error"]
    #[doc = " message and returning the exit_code back to the shell."]
    #[doc = ""]
    #[doc = " This function never returns"]
    #[doc = ""]
    #[doc = " @param exit_code"]
    #[doc = "     The exit code to be returned by the application"]
    #[doc = " @param format"]
    #[doc = "     The format string to be used for printing the message. This can include"]
    #[doc = "     printf format characters which will be expanded using any further parameters"]
    #[doc = "     to the function."]
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic16_t {
    #[doc = "< An internal counter value."]
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic16_t>())).cnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_atomic16_t), "::", stringify!(cnt))
    );
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic32_t {
    #[doc = "< An internal counter value."]
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic32_t>())).cnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_atomic32_t), "::", stringify!(cnt))
    );
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic64_t {
    #[doc = "< Internal counter value."]
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic64_t>())).cnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_atomic64_t), "::", stringify!(cnt))
    );
}
#[doc = " 128-bit integer structure."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_int128_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).int128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(int128)
        )
    );
}
impl Default for rte_int128_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_int128_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t))
    );
}
impl Default for rte_int128_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_buf_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_markers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_chain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_fileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_old_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_cur_column))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_shortbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_codecvt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_wide_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_unused2))
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Change the stream that will be used by the logging system."]
    #[doc = ""]
    #[doc = " This can be done at any time. The f argument represents the stream"]
    #[doc = " to be used to send the logs. If f is NULL, the default output is"]
    #[doc = " used (stderr)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   Pointer to the stream."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative on error."]
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the stream used by the logging system (see rte_openlog_stream()"]
    #[doc = " to change it)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Pointer to the stream."]
    pub fn rte_log_get_stream() -> *mut FILE;
}
extern "C" {
    #[doc = " Set the global log level."]
    #[doc = ""]
    #[doc = " After this call, logs with a level lower or equal than the level"]
    #[doc = " passed as argument will be displayed."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    #[doc = " Get the global log level."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The current global log level."]
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    #[doc = " Get the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype is invalid."]
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For a given `logtype`, check if a log with `loglevel` can be printed."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier"]
    #[doc = " @param loglevel"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @return"]
    #[doc = " Returns 'true' if log can be printed and 'false' if it can't."]
    pub fn rte_log_can_log(logtype: u32, loglevel: u32) -> bool;
}
extern "C" {
    #[doc = " Set the log level for a given type based on globbing pattern."]
    #[doc = ""]
    #[doc = " @param pattern"]
    #[doc = "   The globbing pattern identifying the log type."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_pattern(pattern: *const ::std::os::raw::c_char, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type based on regular expression."]
    #[doc = ""]
    #[doc = " @param regex"]
    #[doc = "   The regular expression identifying the log type."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_regexp(regex: *const ::std::os::raw::c_char, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype or level is invalid."]
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current loglevel for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The loglevel of the message being processed."]
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current logtype for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The logtype of the message being processed."]
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic log type"]
    #[doc = ""]
    #[doc = " If a log is already registered with the same type, the returned value"]
    #[doc = " is the same than the previous one."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The string identifying the log type."]
    #[doc = " @return"]
    #[doc = "   - >0: success, the returned value is the log type identifier."]
    #[doc = "   - (-ENOMEM): cannot allocate memory."]
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Register a dynamic log type and try to pick its level from EAL options"]
    #[doc = ""]
    #[doc = " rte_log_register() is called inside. If successful, the function tries"]
    #[doc = " to search for matching regexp in the list of EAL log level options and"]
    #[doc = " pick the level from the last matching entry. If nothing can be applied"]
    #[doc = " from the list, the level will be set to the user-defined default value."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "    Name for the log type to be registered"]
    #[doc = " @param level_def"]
    #[doc = "    Fallback level to be set if the global list has no matching options"]
    #[doc = " @return"]
    #[doc = "    - >=0: the newly registered log type"]
    #[doc = "    - <0: rte_log_register() error value"]
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump log information."]
    #[doc = ""]
    #[doc = " Dump the global level and the registered log types."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The output stream where the dump should be sent."]
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the loglevel settings."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_log(level: u32, logtype: u32, format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the loglevel settings. A trailing"]
    #[doc = " newline may be added if needed."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @param ap"]
    #[doc = "   The va_list of the variable arguments required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the stack of the calling core to the console."]
    pub fn rte_dump_stack();
}
#[doc = " The rte_rwlock_t type."]
#[doc = ""]
#[doc = " cnt is -1 when write lock is held, and > 0 when read locks are held."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_rwlock_t {
    #[doc = "< -1 when W lock held, > 0 when R locks held."]
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_rwlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_rwlock_t>())).cnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_rwlock_t), "::", stringify!(cnt))
    );
}
pub mod rte_dev_event_type {
    #[doc = " The device event type."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< device being added"]
    pub const RTE_DEV_EVENT_ADD: Type = 0;
    #[doc = "< device being removed"]
    pub const RTE_DEV_EVENT_REMOVE: Type = 1;
    #[doc = "< max value of this enum"]
    pub const RTE_DEV_EVENT_MAX: Type = 2;
}
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub mod rte_dev_policy {
    #[doc = " Device policies."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_DEV_ALLOWED: Type = 0;
    pub const RTE_DEV_BLOCKED: Type = 1;
}
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_resource>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_mem_resource), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rte_mem_resource {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_driver__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver>(),
        32usize,
        concat!("Size of: ", stringify!(rte_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_driver), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).name as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_driver), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).alias as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_driver), "::", stringify!(alias))
    );
}
impl Default for rte_driver {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver assigned after probing"]
    pub driver: *const rte_driver,
    #[doc = "< Bus handle assigned on scan"]
    pub bus: *const rte_bus,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Arguments for latest probing"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_device__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_device>(),
        56usize,
        concat!("Size of: ", stringify!(rte_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).name as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).driver as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).bus as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).numa_node as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(numa_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).devargs as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rte_device), "::", stringify!(devargs))
    );
}
impl Default for rte_device {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Query status of a device."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Generic device pointer."]
    #[doc = " @return"]
    #[doc = "   (int)true if already probed successfully, 0 otherwise."]
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hotplug add a given device to a specific bus."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to add the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is added to."]
    #[doc = " @param devname"]
    #[doc = "   The device name. Based on this device name, eal will identify a driver"]
    #[doc = "   capable of handling it and pass it to the driver probing function."]
    #[doc = " @param drvargs"]
    #[doc = "   Device arguments to be passed to the driver."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add matching devices."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to add the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   Device arguments including bus, class and driver properties."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hotplug remove a given device from a specific bus."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to remove the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is removed from."]
    #[doc = " @param devname"]
    #[doc = "   The device name being removed."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove one device."]
    #[doc = ""]
    #[doc = " In multi-process, it will request other processes to remove the same device."]
    #[doc = " A failure, in any process, will rollback the action"]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   Data structure of the device to remove."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
#[doc = " Device comparison function."]
#[doc = ""]
#[doc = " This type of function is used to compare an rte_device with arbitrary"]
#[doc = " data."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Device handle."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "   Data to compare against. The type of this parameter is determined by"]
#[doc = "   the kind of comparison performed by the function."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   0 if the device matches the data."]
#[doc = "   !0 if the device does not match."]
#[doc = "   <0 if ordering is possible and the device is lower than the data."]
#[doc = "   >0 if ordering is possible and the device is greater than the data."]
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *const rte_device, data: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Iteration context."]
#[doc = ""]
#[doc = " This context carries over the current iteration state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_iterator {
    #[doc = "< device string."]
    pub dev_str: *const ::std::os::raw::c_char,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< current position."]
    pub device: *mut rte_device,
    #[doc = "< additional specialized context."]
    pub class_device: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_dev_iterator() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_iterator>(),
        56usize,
        concat!("Size of: ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).dev_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(dev_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus_str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_dev_iterator), "::", stringify!(bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_dev_iterator), "::", stringify!(cls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).class_device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(class_device)
        )
    );
}
impl Default for rte_dev_iterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Device iteration function."]
#[doc = ""]
#[doc = " Find the next device matching properties passed in parameters."]
#[doc = " The function takes an additional ``start`` parameter, that is"]
#[doc = " used as starting context when relevant."]
#[doc = ""]
#[doc = " The function returns the current element in the iteration."]
#[doc = " This return value will potentially be used as a start parameter"]
#[doc = " in subsequent calls to the function."]
#[doc = ""]
#[doc = " The additional iterator parameter is only there if a specific"]
#[doc = " implementation needs additional context. It must not be modified by"]
#[doc = " the iteration function itself."]
#[doc = ""]
#[doc = " @param start"]
#[doc = "   Starting iteration context."]
#[doc = ""]
#[doc = " @param devstr"]
#[doc = "   Device description string."]
#[doc = ""]
#[doc = " @param it"]
#[doc = "   Device iterator."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   The address of the current element matching the device description"]
#[doc = "   string."]
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " Initializes a device iterator."]
    #[doc = ""]
    #[doc = " This iterator allows accessing a list of devices matching a criteria."]
    #[doc = " The device matching is made among all buses and classes currently registered,"]
    #[doc = " filtered by the device description given as parameter."]
    #[doc = ""]
    #[doc = " This function will not allocate any memory. It is safe to stop the"]
    #[doc = " iteration at any moment and let the iterator go out of context."]
    #[doc = ""]
    #[doc = " @param it"]
    #[doc = "   Device iterator handle."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   Device description string."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful initialization."]
    #[doc = "   <0 on error."]
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates on a device iterator."]
    #[doc = ""]
    #[doc = " Generates a new rte_device handle corresponding to the next element"]
    #[doc = " in the list described in comprehension by the iterator."]
    #[doc = ""]
    #[doc = " The next object is returned, and the iterator is updated."]
    #[doc = ""]
    #[doc = " @param it"]
    #[doc = "   Device iterator handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   An rte_device handle if found."]
    #[doc = "   NULL if an error occurred (rte_errno is set)."]
    #[doc = "   NULL if no device could be found (rte_errno is not set)."]
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It registers the callback for the specific device."]
    #[doc = " Multiple callbacks can be registered at the same time."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name, that is the param name of the struct rte_device,"]
    #[doc = "  null value means for all devices."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It unregisters the callback according to the specified device."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name, that is the param name of the struct rte_device,"]
    #[doc = "  null value means for all devices and their callbacks."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Executes all the user application registered callbacks for"]
    #[doc = " the specific device."]
    #[doc = ""]
    #[doc = " @param device_name"]
    #[doc = "  The device name."]
    #[doc = " @param event"]
    #[doc = "  the device event type."]
    pub fn rte_dev_event_callback_process(device_name: *const ::std::os::raw::c_char, event: rte_dev_event_type::Type);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Start the device event monitoring."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Stop the device event monitoring."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Enable hotplug handling for devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Disable hotplug handling for devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Device level DMA map function."]
    #[doc = " After a successful call, the memory segment will be mapped to the"]
    #[doc = " given device."]
    #[doc = ""]
    #[doc = " @note: Memory must be registered in advance using rte_extmem_* APIs."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "\tDevice pointer."]
    #[doc = " @param addr"]
    #[doc = "\tVirtual address to map."]
    #[doc = " @param iova"]
    #[doc = "\tIOVA address to map."]
    #[doc = " @param len"]
    #[doc = "\tLength of the memory segment being mapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 if mapping was successful."]
    #[doc = "\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Device level DMA unmap function."]
    #[doc = " After a successful call, the memory segment will no longer be"]
    #[doc = " accessible by the given device."]
    #[doc = ""]
    #[doc = " @note: Memory must be registered in advance using rte_extmem_* APIs."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "\tDevice pointer."]
    #[doc = " @param addr"]
    #[doc = "\tVirtual address to unmap."]
    #[doc = " @param iova"]
    #[doc = "\tIOVA address to unmap."]
    #[doc = " @param len"]
    #[doc = "\tLength of the memory segment being mapped."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 if un-mapping was successful."]
    #[doc = "\tNegative value and rte_errno is set otherwise."]
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Double linked list of buses"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_bus_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_iova_mode {
    #[doc = " IOVA mapping mode."]
    #[doc = ""]
    #[doc = " IOVA mapping mode is iommu programming mode of a device."]
    #[doc = " That device (for example: IOMMU backed DMA device) based"]
    #[doc = " on rte_iova_mode will generate physical or virtual address."]
    #[doc = ""]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_IOVA_DC: Type = 0;
    pub const RTE_IOVA_PA: Type = 1;
    pub const RTE_IOVA_VA: Type = 2;
}
#[doc = " Bus specific scan for devices attached on the bus."]
#[doc = " For each bus object, the scan would be responsible for finding devices and"]
#[doc = " adding them to its private device list."]
#[doc = ""]
#[doc = " A bus should mandatorily implement this method."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful scan"]
#[doc = "\t<0 for unsuccessful scan with error value"]
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " This is called while iterating over each registered bus."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful probe"]
#[doc = "\t!0 for any error while probing"]
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Device iterator to find a device on a bus."]
#[doc = ""]
#[doc = " This function returns an rte_device if one of those held by the bus"]
#[doc = " matches the data passed as parameter."]
#[doc = ""]
#[doc = " If the comparison function returns zero this function should stop iterating"]
#[doc = " over any more devices. To continue a search the device of a previous search"]
#[doc = " can be passed via the start parameter."]
#[doc = ""]
#[doc = " @param cmp"]
#[doc = "\tComparison function."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare each device against."]
#[doc = ""]
#[doc = " @param start"]
#[doc = "\tstarting point for the iteration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "\tThe first device matching the data, NULL if none exists."]
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_plug_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Implementation specific remove function which is responsible for unlinking"]
#[doc = " devices on that bus from assigned driver."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_unplug_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Bus specific parsing function."]
#[doc = " Validates the syntax used in the textual representation of a device,"]
#[doc = " If the syntax is valid and ``addr`` is not NULL, writes the bus-specific"]
#[doc = " device representation to ``addr``."]
#[doc = ""]
#[doc = " @param[in] name"]
#[doc = "\tdevice textual description"]
#[doc = ""]
#[doc = " @param[out] addr"]
#[doc = "\tdevice information location address, into which parsed info"]
#[doc = "\tshould be written. If NULL, nothing should be written, which"]
#[doc = "\tis not an error."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if parsing was successful."]
#[doc = "\t!0 for any error."]
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Device level DMA map function."]
#[doc = " After a successful call, the memory segment will be mapped to the"]
#[doc = " given device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer."]
#[doc = " @param addr"]
#[doc = "\tVirtual address to map."]
#[doc = " @param iova"]
#[doc = "\tIOVA address to map."]
#[doc = " @param len"]
#[doc = "\tLength of the memory segment being mapped."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if mapping was successful."]
#[doc = "\tNegative value and rte_errno is set otherwise."]
pub type rte_dev_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Device level DMA unmap function."]
#[doc = " After a successful call, the memory segment will no longer be"]
#[doc = " accessible by the given device."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer."]
#[doc = " @param addr"]
#[doc = "\tVirtual address to unmap."]
#[doc = " @param iova"]
#[doc = "\tIOVA address to unmap."]
#[doc = " @param len"]
#[doc = "\tLength of the memory segment being mapped."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if un-mapping was successful."]
#[doc = "\tNegative value and rte_errno is set otherwise."]
pub type rte_dev_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Implement a specific hot-unplug handler, which is responsible for"]
#[doc = " handle the failure when device be hot-unplugged. When the event of"]
#[doc = " hot-unplug be detected, it could call this function to handle"]
#[doc = " the hot-unplug failure and avoid app crash."]
#[doc = " @param dev"]
#[doc = "\tPointer of the device structure."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Implement a specific sigbus handler, which is responsible for handling"]
#[doc = " the sigbus error which is either original memory error, or specific memory"]
#[doc = " error that caused of device be hot-unplugged. When sigbus error be captured,"]
#[doc = " it could call this function to handle sigbus error."]
#[doc = " @param failure_addr"]
#[doc = "\tPointer of the fault address of the sigbus error."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for success handle the sigbus for hot-unplug."]
#[doc = "\t1 for not process it, because it is a generic sigbus error."]
#[doc = "\t-1 for failed to handle the sigbus for hot-unplug."]
pub type rte_bus_sigbus_handler_t =
    ::std::option::Option<unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
pub mod rte_bus_scan_mode {
    #[doc = " Bus scan policies"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_BUS_SCAN_UNDEFINED: Type = 0;
    pub const RTE_BUS_SCAN_ALLOWLIST: Type = 1;
    pub const RTE_BUS_SCAN_BLOCKLIST: Type = 2;
}
#[doc = " A structure used to configure bus operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_conf {
    #[doc = "< Scan policy."]
    pub scan_mode: rte_bus_scan_mode::Type,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_conf>())).scan_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_conf),
            "::",
            stringify!(scan_mode)
        )
    );
}
impl Default for rte_bus_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Get common iommu class of the all the devices on the bus. The bus may"]
#[doc = " check that those devices are attached to iommu driver."]
#[doc = " If no devices are attached to the bus. The bus may return with don't care"]
#[doc = " (_DC) value."]
#[doc = " Otherwise, The bus will return appropriate _pa or _va iova mode."]
#[doc = ""]
#[doc = " @return"]
#[doc = "      enum rte_iova_mode value."]
pub type rte_bus_get_iommu_class_t = ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode::Type>;
#[doc = " A structure describing a generic bus."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus {
    #[doc = "< Next bus object in linked list"]
    pub next: rte_bus__bindgen_ty_1,
    #[doc = "< Name of the bus"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Scan for devices attached to bus"]
    pub scan: rte_bus_scan_t,
    #[doc = "< Probe devices on bus"]
    pub probe: rte_bus_probe_t,
    #[doc = "< Find a device on the bus"]
    pub find_device: rte_bus_find_device_t,
    #[doc = "< Probe single device for drivers"]
    pub plug: rte_bus_plug_t,
    #[doc = "< Remove single device from driver"]
    pub unplug: rte_bus_unplug_t,
    #[doc = "< Parse a device name"]
    pub parse: rte_bus_parse_t,
    #[doc = "< DMA map for device in the bus"]
    pub dma_map: rte_dev_dma_map_t,
    #[doc = "< DMA unmap for device in the bus"]
    pub dma_unmap: rte_dev_dma_unmap_t,
    #[doc = "< Bus configuration"]
    pub conf: rte_bus_conf,
    #[doc = "< Get iommu class"]
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    #[doc = "< Device iterator."]
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_bus__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus>(),
        128usize,
        concat!("Size of: ", stringify!(rte_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).name as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).scan as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(scan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).probe as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(probe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).find_device as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(find_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).plug as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(plug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).unplug as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(unplug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).parse as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(parse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_map as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(dma_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_unmap as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(dma_unmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).conf as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).get_iommu_class as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(get_iommu_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dev_iterate as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(rte_bus), "::", stringify!(dev_iterate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).hot_unplug_handler as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(hot_unplug_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).sigbus_handler as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(sigbus_handler)
        )
    );
}
impl Default for rte_bus {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Register a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be registered."]
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Unregister a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be unregistered."]
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Scan all the buses."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 in case of success in scanning all buses"]
    #[doc = "  !0 in case of failure to scan"]
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For each device on the buses, perform a driver 'match' and call the"]
    #[doc = " driver-specific probe for device initialization."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t 0 for successful match/probe"]
    #[doc = "\t!0 otherwise"]
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump information of all the buses registered with EAL."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "\t A valid and open output stream handle"]
    pub fn rte_bus_dump(f: *mut FILE);
}
#[doc = " Bus comparison function."]
#[doc = ""]
#[doc = " @param bus"]
#[doc = "\tBus under test."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare against."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if the bus matches the data."]
#[doc = "\t!0 if the bus does not match."]
#[doc = "\t<0 if ordering is possible and the bus is lower than the data."]
#[doc = "\t>0 if ordering is possible and the bus is greater than the data."]
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(bus: *const rte_bus, data: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Bus iterator to find a particular bus."]
    #[doc = ""]
    #[doc = " This function compares each registered bus to find one that matches"]
    #[doc = " the data passed as parameter."]
    #[doc = ""]
    #[doc = " If the comparison function returns zero this function will stop iterating"]
    #[doc = " over any more buses. To continue a search the bus of a previous search can"]
    #[doc = " be passed via the start parameter."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "\tStarting point for the iteration."]
    #[doc = ""]
    #[doc = " @param cmp"]
    #[doc = "\tComparison function."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = "\t Data to pass to comparison function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t A pointer to a rte_bus structure or NULL in case no bus matches"]
    pub fn rte_bus_find(start: *const rte_bus, cmp: rte_bus_cmp_t, data: *const ::std::os::raw::c_void)
        -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a particular device."]
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a given name."]
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Get the common iommu class of devices bound on to buses available in the"]
    #[doc = " system. RTE_IOVA_DC means that no preference has been expressed."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     enum rte_iova_mode value."]
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode::Type;
}
#[doc = " Struct describing a Universal Unique Identifier"]
pub type rte_uuid_t = [::std::os::raw::c_uchar; 16usize];
extern "C" {
    #[doc = " Test if UUID is all zeros."]
    #[doc = ""]
    #[doc = " @param uu"]
    #[doc = "    The uuid to check."]
    #[doc = " @return"]
    #[doc = "    true if uuid is NULL value, false otherwise"]
    pub fn rte_uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> bool;
}
extern "C" {
    #[doc = " Compare two UUID's"]
    #[doc = ""]
    #[doc = " @param a"]
    #[doc = "    A UUID to compare"]
    #[doc = " @param b"]
    #[doc = "    A UUID to compare"]
    #[doc = " @return"]
    #[doc = "   returns an integer less than, equal to, or greater than zero if UUID a is"]
    #[doc = "   is less than, equal, or greater than UUID b."]
    pub fn rte_uuid_compare(a: *mut ::std::os::raw::c_uchar, b: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract UUID from string"]
    #[doc = ""]
    #[doc = " @param in"]
    #[doc = "    Pointer to string of characters to convert"]
    #[doc = " @param uu"]
    #[doc = "    Destination UUID"]
    #[doc = " @return"]
    #[doc = "    Returns 0 on success, and -1 if string is not a valid UUID."]
    pub fn rte_uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_uuid_unparse(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char, len: usize);
}
pub mod rte_intr_mode {
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_INTR_MODE_NONE: Type = 0;
    pub const RTE_INTR_MODE_LEGACY: Type = 1;
    pub const RTE_INTR_MODE_MSI: Type = 2;
    pub const RTE_INTR_MODE_MSIX: Type = 3;
}
pub mod rte_proc_type_t {
    #[doc = " The type of process in a linux, multi-process setup"]
    pub type Type = ::std::os::raw::c_int;
    pub const RTE_PROC_AUTO: Type = -1;
    pub const RTE_PROC_PRIMARY: Type = 0;
    pub const RTE_PROC_SECONDARY: Type = 1;
    pub const RTE_PROC_INVALID: Type = 2;
}
extern "C" {
    #[doc = " Get the process type in a multi-process setup"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t::Type;
}
extern "C" {
    #[doc = " Request iopl privilege for all RPL."]
    #[doc = ""]
    #[doc = " This function should be called by pmds which need access to ioports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, returns 0."]
    #[doc = "   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL)."]
    #[doc = ""]
    #[doc = " This function is to be executed on the MAIN lcore only, as soon"]
    #[doc = " as possible in the application's main() function."]
    #[doc = " It puts the WORKER lcores in the WAIT state."]
    #[doc = ""]
    #[doc = " @param argc"]
    #[doc = "   A non-negative value.  If it is greater than 0, the array members"]
    #[doc = "   for argv[0] through argv[argc] (non-inclusive) shall contain pointers"]
    #[doc = "   to strings."]
    #[doc = " @param argv"]
    #[doc = "   An array of strings.  The contents of the array, as well as the strings"]
    #[doc = "   which are pointed to by the array, may be modified by this function."]
    #[doc = " @return"]
    #[doc = "   - On success, the number of parsed arguments, which is greater or"]
    #[doc = "     equal to zero. After the call to rte_eal_init(),"]
    #[doc = "     all arguments argv[x] with x < ret may have been modified by this"]
    #[doc = "     function call and should not be further interpreted by the"]
    #[doc = "     application.  The EAL does not take any ownership of the memory used"]
    #[doc = "     for either the argv array, or its members."]
    #[doc = "   - On failure, -1 and rte_errno is set to a value indicating the cause"]
    #[doc = "     for failure.  In some instances, the application will need to be"]
    #[doc = "     restarted as part of clearing the issue."]
    #[doc = ""]
    #[doc = "   Error codes returned via rte_errno:"]
    #[doc = "     EACCES indicates a permissions issue."]
    #[doc = ""]
    #[doc = "     EAGAIN indicates either a bus or system resource was not available,"]
    #[doc = "            setup may be attempted again."]
    #[doc = ""]
    #[doc = "     EALREADY indicates that the rte_eal_init function has already been"]
    #[doc = "              called, and cannot be called again."]
    #[doc = ""]
    #[doc = "     EFAULT indicates the tailq configuration name was not found in"]
    #[doc = "            memory configuration."]
    #[doc = ""]
    #[doc = "     EINVAL indicates invalid parameters were passed as argv/argc."]
    #[doc = ""]
    #[doc = "     ENOMEM indicates failure likely caused by an out-of-memory condition."]
    #[doc = ""]
    #[doc = "     ENODEV indicates memory setup issues."]
    #[doc = ""]
    #[doc = "     ENOTSUP indicates that the EAL cannot initialize on this system."]
    #[doc = ""]
    #[doc = "     EPROTO indicates that the PCI bus is either not present, or is not"]
    #[doc = "            readable by the eal."]
    #[doc = ""]
    #[doc = "     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)"]
    #[doc = ""]
    #[doc = " This function must be called to release any internal resources that EAL has"]
    #[doc = " allocated during rte_eal_init(). After this call, no DPDK function calls may"]
    #[doc = " be made. It is expected that common usage of this function is to call it"]
    #[doc = " just before terminating the process."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 Successfully released all internal EAL resources."]
    #[doc = "  - -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a primary process is currently alive"]
    #[doc = ""]
    #[doc = " This function returns true when a primary process is currently"]
    #[doc = " active."]
    #[doc = ""]
    #[doc = " @param config_file_path"]
    #[doc = "   The config_file_path argument provided should point at the location"]
    #[doc = "   that the primary process will create its config file. If NULL, the default"]
    #[doc = "   config file path is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - If alive, returns 1."]
    #[doc = "  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(config_file_path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable multiprocess."]
    #[doc = ""]
    #[doc = " This function can be called to indicate that multiprocess won't be used for"]
    #[doc = " the rest of the application life."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - true if called from a primary process that had no secondary processes"]
    #[doc = "     attached,"]
    #[doc = "   - false, otherwise."]
    pub fn rte_mp_disable() -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_rte_mp_msg() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_msg>(),
        360usize,
        concat!("Size of: ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mp_msg), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).len_param as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_mp_msg), "::", stringify!(len_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).num_fds as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(rte_mp_msg), "::", stringify!(num_fds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).param as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rte_mp_msg), "::", stringify!(param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).fds as *const _ as usize },
        328usize,
        concat!("Offset of field: ", stringify!(rte_mp_msg), "::", stringify!(fds))
    );
}
impl Default for rte_mp_msg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[test]
fn bindgen_test_layout_rte_mp_reply() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_reply>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_sent as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mp_reply), "::", stringify!(nb_sent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_received as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).msgs as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_mp_reply), "::", stringify!(msgs))
    );
}
impl Default for rte_mp_reply {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Action function typedef used by other components."]
#[doc = ""]
#[doc = " As we create  socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming messages."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(msg: *const rte_mp_msg, peer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components."]
#[doc = ""]
#[doc = " As we create socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming responses to asynchronous"]
#[doc = " requests."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(request: *const rte_mp_msg, reply: *const rte_mp_reply) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Register an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to register an action, if the calling component wants"]
    #[doc = " to response the messages from the corresponding component in its primary"]
    #[doc = " process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    #[doc = " @param action"]
    #[doc = "   The action argument is the function pointer to the action function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - (<0) on failure."]
    pub fn rte_mp_action_register(name: *const ::std::os::raw::c_char, action: rte_mp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Unregister an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to unregister an action  if the calling component does"]
    #[doc = " not want to response the messages from the corresponding component in its"]
    #[doc = " primary process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a message to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a message which will be responded by the action"]
    #[doc = " identified by name in the peer process."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a request to the peer process and expect a reply."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will"]
    #[doc = " block until receiving reply message from the peer process."]
    #[doc = ""]
    #[doc = " @note The caller is responsible to free reply->replies."]
    #[doc = ""]
    #[doc = " @note This API must not be used inside memory-related or IPC callbacks, and"]
    #[doc = "   no memory allocations should take place inside such callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param reply"]
    #[doc = "   The reply argument will be for storing all the replied messages;"]
    #[doc = "   the caller is responsible for free reply->msgs."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a request to the peer process and expect a reply in a separate callback."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will not"]
    #[doc = " block. Instead, reply will be received in a separate callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   The callback to trigger when all responses for this request have arrived."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a reply to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a reply message in response to a request message"]
    #[doc = " received previously."]
    #[doc = ""]
    #[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
    #[doc = "   cases of error handling. Simply returning success or failure will *not*"]
    #[doc = "   send a response to the requestor."]
    #[doc = "   Implementation of error signalling mechanism is up to the application."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @param peer"]
    #[doc = "   The peer argument is the pointer to the peer socket path."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_reply(msg: *mut rte_mp_msg, peer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " Usage function typedef used by the application usage function."]
#[doc = ""]
#[doc = " Use this function typedef to define and call rte_set_application_usage_hook()"]
#[doc = " routine."]
pub type rte_usage_hook_t = ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine."]
    #[doc = ""]
    #[doc = " This function allows the application to include its usage message"]
    #[doc = " in the EAL system usage message. The routine rte_set_application_usage_hook()"]
    #[doc = " needs to be called before the rte_eal_init() routine in the application."]
    #[doc = ""]
    #[doc = " This routine is optional for the application and will behave as if the set"]
    #[doc = " routine was never called as the default behavior."]
    #[doc = ""]
    #[doc = " @param usage_func"]
    #[doc = "   The func argument is a function pointer to the application usage routine."]
    #[doc = "   Called function is defined using rte_usage_hook_t typedef, which is of"]
    #[doc = "   the form void rte_usage_func(const char * prgname)."]
    #[doc = ""]
    #[doc = "   Calling this routine with a NULL value will reset the usage hook routine and"]
    #[doc = "   return the current value, which could be NULL."]
    #[doc = " @return"]
    #[doc = "   - Returns the current value of the rte_application_usage pointer to allow"]
    #[doc = "     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option)."]
    #[doc = " The no-huge mode is not compatible with all drivers or features."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether EAL is using PCI bus."]
    #[doc = " Disabled by --no-pci option."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The user-configured vfio interrupt mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Interrupt mode configured with the command line,"]
    #[doc = "   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode::Type;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Copy the user-configured vfio VF token."]
    #[doc = ""]
    #[doc = " @param vf_token"]
    #[doc = "   vfio VF token configured with the command line is copied"]
    #[doc = "   into this parameter, zero uuid by default."]
    pub fn rte_eal_vfio_get_vf_token(vf_token: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " A wrap API for syscall gettid."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, returns the thread ID of calling process."]
    #[doc = "   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut per_lcore__thread_id: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the iova mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode::Type;
}
extern "C" {
    #[doc = " Get user provided pool ops name for mbuf"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the runtime directory of DPDK"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
pub mod rte_lcore_state_t {
    #[doc = " State of an lcore."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< waiting a new command"]
    pub const WAIT: Type = 0;
    #[doc = "< executing command"]
    pub const RUNNING: Type = 1;
    #[doc = "< command executed"]
    pub const FINISHED: Type = 2;
}
#[doc = " Definition of a remote launch function."]
pub type lcore_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " Launch a function on another lcore."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " Sends a message to a worker lcore (identified by the worker_id) that"]
    #[doc = " is in the WAIT state (this is true after the first call to"]
    #[doc = " rte_eal_init()). This can be checked by first calling"]
    #[doc = " rte_eal_wait_lcore(worker_id)."]
    #[doc = ""]
    #[doc = " When the remote lcore receives the message, it switches to"]
    #[doc = " the RUNNING state, then calls the function f with argument arg. Once the"]
    #[doc = " execution is done, the remote lcore switches to a FINISHED state and"]
    #[doc = " the return value of f is stored in a local variable to be read using"]
    #[doc = " rte_eal_wait_lcore()."]
    #[doc = ""]
    #[doc = " The MAIN lcore returns as soon as the message is sent and knows"]
    #[doc = " nothing about the completion of f."]
    #[doc = ""]
    #[doc = " Note: This function is not designed to offer optimum"]
    #[doc = " performance. It is just a practical way to launch a function on"]
    #[doc = " another lcore at initialization time."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore on which the function should be executed."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on the remote lcore."]
    #[doc = "   - (-EBUSY): The remote lcore is not in a WAIT state."]
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        worker_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_rmt_call_main_t {
    #[doc = " This enum indicates whether the main core must execute the handler"]
    #[doc = " launched on all logical cores."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< lcore handler not executed by main core."]
    pub const SKIP_MAIN: Type = 0;
    #[doc = "< lcore handler executed by main core."]
    pub const CALL_MAIN: Type = 1;
}
extern "C" {
    #[doc = " Launch a function on all lcores."]
    #[doc = ""]
    #[doc = " Check that each WORKER lcore is in a WAIT state, then call"]
    #[doc = " rte_eal_remote_launch() for each lcore."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param call_main"]
    #[doc = "   If call_main set to SKIP_MAIN, the MAIN lcore does not call"]
    #[doc = "   the function. If call_main is set to CALL_MAIN, the function"]
    #[doc = "   is also called on main before returning. In any case, the main"]
    #[doc = "   lcore returns as soon as it finished its job and knows nothing"]
    #[doc = "   about the completion of f on the other lcores."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on all remote lcores."]
    #[doc = "   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this"]
    #[doc = "     case, no message is sent to any of the lcores."]
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_main: rte_rmt_call_main_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the state of the lcore identified by worker_id."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   The state of the lcore."]
    pub fn rte_eal_get_lcore_state(worker_id: ::std::os::raw::c_uint) -> rte_lcore_state_t::Type;
}
extern "C" {
    #[doc = " Wait until an lcore finishes its job."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only."]
    #[doc = ""]
    #[doc = " If the worker lcore identified by the worker_id is in a FINISHED state,"]
    #[doc = " switch to the WAIT state. If the lcore is in RUNNING state, wait until"]
    #[doc = " the lcore finishes its job and moves to the FINISHED state."]
    #[doc = ""]
    #[doc = " @param worker_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   - 0: If the lcore identified by the worker_id is in a WAIT state."]
    #[doc = "   - The value that was returned by the previous remote launch"]
    #[doc = "     function call if the lcore identified by the worker_id was in a"]
    #[doc = "     FINISHED or RUNNING state. In this case, it changes the state"]
    #[doc = "     of the lcore to WAIT."]
    pub fn rte_eal_wait_lcore(worker_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait until all lcores finish their jobs."]
    #[doc = ""]
    #[doc = " To be executed on the MAIN lcore only. Issue an"]
    #[doc = " rte_eal_wait_lcore() for every lcore. The return values are"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " After a call to rte_eal_mp_wait_lcore(), the caller can assume"]
    #[doc = " that all worker lcores are in a WAIT state."]
    pub fn rte_eal_mp_wait_lcore();
}
extern "C" {
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
pub mod rte_lcore_role_t {
    #[doc = " The lcore role (used in RTE or not)."]
    pub type Type = ::std::os::raw::c_uint;
    pub const ROLE_RTE: Type = 0;
    pub const ROLE_OFF: Type = 1;
    pub const ROLE_SERVICE: Type = 2;
    pub const ROLE_NON_EAL: Type = 3;
}
extern "C" {
    #[doc = " Get a lcore's role."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   The role of the lcore."]
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t::Type;
}
extern "C" {
    #[doc = " Test if the core supplied has a specific role"]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and"]
    #[doc = "   RTE_MAX_LCORE-1."]
    #[doc = " @param role"]
    #[doc = "   The role to be checked against."]
    #[doc = " @return"]
    #[doc = "   Boolean value: positive if test is true; otherwise returns 0."]
    pub fn rte_lcore_has_role(lcore_id: ::std::os::raw::c_uint, role: rte_lcore_role_t::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the id of the main lcore"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the id of the main lcore"]
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of execution units (lcores) on the system."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the number of execution units (lcores) on the system."]
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the index of the lcore starting from zero."]
    #[doc = ""]
    #[doc = " When option -c or -l is given, the index corresponds"]
    #[doc = " to the order in the list."]
    #[doc = " For example:"]
    #[doc = " -c 0x30, lcore 4 has index 0, and 5 has index 1."]
    #[doc = " -l 22,18 lcore 22 has index 0, and 18 has index 1."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The targeted lcore, or -1 for the current one."]
    #[doc = " @return"]
    #[doc = "   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the ID of the physical socket of the logical core we are"]
    #[doc = " running on."]
    #[doc = " @return"]
    #[doc = "   the ID of current lcoreid's physical socket"]
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return number of physical sockets detected on the system."]
    #[doc = ""]
    #[doc = " Note that number of nodes may not be correspondent to their physical id's:"]
    #[doc = " for example, a system may report two socket id's, but the actual socket id's"]
    #[doc = " may be 0 and 8."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the number of physical sockets as recognized by EAL"]
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return socket id with a particular index."]
    #[doc = ""]
    #[doc = " This will return socket id at a particular position in list of all detected"]
    #[doc = " physical socket id's. For example, on a machine with sockets [0, 8], passing"]
    #[doc = " 1 as a parameter will return 8."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   index of physical socket id to return"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - physical socket id as recognized by EAL"]
    #[doc = "   - -1 on error, with errno set to EINVAL"]
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the ID of the physical socket of the specified lcore"]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   the targeted lcore, which MUST be between 0 and RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   the ID of lcoreid's physical socket"]
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Return the id of the lcore on a socket starting from zero."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The targeted lcore, or -1 for the current one."]
    #[doc = " @return"]
    #[doc = "   The relative index, or -1 if not enabled."]
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Return the cpuset for a given lcore."]
    #[doc = " @param lcore_id"]
    #[doc = "   the targeted lcore, which MUST be between 0 and RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   The cpuset of that lcore"]
    pub fn rte_lcore_cpuset(lcore_id: ::std::os::raw::c_uint) -> rte_cpuset_t;
}
extern "C" {
    #[doc = " Test if an lcore is enabled."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore, which MUST be between 0 and"]
    #[doc = "   RTE_MAX_LCORE-1."]
    #[doc = " @return"]
    #[doc = "   True if the given lcore is enabled; false otherwise."]
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next enabled lcore ID."]
    #[doc = ""]
    #[doc = " @param i"]
    #[doc = "   The current lcore (reference)."]
    #[doc = " @param skip_main"]
    #[doc = "   If true, do not return the ID of the main lcore."]
    #[doc = " @param wrap"]
    #[doc = "   If true, go back to 0 when RTE_MAX_LCORE is reached; otherwise,"]
    #[doc = "   return RTE_MAX_LCORE."]
    #[doc = " @return"]
    #[doc = "   The next lcore_id or RTE_MAX_LCORE if not found."]
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_main: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Callback prototype for initializing lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer passed at callback registration."]
#[doc = " @return"]
#[doc = "   - -1 when refusing this operation,"]
#[doc = "   - 0 otherwise."]
pub type rte_lcore_init_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Callback prototype for uninitializing lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer passed at callback registration."]
pub type rte_lcore_uninit_cb =
    ::std::option::Option<unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Register callbacks invoked when initializing and uninitializing a lcore."]
    #[doc = ""]
    #[doc = " This function calls the init callback with all initialized lcores."]
    #[doc = " Any error reported by the init callback triggers a rollback calling the"]
    #[doc = " uninit callback for each lcore."]
    #[doc = " If this step succeeds, the callbacks are put in the lcore callbacks list"]
    #[doc = " that will get called for each lcore allocation/release."]
    #[doc = ""]
    #[doc = " Note: callbacks execution is serialised under a write lock protecting the"]
    #[doc = " lcores and callbacks list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A name serving as a small description for this callback."]
    #[doc = " @param init"]
    #[doc = "   The callback invoked when a lcore_id is initialized."]
    #[doc = "   init can be NULL."]
    #[doc = " @param uninit"]
    #[doc = "   The callback invoked when a lcore_id is uninitialized."]
    #[doc = "   uninit can be NULL."]
    #[doc = " @param arg"]
    #[doc = "   An optional argument that gets passed to the callback when it gets"]
    #[doc = "   invoked."]
    #[doc = " @return"]
    #[doc = "   On success, returns an opaque pointer for the registered object."]
    #[doc = "   On failure (either memory allocation issue in the function itself or an"]
    #[doc = "   error is returned by the init callback itself), returns NULL."]
    pub fn rte_lcore_callback_register(
        name: *const ::std::os::raw::c_char,
        init: rte_lcore_init_cb,
        uninit: rte_lcore_uninit_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Unregister callbacks previously registered with rte_lcore_callback_register."]
    #[doc = ""]
    #[doc = " This function calls the uninit callback with all initialized lcores."]
    #[doc = " The callbacks are then removed from the lcore callbacks list."]
    #[doc = ""]
    #[doc = " @param handle"]
    #[doc = "   The handle pointer returned by a former successful call to"]
    #[doc = "   rte_lcore_callback_register."]
    pub fn rte_lcore_callback_unregister(handle: *mut ::std::os::raw::c_void);
}
#[doc = " Callback prototype for iterating over lcores."]
#[doc = ""]
#[doc = " @param lcore_id"]
#[doc = "   The lcore to consider."]
#[doc = " @param arg"]
#[doc = "   An opaque pointer coming from the caller."]
#[doc = " @return"]
#[doc = "   - 0 lets the iteration continue."]
#[doc = "   - !0 makes the iteration stop."]
pub type rte_lcore_iterate_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Iterate on all active lcores (ROLE_RTE, ROLE_SERVICE and ROLE_NON_EAL)."]
    #[doc = " No modification on the lcore states is allowed in the callback."]
    #[doc = ""]
    #[doc = " Note: as opposed to init/uninit callbacks, iteration callbacks can be"]
    #[doc = " invoked in parallel as they are run under a read lock protecting the lcores"]
    #[doc = " and callbacks list."]
    #[doc = ""]
    #[doc = " @param cb"]
    #[doc = "   The callback that gets passed each lcore."]
    #[doc = " @param arg"]
    #[doc = "   An opaque pointer passed to cb."]
    #[doc = " @return"]
    #[doc = "   Same return code as the callback last invocation (see rte_lcore_iterate_cb"]
    #[doc = "   description)."]
    pub fn rte_lcore_iterate(cb: rte_lcore_iterate_cb, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " List all lcores."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The output stream where the dump should be sent."]
    pub fn rte_lcore_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Set core affinity of the current thread."]
    #[doc = " Support both EAL and non-EAL thread and update TLS."]
    #[doc = ""]
    #[doc = " @param cpusetp"]
    #[doc = "   Point to cpu_set_t for setting current thread affinity."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return -1;"]
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get core affinity of the current thread."]
    #[doc = ""]
    #[doc = " @param cpusetp"]
    #[doc = "   Point to cpu_set_t for getting current thread cpu affinity."]
    #[doc = "   It presumes input is not NULL, otherwise it causes panic."]
    #[doc = ""]
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    #[doc = " Set thread names."]
    #[doc = ""]
    #[doc = " @note It fails with glibc < 2.12."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Thread id."]
    #[doc = " @param name"]
    #[doc = "   Thread name to set."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return a negative value."]
    pub fn rte_thread_setname(id: pthread_t, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get thread name."]
    #[doc = ""]
    #[doc = " @note It fails with glibc < 2.12."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Thread id."]
    #[doc = " @param name"]
    #[doc = "   Thread name to set."]
    #[doc = " @param len"]
    #[doc = "   Thread name buffer length."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return a negative value."]
    pub fn rte_thread_getname(id: pthread_t, name: *mut ::std::os::raw::c_char, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register current non-EAL thread as a lcore."]
    #[doc = ""]
    #[doc = " @note This API is not compatible with the multi-process feature:"]
    #[doc = " - if a primary process registers a non-EAL thread, then no secondary process"]
    #[doc = "   will initialise."]
    #[doc = " - if a secondary process initialises successfully, trying to register a"]
    #[doc = "   non-EAL thread from either primary or secondary processes will always end"]
    #[doc = "   up with the thread getting LCORE_ID_ANY as lcore."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return -1 with rte_errno set."]
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister current thread and release lcore if one was associated."]
    pub fn rte_thread_unregister();
}
extern "C" {
    #[doc = " Create a control thread."]
    #[doc = ""]
    #[doc = " Wrapper to pthread_create(), pthread_setname_np() and"]
    #[doc = " pthread_setaffinity_np(). The affinity of the new thread is based"]
    #[doc = " on the CPU affinity retrieved at the time rte_eal_init() was called,"]
    #[doc = " the dataplane and service lcores are then excluded."]
    #[doc = ""]
    #[doc = " @param thread"]
    #[doc = "   Filled with the thread id of the new created thread."]
    #[doc = " @param name"]
    #[doc = "   The name of the control thread (max 16 characters including '\\0')."]
    #[doc = " @param attr"]
    #[doc = "   Attributes for the new thread."]
    #[doc = " @param start_routine"]
    #[doc = "   Function to be executed by the new thread."]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to start_routine."]
    #[doc = " @return"]
    #[doc = "   On success, returns 0; on error, it returns a negative value"]
    #[doc = "   corresponding to the error number."]
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_t>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
#[doc = " The rte_spinlock_recursive_t type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_recursive_t {
    #[doc = "< the actual spinlock"]
    pub sl: rte_spinlock_t,
    #[doc = "< core id using lock, -1 for unused"]
    pub user: ::std::os::raw::c_int,
    #[doc = "< count of time this lock has been called"]
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).user as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
pub mod rte_cpu_flag_t {
    #[doc = " Enumeration of all CPU features supported"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< SSE3"]
    pub const RTE_CPUFLAG_SSE3: Type = 0;
    #[doc = "< PCLMULQDQ"]
    pub const RTE_CPUFLAG_PCLMULQDQ: Type = 1;
    #[doc = "< DTES64"]
    pub const RTE_CPUFLAG_DTES64: Type = 2;
    #[doc = "< MONITOR"]
    pub const RTE_CPUFLAG_MONITOR: Type = 3;
    #[doc = "< DS_CPL"]
    pub const RTE_CPUFLAG_DS_CPL: Type = 4;
    #[doc = "< VMX"]
    pub const RTE_CPUFLAG_VMX: Type = 5;
    #[doc = "< SMX"]
    pub const RTE_CPUFLAG_SMX: Type = 6;
    #[doc = "< EIST"]
    pub const RTE_CPUFLAG_EIST: Type = 7;
    #[doc = "< TM2"]
    pub const RTE_CPUFLAG_TM2: Type = 8;
    #[doc = "< SSSE3"]
    pub const RTE_CPUFLAG_SSSE3: Type = 9;
    #[doc = "< CNXT_ID"]
    pub const RTE_CPUFLAG_CNXT_ID: Type = 10;
    #[doc = "< FMA"]
    pub const RTE_CPUFLAG_FMA: Type = 11;
    #[doc = "< CMPXCHG16B"]
    pub const RTE_CPUFLAG_CMPXCHG16B: Type = 12;
    #[doc = "< XTPR"]
    pub const RTE_CPUFLAG_XTPR: Type = 13;
    #[doc = "< PDCM"]
    pub const RTE_CPUFLAG_PDCM: Type = 14;
    #[doc = "< PCID"]
    pub const RTE_CPUFLAG_PCID: Type = 15;
    #[doc = "< DCA"]
    pub const RTE_CPUFLAG_DCA: Type = 16;
    #[doc = "< SSE4_1"]
    pub const RTE_CPUFLAG_SSE4_1: Type = 17;
    #[doc = "< SSE4_2"]
    pub const RTE_CPUFLAG_SSE4_2: Type = 18;
    #[doc = "< X2APIC"]
    pub const RTE_CPUFLAG_X2APIC: Type = 19;
    #[doc = "< MOVBE"]
    pub const RTE_CPUFLAG_MOVBE: Type = 20;
    #[doc = "< POPCNT"]
    pub const RTE_CPUFLAG_POPCNT: Type = 21;
    #[doc = "< TSC_DEADLINE"]
    pub const RTE_CPUFLAG_TSC_DEADLINE: Type = 22;
    #[doc = "< AES"]
    pub const RTE_CPUFLAG_AES: Type = 23;
    #[doc = "< XSAVE"]
    pub const RTE_CPUFLAG_XSAVE: Type = 24;
    #[doc = "< OSXSAVE"]
    pub const RTE_CPUFLAG_OSXSAVE: Type = 25;
    #[doc = "< AVX"]
    pub const RTE_CPUFLAG_AVX: Type = 26;
    #[doc = "< F16C"]
    pub const RTE_CPUFLAG_F16C: Type = 27;
    #[doc = "< RDRAND"]
    pub const RTE_CPUFLAG_RDRAND: Type = 28;
    #[doc = "< Running in a VM"]
    pub const RTE_CPUFLAG_HYPERVISOR: Type = 29;
    #[doc = "< FPU"]
    pub const RTE_CPUFLAG_FPU: Type = 30;
    #[doc = "< VME"]
    pub const RTE_CPUFLAG_VME: Type = 31;
    #[doc = "< DE"]
    pub const RTE_CPUFLAG_DE: Type = 32;
    #[doc = "< PSE"]
    pub const RTE_CPUFLAG_PSE: Type = 33;
    #[doc = "< TSC"]
    pub const RTE_CPUFLAG_TSC: Type = 34;
    #[doc = "< MSR"]
    pub const RTE_CPUFLAG_MSR: Type = 35;
    #[doc = "< PAE"]
    pub const RTE_CPUFLAG_PAE: Type = 36;
    #[doc = "< MCE"]
    pub const RTE_CPUFLAG_MCE: Type = 37;
    #[doc = "< CX8"]
    pub const RTE_CPUFLAG_CX8: Type = 38;
    #[doc = "< APIC"]
    pub const RTE_CPUFLAG_APIC: Type = 39;
    #[doc = "< SEP"]
    pub const RTE_CPUFLAG_SEP: Type = 40;
    #[doc = "< MTRR"]
    pub const RTE_CPUFLAG_MTRR: Type = 41;
    #[doc = "< PGE"]
    pub const RTE_CPUFLAG_PGE: Type = 42;
    #[doc = "< MCA"]
    pub const RTE_CPUFLAG_MCA: Type = 43;
    #[doc = "< CMOV"]
    pub const RTE_CPUFLAG_CMOV: Type = 44;
    #[doc = "< PAT"]
    pub const RTE_CPUFLAG_PAT: Type = 45;
    #[doc = "< PSE36"]
    pub const RTE_CPUFLAG_PSE36: Type = 46;
    #[doc = "< PSN"]
    pub const RTE_CPUFLAG_PSN: Type = 47;
    #[doc = "< CLFSH"]
    pub const RTE_CPUFLAG_CLFSH: Type = 48;
    #[doc = "< DS"]
    pub const RTE_CPUFLAG_DS: Type = 49;
    #[doc = "< ACPI"]
    pub const RTE_CPUFLAG_ACPI: Type = 50;
    #[doc = "< MMX"]
    pub const RTE_CPUFLAG_MMX: Type = 51;
    #[doc = "< FXSR"]
    pub const RTE_CPUFLAG_FXSR: Type = 52;
    #[doc = "< SSE"]
    pub const RTE_CPUFLAG_SSE: Type = 53;
    #[doc = "< SSE2"]
    pub const RTE_CPUFLAG_SSE2: Type = 54;
    #[doc = "< SS"]
    pub const RTE_CPUFLAG_SS: Type = 55;
    #[doc = "< HTT"]
    pub const RTE_CPUFLAG_HTT: Type = 56;
    #[doc = "< TM"]
    pub const RTE_CPUFLAG_TM: Type = 57;
    #[doc = "< PBE"]
    pub const RTE_CPUFLAG_PBE: Type = 58;
    #[doc = "< DIGTEMP"]
    pub const RTE_CPUFLAG_DIGTEMP: Type = 59;
    #[doc = "< TRBOBST"]
    pub const RTE_CPUFLAG_TRBOBST: Type = 60;
    #[doc = "< ARAT"]
    pub const RTE_CPUFLAG_ARAT: Type = 61;
    #[doc = "< PLN"]
    pub const RTE_CPUFLAG_PLN: Type = 62;
    #[doc = "< ECMD"]
    pub const RTE_CPUFLAG_ECMD: Type = 63;
    #[doc = "< PTM"]
    pub const RTE_CPUFLAG_PTM: Type = 64;
    #[doc = "< MPERF_APERF_MSR"]
    pub const RTE_CPUFLAG_MPERF_APERF_MSR: Type = 65;
    #[doc = "< ACNT2"]
    pub const RTE_CPUFLAG_ACNT2: Type = 66;
    #[doc = "< ENERGY_EFF"]
    pub const RTE_CPUFLAG_ENERGY_EFF: Type = 67;
    #[doc = "< FSGSBASE"]
    pub const RTE_CPUFLAG_FSGSBASE: Type = 68;
    #[doc = "< BMI1"]
    pub const RTE_CPUFLAG_BMI1: Type = 69;
    #[doc = "< Hardware Lock elision"]
    pub const RTE_CPUFLAG_HLE: Type = 70;
    #[doc = "< AVX2"]
    pub const RTE_CPUFLAG_AVX2: Type = 71;
    #[doc = "< SMEP"]
    pub const RTE_CPUFLAG_SMEP: Type = 72;
    #[doc = "< BMI2"]
    pub const RTE_CPUFLAG_BMI2: Type = 73;
    #[doc = "< ERMS"]
    pub const RTE_CPUFLAG_ERMS: Type = 74;
    #[doc = "< INVPCID"]
    pub const RTE_CPUFLAG_INVPCID: Type = 75;
    #[doc = "< Transactional memory"]
    pub const RTE_CPUFLAG_RTM: Type = 76;
    #[doc = "< AVX512F"]
    pub const RTE_CPUFLAG_AVX512F: Type = 77;
    #[doc = "< RDSEED instruction"]
    pub const RTE_CPUFLAG_RDSEED: Type = 78;
    #[doc = "< LAHF_SAHF"]
    pub const RTE_CPUFLAG_LAHF_SAHF: Type = 79;
    #[doc = "< LZCNT"]
    pub const RTE_CPUFLAG_LZCNT: Type = 80;
    #[doc = "< SYSCALL"]
    pub const RTE_CPUFLAG_SYSCALL: Type = 81;
    #[doc = "< XD"]
    pub const RTE_CPUFLAG_XD: Type = 82;
    #[doc = "< 1GB_PG"]
    pub const RTE_CPUFLAG_1GB_PG: Type = 83;
    #[doc = "< RDTSCP"]
    pub const RTE_CPUFLAG_RDTSCP: Type = 84;
    #[doc = "< EM64T"]
    pub const RTE_CPUFLAG_EM64T: Type = 85;
    #[doc = "< INVTSC"]
    pub const RTE_CPUFLAG_INVTSC: Type = 86;
    #[doc = "< AVX512 Doubleword and Quadword"]
    pub const RTE_CPUFLAG_AVX512DQ: Type = 87;
    #[doc = "< AVX512 Integer Fused Multiply-Add"]
    pub const RTE_CPUFLAG_AVX512IFMA: Type = 88;
    #[doc = "< AVX512 Conflict Detection"]
    pub const RTE_CPUFLAG_AVX512CD: Type = 89;
    #[doc = "< AVX512 Byte and Word"]
    pub const RTE_CPUFLAG_AVX512BW: Type = 90;
    #[doc = "< AVX512 Vector Length"]
    pub const RTE_CPUFLAG_AVX512VL: Type = 91;
    #[doc = "< AVX512 Vector Bit Manipulation"]
    pub const RTE_CPUFLAG_AVX512VBMI: Type = 92;
    #[doc = "< AVX512 Vector Bit Manipulation 2"]
    pub const RTE_CPUFLAG_AVX512VBMI2: Type = 93;
    #[doc = "< Galois Field New Instructions"]
    pub const RTE_CPUFLAG_GFNI: Type = 94;
    #[doc = "< Vector AES"]
    pub const RTE_CPUFLAG_VAES: Type = 95;
    #[doc = "< Vector Carry-less Multiply"]
    pub const RTE_CPUFLAG_VPCLMULQDQ: Type = 96;
    pub const RTE_CPUFLAG_AVX512VNNI: Type = 97;
    #[doc = "< AVX512 Bit Algorithms"]
    pub const RTE_CPUFLAG_AVX512BITALG: Type = 98;
    #[doc = "< AVX512 Vector Popcount"]
    pub const RTE_CPUFLAG_AVX512VPOPCNTDQ: Type = 99;
    #[doc = "< Cache Line Demote"]
    pub const RTE_CPUFLAG_CLDEMOTE: Type = 100;
    #[doc = "< Direct Store Instructions"]
    pub const RTE_CPUFLAG_MOVDIRI: Type = 101;
    #[doc = "< Direct Store Instructions 64B"]
    pub const RTE_CPUFLAG_MOVDIR64B: Type = 102;
    #[doc = "< AVX512 Two Register Intersection"]
    pub const RTE_CPUFLAG_AVX512VP2INTERSECT: Type = 103;
    #[doc = "< UMONITOR/UMWAIT/TPAUSE"]
    pub const RTE_CPUFLAG_WAITPKG: Type = 104;
    #[doc = "< This should always be the last!"]
    pub const RTE_CPUFLAG_NUMFLAGS: Type = 105;
}
#[doc = " Structure used to describe platform-specific intrinsics that may or may not"]
#[doc = " be supported at runtime."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_cpu_intrinsics {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_cpu_intrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rte_cpu_intrinsics>(),
        4usize,
        concat!("Size of: ", stringify!(rte_cpu_intrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_cpu_intrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_cpu_intrinsics))
    );
}
impl rte_cpu_intrinsics {
    #[inline]
    pub fn power_monitor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_pause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_pause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(power_monitor: u32, power_pause: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let power_monitor: u32 = unsafe { ::std::mem::transmute(power_monitor) };
            power_monitor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_pause: u32 = unsafe { ::std::mem::transmute(power_pause) };
            power_pause as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Check CPU support for various intrinsics at runtime."]
    #[doc = ""]
    #[doc = " @param intrinsics"]
    #[doc = "     Pointer to a structure to be filled."]
    pub fn rte_cpu_get_intrinsics_support(intrinsics: *mut rte_cpu_intrinsics);
}
extern "C" {
    #[doc = " Get name of CPU flag"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag ID"]
    #[doc = " @return"]
    #[doc = "     flag name"]
    #[doc = "     NULL if flag ID is invalid"]
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Function for checking a CPU flag availability"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag to query CPU for"]
    #[doc = " @return"]
    #[doc = "     1 if flag is available"]
    #[doc = "     0 if flag is not available"]
    #[doc = "     -ENOENT if flag is invalid"]
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features"]
    #[doc = " that were specified at compile time. It is called automatically within the"]
    #[doc = " EAL, so does not need to be used by applications.  This version returns a"]
    #[doc = " result so that decisions may be made (for instance, graceful shutdowns)."]
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to retrieve a value from the auxiliary vector."]
    #[doc = " If it is unsuccessful, the result will be 0, and errno will be set."]
    #[doc = ""]
    #[doc = " @return A value from the auxiliary vector.  When the value is 0, check"]
    #[doc = " errno to determine if an error occurred."]
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " This function retrieves a value from the auxiliary vector, and compares it"]
    #[doc = " as a string against the value retrieved."]
    #[doc = ""]
    #[doc = " @return The result of calling strcmp() against the value retrieved from"]
    #[doc = " the auxiliary vector.  When the value is 0 (meaning a match is found),"]
    #[doc = " check errno to determine if an error occurred."]
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the measured frequency of the RDTSC counter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The TSC frequency for this lcore"]
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    pub static mut rte_delay_us: ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    #[doc = " Blocking delay function."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   Number of microseconds to wait."]
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Delay function that uses system sleep."]
    #[doc = " Does not block the CPU core."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   Number of microseconds to wait."]
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Replace rte_delay_us with user defined function."]
    #[doc = ""]
    #[doc = " @param userfunc"]
    #[doc = "   User function which replaces rte_delay_us. rte_delay_us_block restores"]
    #[doc = "   builtin block delay function."]
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    #[doc = "< name associated with an array"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< number of entries stored"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< current length of the array"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< size of each element"]
    pub elt_sz: ::std::os::raw::c_uint,
    #[doc = "< data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< multiprocess lock"]
    pub rwlock: rte_rwlock_t,
}
#[test]
fn bindgen_test_layout_rte_fbarray() {
    assert_eq!(
        ::std::mem::size_of::<rte_fbarray>(),
        96usize,
        concat!("Size of: ", stringify!(rte_fbarray))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fbarray>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_fbarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).count as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).len as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).elt_sz as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(elt_sz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).data as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).rwlock as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(rte_fbarray), "::", stringify!(rwlock))
    );
}
impl Default for rte_fbarray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Set up ``rte_fbarray`` structure and allocate underlying resources."]
    #[doc = ""]
    #[doc = " Call this function to correctly set up ``rte_fbarray`` and allocate"]
    #[doc = " underlying files that will be backing the data in the current process. Note"]
    #[doc = " that in order to use and share ``rte_fbarray`` between multiple processes,"]
    #[doc = " data pointed to by ``arr`` pointer must itself be allocated in shared memory."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Unique name to be assigned to this array."]
    #[doc = ""]
    #[doc = " @param len"]
    #[doc = "   Number of elements initially available in the array."]
    #[doc = ""]
    #[doc = " @param elt_sz"]
    #[doc = "   Size of each element."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach to a file backing an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " Call this function to attach to file that will be backing the data in the"]
    #[doc = " current process. The structure must have been previously correctly set up"]
    #[doc = " with a call to ``rte_fbarray_init()``. Calls to ``rte_fbarray_attach()`` are"]
    #[doc = " usually meant to be performed in a multiprocessing scenario, with data"]
    #[doc = " pointed to by ``arr`` pointer allocated in shared memory."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up rte_fbarray structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure, and remove the underlying file."]
    #[doc = ""]
    #[doc = " Call this function to deallocate all resources associated with an"]
    #[doc = " ``rte_fbarray`` structure within the current process. This will also"]
    #[doc = " zero-fill data pointed to by ``arr`` pointer and remove the underlying file"]
    #[doc = " backing the data, so it is expected that by the time this function is called,"]
    #[doc = " all other processes have detached from this ``rte_fbarray``."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate resources for an already allocated and correctly set up"]
    #[doc = " ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " Call this function to deallocate all resources associated with an"]
    #[doc = " ``rte_fbarray`` structure within current process."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get pointer to element residing at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Index of an element to get a pointer to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-NULL pointer on success."]
    #[doc = "  - NULL on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_get(arr: *const rte_fbarray, idx: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Find index of a specified element within the array."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param elt"]
    #[doc = "   Pointer to element to find index to."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_idx(arr: *const rte_fbarray, elt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark specified element as used."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to mark as used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_used(arr: *mut rte_fbarray, idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark specified element as free."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to mark as free."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_set_free(arr: *mut rte_fbarray, idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether element at specified index is marked as used."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param idx"]
    #[doc = "   Element index to check as used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 1 if element is used."]
    #[doc = "  - 0 if element is unused."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_is_used(arr: *mut rte_fbarray, idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next free element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_free(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next used element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_used(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next chunk of ``n`` free elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of free elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of next chunk of ``n`` used elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of used elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more free entries there are, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_free(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more used entries there are, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_contig_used(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of previous free element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_free(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of previous used element, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_used(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` free elements, down from specified"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of free elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find lowest start index of chunk of ``n`` used elements, down from specified"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "   Number of used elements to look for."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more free entries there are before specified index (like"]
    #[doc = " ``rte_fbarray_find_contig_free`` but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find how many more used entries there are before specified index (like"]
    #[doc = " ``rte_fbarray_find_contig_used`` but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of free elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_free(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of used elements, starting at specified index."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_biggest_used(arr: *mut rte_fbarray, start: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of free elements before a specified index (like"]
    #[doc = " ``rte_fbarray_find_biggest_free``, but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find index of biggest chunk of used elements before a specified index (like"]
    #[doc = " ``rte_fbarray_find_biggest_used``, but going in reverse)."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Element index to start search from."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non-negative integer on success."]
    #[doc = "  - -1 on failure, with ``rte_errno`` indicating reason for failure."]
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump ``rte_fbarray`` metadata."]
    #[doc = ""]
    #[doc = " @param arr"]
    #[doc = "   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   File object to dump information into."]
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    #[doc = "< Length of the segment."]
    pub len: usize,
    #[doc = "< The pagesize of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Number of channels."]
    pub nchannel: u32,
    #[doc = "< Number of ranks."]
    pub nrank: u32,
    #[doc = "< Memseg-specific flags"]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64 bits"]
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).addr_64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        48usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).iova as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(iova))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).len as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).hugepage_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).socket_id as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(socket_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nchannel as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(nchannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nrank as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(nrank))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).flags as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(rte_memseg), "::", stringify!(flags))
    );
}
impl Default for rte_memseg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " memseg list is a special case as we need to store a bunch of other data"]
#[doc = " together with the array itself."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    #[doc = "< Page size for all memsegs in this list."]
    pub page_sz: u64,
    #[doc = "< Socket ID for all memsegs in this list."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< version number for multiprocess sync."]
    pub version: u32,
    #[doc = "< Length of memory area covered by this memseg list."]
    pub len: usize,
    #[doc = "< 1 if this list points to external memory"]
    pub external: ::std::os::raw::c_uint,
    #[doc = "< 1 if this list points to a heap"]
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg_list__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).base_va as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(base_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).addr_64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg_list__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list>(),
        136usize,
        concat!("Size of: ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).page_sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(page_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).socket_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).len as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_memseg_list), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).external as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).heap as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_memseg_list), "::", stringify!(heap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).memseg_arr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(memseg_arr)
        )
    );
}
impl Default for rte_memseg_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Lock page in physical memory and prevent from swapping."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get physical address of any mapped virtual address in the current process."]
    #[doc = " It is found by browsing the /proc/self/pagemap special file."]
    #[doc = " The page must be locked."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   The physical address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    #[doc = " Get IO virtual address of any mapped virtual address in the current process."]
    #[doc = ""]
    #[doc = " @note This function will not check internal page table. Instead, in IOVA as"]
    #[doc = "       PA mode, it will fall back to getting real physical address (which may"]
    #[doc = "       not match the expected IOVA, such as what was specified for external"]
    #[doc = "       memory)."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   The IO address or RTE_BAD_IOVA on error."]
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    #[doc = " Get virtual memory address corresponding to iova address."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param iova"]
    #[doc = "   The iova address."]
    #[doc = " @return"]
    #[doc = "   Virtual address corresponding to iova address (or NULL if address does not"]
    #[doc = "   exist within DPDK memory map)."]
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get memseg to which a particular virtual address belongs."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @param msl"]
    #[doc = "   The memseg list in which to look up based on ``virt`` address"]
    #[doc = "   (can be NULL)."]
    #[doc = " @return"]
    #[doc = "   Memseg pointer on success, or NULL on error."]
    pub fn rte_mem_virt2memseg(virt: *const ::std::os::raw::c_void, msl: *const rte_memseg_list) -> *mut rte_memseg;
}
extern "C" {
    #[doc = " Get memseg list corresponding to virtual memory address."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   Memseg list to which this virtual address belongs to."]
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
#[doc = " Memseg walk function prototype."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg contig walk function prototype. This will trigger a callback on every"]
#[doc = " VA-contiguous area starting at memseg ``ms``, so total valid VA space at each"]
#[doc = " callback call will be [``ms->addr``, ``ms->addr + len``)."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Memseg list walk function prototype. This will trigger a callback on every"]
#[doc = " allocated memseg list."]
#[doc = ""]
#[doc = " Returning 0 will continue walk"]
#[doc = " Returning 1 will stop the walk"]
#[doc = " Returning -1 will stop the walk and report error"]
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(msl: *const rte_memseg_list, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Walk list of all memsegs."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_walk(func: rte_memseg_walk_t, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each VA-contiguous area."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each allocated memseg list."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This function will also walk through externally allocated segments. It"]
    #[doc = "       is up to the user to decide whether to skip through these segments."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk list of all memsegs without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each VA-contiguous area without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Walk each allocated memseg list without performing any locking."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    #[doc = " @return"]
    #[doc = "   0 if walked over the entire list"]
    #[doc = "   1 if stopped by the user"]
    #[doc = "   -1 if user function reported error"]
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return file descriptor associated with a particular memseg (if available)."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This returns an internal file descriptor. Performing any operations on"]
    #[doc = "       this file descriptor is inherently dangerous, so it should be treated"]
    #[doc = "       as read-only for all intents and purposes."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return file descriptor associated with a particular memseg (if available)."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @note This returns an internal file descriptor. Performing any operations on"]
    #[doc = "       this file descriptor is inherently dangerous, so it should be treated"]
    #[doc = "       as read-only for all intents and purposes."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get offset into segment file descriptor associated with a particular memseg"]
    #[doc = " (if available)."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = " @param offset"]
    #[doc = "   A pointer to offset value where the result will be stored."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - EINVAL  - ``offset`` pointer was NULL"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_offset(ms: *const rte_memseg, offset: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get offset into segment file descriptor associated with a particular memseg"]
    #[doc = " (if available)."]
    #[doc = ""]
    #[doc = " @note This function does not perform any locking, and is only safe to call"]
    #[doc = "       from within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   A pointer to memseg for which to get file descriptor."]
    #[doc = " @param offset"]
    #[doc = "   A pointer to offset value where the result will be stored."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Valid file descriptor in case of success."]
    #[doc = "   -1 in case of error, with ``rte_errno`` set to the following values:"]
    #[doc = "     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg"]
    #[doc = "     - EINVAL  - ``offset`` pointer was NULL"]
    #[doc = "     - ENODEV  - ``ms`` fd is not available"]
    #[doc = "     - ENOENT  - ``ms`` is an unused segment"]
    #[doc = "     - ENOTSUP - segment fd's are not supported"]
    pub fn rte_memseg_get_fd_offset_thread_unsafe(ms: *const rte_memseg, offset: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Register external memory chunk with DPDK."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA mapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @note Before accessing this memory in other processes, it needs to be"]
    #[doc = "   attached in each of those processes by calling ``rte_extmem_attach`` in"]
    #[doc = "   each other process."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to register. Must be aligned by ``page_sz``."]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to register. Must be aligned by ``page_sz``."]
    #[doc = " @param iova_addrs"]
    #[doc = "   Array of page IOVA addresses corresponding to each page in this memory"]
    #[doc = "   area. Can be NULL, in which case page IOVA addresses will be set to"]
    #[doc = "   RTE_BAD_IOVA."]
    #[doc = " @param n_pages"]
    #[doc = "   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``"]
    #[doc = "   is NULL."]
    #[doc = " @param page_sz"]
    #[doc = "   Page size of the underlying memory"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EEXIST - memory chunk is already registered"]
    #[doc = "     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Unregister external memory chunk with DPDK."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA unmapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @note Before calling this function, all other processes must call"]
    #[doc = "   ``rte_extmem_detach`` to detach from the memory area."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to unregister"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_unregister(va_addr: *mut ::std::os::raw::c_void, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Attach to external memory chunk registered in another process."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA mapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to register"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to register"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_attach(va_addr: *mut ::std::os::raw::c_void, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Detach from external memory chunk registered in another process."]
    #[doc = ""]
    #[doc = " @note Using this API is mutually exclusive with ``rte_malloc`` family of"]
    #[doc = "   API's."]
    #[doc = ""]
    #[doc = " @note This API will not perform any DMA unmapping. It is expected that user"]
    #[doc = "   will do that themselves."]
    #[doc = ""]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to unregister"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     ENOENT - memory chunk was not found"]
    pub fn rte_extmem_detach(va_addr: *mut ::std::os::raw::c_void, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the physical memory layout to a file."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    #[doc = " Get the total amount of available physical memory."]
    #[doc = ""]
    #[doc = " @note This function read-locks the memory hotplug subsystem, and thus cannot"]
    #[doc = "       be used within memory-related callback functions."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    The total amount of available physical memory in bytes."]
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    #[doc = " Get the number of memory channels."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory channels on the system. The value is 0 if unknown"]
    #[doc = "   or not the same on all devices."]
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the number of memory ranks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory ranks on the system. The value is 0 if unknown or"]
    #[doc = "   not the same on all devices."]
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Check if all currently allocated memory segments are compliant with"]
    #[doc = " supplied DMA address width."]
    #[doc = ""]
    #[doc = "  @param maskbits"]
    #[doc = "    Address width to check against."]
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Check if all currently allocated memory segments are compliant with"]
    #[doc = " supplied DMA address width. This function will use"]
    #[doc = " rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying"]
    #[doc = " memory_hotplug_lock will not be acquired avoiding deadlock during"]
    #[doc = " memory initialization."]
    #[doc = ""]
    #[doc = " This function is just for EAL core memory internal use. Drivers should"]
    #[doc = " use the previous rte_mem_check_dma_mask."]
    #[doc = ""]
    #[doc = "  @param maskbits"]
    #[doc = "    Address width to check against."]
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = "  Set dma mask to use once memory initialization is done. Previous functions"]
    #[doc = "  rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be"]
    #[doc = "  used safely until memory has been initialized."]
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    #[doc = " Drivers based on uio will not load unless physical"]
    #[doc = " addresses are obtainable. It is only possible to get"]
    #[doc = " physical addresses when running as a privileged user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if the system is able to obtain physical addresses."]
    #[doc = "   0 if using DMA addresses through an IOMMU."]
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub mod rte_mem_event {
    #[doc = " Enum indicating which kind of memory event has happened. Used by callbacks to"]
    #[doc = " distinguish between memory allocations and deallocations."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Allocation event."]
    pub const RTE_MEM_EVENT_ALLOC: Type = 0;
    #[doc = "< Deallocation event."]
    pub const RTE_MEM_EVENT_FREE: Type = 1;
}
#[doc = " Function typedef used to register callbacks for memory events."]
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event::Type,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Function used to register callbacks for memory events."]
    #[doc = ""]
    #[doc = " @note callbacks will happen while memory hotplug subsystem is write-locked,"]
    #[doc = "       therefore some functions (e.g. `rte_memseg_walk()`) will cause a"]
    #[doc = "       deadlock when called from within such callbacks."]
    #[doc = ""]
    #[doc = " @note mem event callbacks not being supported is an expected error condition,"]
    #[doc = "       so user code needs to handle this situation. In these cases, return"]
    #[doc = "       value will be -1, and rte_errno will be set to ENOTSUP."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be added to the list."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   Callback function pointer."]
    #[doc = ""]
    #[doc = " @param arg"]
    #[doc = "   Argument to pass to the callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback register"]
    #[doc = "   -1 on unsuccessful callback register, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function used to unregister callbacks for memory events."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be removed from the list."]
    #[doc = ""]
    #[doc = " @param arg"]
    #[doc = "   Argument to look for among callbacks with specified callback name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback unregister"]
    #[doc = "   -1 on unsuccessful callback unregister, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function typedef used to register memory allocation validation callbacks."]
#[doc = ""]
#[doc = " Returning 0 will allow allocation attempt to continue. Returning -1 will"]
#[doc = " prevent allocation from succeeding."]
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(socket_id: ::std::os::raw::c_int, cur_limit: usize, new_len: usize) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Register validator callback for memory allocations."]
    #[doc = ""]
    #[doc = " Callbacks registered by this function will be called right before memory"]
    #[doc = " allocator is about to trigger allocation of more pages from the system if"]
    #[doc = " said allocation will bring total memory usage above specified limit on"]
    #[doc = " specified socket. User will be able to cancel pending allocation if callback"]
    #[doc = " returns -1."]
    #[doc = ""]
    #[doc = " @note callbacks will happen while memory hotplug subsystem is write-locked,"]
    #[doc = "       therefore some functions (e.g. `rte_memseg_walk()`) will cause a"]
    #[doc = "       deadlock when called from within such callbacks."]
    #[doc = ""]
    #[doc = " @note validator callbacks not being supported is an expected error condition,"]
    #[doc = "       so user code needs to handle this situation. In these cases, return"]
    #[doc = "       value will be -1, and rte_errno will be set to ENOTSUP."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be added to the list."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   Callback function pointer."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID on which to watch for allocations."]
    #[doc = ""]
    #[doc = " @param limit"]
    #[doc = "   Limit above which to trigger callbacks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback register"]
    #[doc = "   -1 on unsuccessful callback register, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unregister validator callback for memory allocations."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Name associated with specified callback to be removed from the list."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID on which to watch for allocations."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful callback unregister"]
    #[doc = "   -1 on unsuccessful callback unregister, with rte_errno value indicating"]
    #[doc = "   reason for failure."]
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Bitmap data structure"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_bitmap {
    #[doc = "< Bitmap array1"]
    pub array1: *mut u64,
    #[doc = "< Bitmap array2"]
    pub array2: *mut u64,
    #[doc = "< Number of 64-bit slabs in array1 that are actually used"]
    pub array1_size: u32,
    #[doc = "< Number of 64-bit slabs in array2"]
    pub array2_size: u32,
    #[doc = "< Bitmap scan: Index of current array1 slab"]
    pub index1: u32,
    #[doc = "< Bitmap scan: Offset of current bit within current array1 slab"]
    pub offset1: u32,
    #[doc = "< Bitmap scan: Index of current array2 slab"]
    pub index2: u32,
    #[doc = "< Bitmap scan: Go/stop condition for current array2 cache line"]
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<rte_bitmap>(),
        40usize,
        concat!("Size of: ", stringify!(rte_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bitmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).array1 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(array1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).array2 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(array2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).array1_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bitmap),
            "::",
            stringify!(array1_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).array2_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bitmap),
            "::",
            stringify!(array2_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).index1 as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(index1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).offset1 as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(offset1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).index2 as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(index2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).go2 as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(go2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bitmap>())).memory as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_bitmap), "::", stringify!(memory))
    );
}
impl Default for rte_bitmap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function which returns a printable string describing a particular"]
    #[doc = " error code. For non-RTE-specific error codes, this function returns"]
    #[doc = " the value from the libc strerror function."]
    #[doc = ""]
    #[doc = " @param errnum"]
    #[doc = "   The error number to be looked up - generally the value of rte_errno"]
    #[doc = " @return"]
    #[doc = "   A pointer to a thread-local string containing the text describing"]
    #[doc = "   the error."]
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub mod _bindgen_ty_12 {
    #[doc = " Error types"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Start numbering above std errno vals"]
    pub const RTE_MIN_ERRNO: Type = 1000;
    #[doc = "< Operation not allowed in secondary processes"]
    pub const E_RTE_SECONDARY: Type = 1001;
    #[doc = "< Missing rte_config"]
    pub const E_RTE_NO_CONFIG: Type = 1002;
    #[doc = "< Max RTE error number"]
    pub const RTE_MAX_ERRNO: Type = 1003;
}
pub mod rte_keepalive_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_KA_STATE_UNUSED: Type = 0;
    pub const RTE_KA_STATE_ALIVE: Type = 1;
    pub const RTE_KA_STATE_MISSING: Type = 4;
    pub const RTE_KA_STATE_DEAD: Type = 2;
    pub const RTE_KA_STATE_GONE: Type = 3;
    pub const RTE_KA_STATE_DOZING: Type = 5;
    pub const RTE_KA_STATE_SLEEP: Type = 6;
}
#[doc = " Keepalive failure callback."]
#[doc = ""]
#[doc = "  Receives a data pointer passed to rte_keepalive_create() and the id of the"]
#[doc = "  failed core."]
#[doc = "  @param data Data pointer passed to rte_keepalive_create()"]
#[doc = "  @param id_core ID of the core that has failed"]
pub type rte_keepalive_failure_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id_core: ::std::os::raw::c_int)>;
#[doc = " Keepalive relay callback."]
#[doc = ""]
#[doc = "  Receives a data pointer passed to rte_keepalive_register_relay_callback(),"]
#[doc = "  the id of the core for which state is to be forwarded, and details of the"]
#[doc = "  current core state."]
#[doc = "  @param data Data pointer passed to rte_keepalive_register_relay_callback()"]
#[doc = "  @param id_core ID of the core for which state is being reported"]
#[doc = "  @param core_state The current state of the core"]
#[doc = "  @param Timestamp of when core was last seen alive"]
pub type rte_keepalive_relay_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id_core: ::std::os::raw::c_int,
        core_state: rte_keepalive_state::Type,
        last_seen: u64,
    ),
>;
#[doc = " Keepalive state structure."]
#[doc = " @internal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_keepalive {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialise keepalive sub-system."]
    #[doc = " @param callback"]
    #[doc = "   Function called upon detection of a dead core."]
    #[doc = " @param data"]
    #[doc = "   Data pointer to be passed to function callback."]
    #[doc = " @return"]
    #[doc = "   Keepalive structure success, NULL on failure."]
    pub fn rte_keepalive_create(
        callback: rte_keepalive_failure_callback_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut rte_keepalive;
}
extern "C" {
    #[doc = " Checks & handles keepalive state of monitored cores."]
    #[doc = " @param *ptr_timer Triggering timer (unused)"]
    #[doc = " @param *ptr_data  Data pointer (keepalive structure)"]
    pub fn rte_keepalive_dispatch_pings(ptr_timer: *mut ::std::os::raw::c_void, ptr_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Registers a core for keepalive checks."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = " @param id_core"]
    #[doc = "   ID number of core to register."]
    pub fn rte_keepalive_register_core(keepcfg: *mut rte_keepalive, id_core: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Per-core keepalive check."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = ""]
    #[doc = " This function needs to be called from within the main process loop of"]
    #[doc = " the LCore to be checked."]
    pub fn rte_keepalive_mark_alive(keepcfg: *mut rte_keepalive);
}
extern "C" {
    #[doc = " Per-core sleep-time indication."]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = ""]
    #[doc = " If CPU idling is enabled, this function needs to be called from within"]
    #[doc = " the main process loop of the LCore going to sleep, in order to avoid"]
    #[doc = " the LCore being mis-detected as dead."]
    pub fn rte_keepalive_mark_sleep(keepcfg: *mut rte_keepalive);
}
extern "C" {
    #[doc = " Registers a 'live core' callback."]
    #[doc = ""]
    #[doc = " The complement of the 'dead core' callback. This is called when a"]
    #[doc = " core is known to be alive, and is intended for cases when an app"]
    #[doc = " needs to know 'liveness' beyond just knowing when a core has died."]
    #[doc = ""]
    #[doc = " @param *keepcfg"]
    #[doc = "   Keepalive structure pointer"]
    #[doc = " @param callback"]
    #[doc = "   Function called upon detection of a dead core."]
    #[doc = " @param data"]
    #[doc = "   Data pointer to be passed to function callback."]
    pub fn rte_keepalive_register_relay_callback(
        keepcfg: *mut rte_keepalive,
        callback: rte_keepalive_relay_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = "  Structure to hold heap statistics obtained from rte_malloc_get_socket_stats function."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_malloc_socket_stats {
    #[doc = "< Total bytes on heap"]
    pub heap_totalsz_bytes: usize,
    #[doc = "< Total free bytes on heap"]
    pub heap_freesz_bytes: usize,
    #[doc = "< Size in bytes of largest free block"]
    pub greatest_free_size: usize,
    #[doc = "< Number of free elements on heap"]
    pub free_count: ::std::os::raw::c_uint,
    #[doc = "< Number of allocated elements on heap"]
    pub alloc_count: ::std::os::raw::c_uint,
    #[doc = "< Total allocated bytes on heap"]
    pub heap_allocsz_bytes: usize,
}
#[test]
fn bindgen_test_layout_rte_malloc_socket_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_malloc_socket_stats>(),
        40usize,
        concat!("Size of: ", stringify!(rte_malloc_socket_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_malloc_socket_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_malloc_socket_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_totalsz_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_totalsz_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_freesz_bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_freesz_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).greatest_free_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(greatest_free_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).free_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(free_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).alloc_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(alloc_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_allocsz_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_allocsz_bytes)
        )
    );
}
extern "C" {
    #[doc = " This function allocates memory from the huge-page area of memory. The memory"]
    #[doc = " is not cleared. In NUMA systems, the memory allocated resides on the same"]
    #[doc = " NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_malloc(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate zero'ed memory from the heap."]
    #[doc = ""]
    #[doc = " Equivalent to rte_malloc() except that the memory zone is"]
    #[doc = " initialised with zeros. In NUMA systems, the memory allocated resides on the"]
    #[doc = " same NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_zmalloc(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for calloc(), using huge-page memory. Memory area is"]
    #[doc = " initialised with zeros. In NUMA systems, the memory allocated resides on the"]
    #[doc = " same NUMA socket as the core that calls this function."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param num"]
    #[doc = "   Number of elements to be allocated."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of a single element."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_calloc(
        type_: *const ::std::os::raw::c_char,
        num: usize,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for realloc(), using huge-page memory. Reserved area"]
    #[doc = " memory is resized, preserving contents. In NUMA systems, the new area"]
    #[doc = " may not reside on the same NUMA node as the old one."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   Pointer to already allocated memory"]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of new area. If this is 0, memory is freed."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the reallocated memory."]
    pub fn rte_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for realloc(), using huge-page memory. Reserved area"]
    #[doc = " memory is resized, preserving contents. In NUMA systems, the new area"]
    #[doc = " resides on requested NUMA socket."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   Pointer to already allocated memory"]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of new area. If this is 0, memory is freed."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the reallocated memory."]
    pub fn rte_realloc_socket(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This function allocates memory from the huge-page area of memory. The memory"]
    #[doc = " is not cleared."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_malloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_malloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate zero'ed memory from the heap."]
    #[doc = ""]
    #[doc = " Equivalent to rte_malloc() except that the memory zone is"]
    #[doc = " initialised with zeros."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) to be allocated."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_zmalloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_zmalloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Replacement function for calloc(), using huge-page memory. Memory area is"]
    #[doc = " initialised with zeros."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects (useful for debug"]
    #[doc = "   purposes, such as identifying the cause of a memory leak). Can be NULL."]
    #[doc = " @param num"]
    #[doc = "   Number of elements to be allocated."]
    #[doc = " @param size"]
    #[doc = "   Size (in bytes) of a single element."]
    #[doc = " @param align"]
    #[doc = "   If 0, the return is a pointer that is suitably aligned for any kind of"]
    #[doc = "   variable (in the same manner as malloc())."]
    #[doc = "   Otherwise, the return is a pointer that is a multiple of *align*. In"]
    #[doc = "   this case, it must obviously be a power of two. (Minimum alignment is the"]
    #[doc = "   cacheline size, i.e. 64-bytes)"]
    #[doc = " @param socket"]
    #[doc = "   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function"]
    #[doc = "   will behave the same as rte_calloc()."]
    #[doc = " @return"]
    #[doc = "   - NULL on error. Not enough memory, or invalid arguments (size is 0,"]
    #[doc = "     align is not a power of two)."]
    #[doc = "   - Otherwise, the pointer to the allocated object."]
    pub fn rte_calloc_socket(
        type_: *const ::std::os::raw::c_char,
        num: usize,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees the memory space pointed to by the provided pointer."]
    #[doc = ""]
    #[doc = " This pointer must have been returned by a previous call to"]
    #[doc = " rte_malloc(), rte_zmalloc(), rte_calloc() or rte_realloc(). The behaviour of"]
    #[doc = " rte_free() is undefined if the pointer does not match this requirement."]
    #[doc = ""]
    #[doc = " If the pointer is NULL, the function does nothing."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   The pointer to memory to be freed."]
    pub fn rte_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " If malloc debug is enabled, check a memory block for header"]
    #[doc = " and trailer markers to indicate that all is well with the block."]
    #[doc = " If size is non-null, also return the size of the block."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   pointer to the start of a data block, must have been returned"]
    #[doc = "   by a previous call to rte_malloc(), rte_zmalloc(), rte_calloc()"]
    #[doc = "   or rte_realloc()"]
    #[doc = " @param size"]
    #[doc = "   if non-null, and memory block pointer is valid, returns the size"]
    #[doc = "   of the memory block"]
    #[doc = " @return"]
    #[doc = "   -1 on error, invalid pointer passed or header and trailer markers"]
    #[doc = "   are missing or corrupted"]
    #[doc = "   0 on success"]
    pub fn rte_malloc_validate(ptr: *const ::std::os::raw::c_void, size: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get heap statistics for the specified heap."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param socket"]
    #[doc = "   An unsigned integer specifying the socket to get heap statistics for"]
    #[doc = " @param socket_stats"]
    #[doc = "   A structure which provides memory to store statistics"]
    #[doc = " @return"]
    #[doc = "   Null on error"]
    #[doc = "   Pointer to structure storing statistics on success"]
    pub fn rte_malloc_get_socket_stats(
        socket: ::std::os::raw::c_int,
        socket_stats: *mut rte_malloc_socket_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory chunk to a heap with specified name."]
    #[doc = ""]
    #[doc = " @note Multiple memory chunks can be added to the same heap"]
    #[doc = ""]
    #[doc = " @note Before accessing this memory in other processes, it needs to be"]
    #[doc = "   attached in each of those processes by calling"]
    #[doc = "   ``rte_malloc_heap_memory_attach`` in each other process."]
    #[doc = ""]
    #[doc = " @note Memory must be previously allocated for DPDK to be able to use it as a"]
    #[doc = "   malloc heap. Failing to do so will result in undefined behavior, up to and"]
    #[doc = "   including segmentation faults."]
    #[doc = ""]
    #[doc = " @note Calling this function will erase any contents already present at the"]
    #[doc = "   supplied memory address."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to add memory chunk to"]
    #[doc = " @param va_addr"]
    #[doc = "   Start of virtual area to add to the heap. Must be aligned by ``page_sz``."]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to add to the heap. Must be aligned by ``page_sz``."]
    #[doc = " @param iova_addrs"]
    #[doc = "   Array of page IOVA addresses corresponding to each page in this memory"]
    #[doc = "   area. Can be NULL, in which case page IOVA addresses will be set to"]
    #[doc = "   RTE_BAD_IOVA."]
    #[doc = " @param n_pages"]
    #[doc = "   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``"]
    #[doc = "   is NULL."]
    #[doc = " @param page_sz"]
    #[doc = "   Page size of the underlying memory"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to add memory to a reserved heap"]
    #[doc = "     ENOSPC - no more space in internal config to store a new memory chunk"]
    pub fn rte_malloc_heap_memory_add(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove memory chunk from heap with specified name."]
    #[doc = ""]
    #[doc = " @note Memory chunk being removed must be the same as one that was added;"]
    #[doc = "   partially removing memory chunks is not supported"]
    #[doc = ""]
    #[doc = " @note Memory area must not contain any allocated elements to allow its"]
    #[doc = "   removal from the heap"]
    #[doc = ""]
    #[doc = " @note All other processes must detach from the memory chunk prior to it being"]
    #[doc = "   removed from the heap."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to remove memory from"]
    #[doc = " @param va_addr"]
    #[doc = "   Virtual address to remove from the heap"]
    #[doc = " @param len"]
    #[doc = "   Length of virtual area to remove from the heap"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to remove memory from a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    #[doc = "     EBUSY  - memory chunk still contains data"]
    pub fn rte_malloc_heap_memory_remove(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach to an already existing chunk of external memory in another process."]
    #[doc = ""]
    #[doc = " @note This function must be called before any attempt is made to use an"]
    #[doc = "   already existing external memory chunk. This function does *not* need to"]
    #[doc = "   be called if a call to ``rte_malloc_heap_memory_add`` was made in the"]
    #[doc = "   current process."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Heap name to which this chunk of memory belongs"]
    #[doc = " @param va_addr"]
    #[doc = "   Start address of memory chunk to attach to"]
    #[doc = " @param len"]
    #[doc = "   Length of memory chunk to attach to"]
    #[doc = " @return"]
    #[doc = "   0 on successful attach"]
    #[doc = "   -1 on unsuccessful attach, with rte_errno set to indicate cause for error:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to attach memory to a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    pub fn rte_malloc_heap_memory_attach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Detach from a chunk of external memory in secondary process."]
    #[doc = ""]
    #[doc = " @note This function must be called in before any attempt is made to remove"]
    #[doc = "   external memory from the heap in another process. This function does *not*"]
    #[doc = "   need to be called if a call to ``rte_malloc_heap_memory_remove`` will be"]
    #[doc = "   called in current process."]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Heap name to which this chunk of memory belongs"]
    #[doc = " @param va_addr"]
    #[doc = "   Start address of memory chunk to attach to"]
    #[doc = " @param len"]
    #[doc = "   Length of memory chunk to attach to"]
    #[doc = " @return"]
    #[doc = "   0 on successful detach"]
    #[doc = "   -1 on unsuccessful detach, with rte_errno set to indicate cause for error:"]
    #[doc = "     EINVAL - one of the parameters was invalid"]
    #[doc = "     EPERM  - attempted to detach memory from a reserved heap"]
    #[doc = "     ENOENT - heap or memory chunk was not found"]
    pub fn rte_malloc_heap_memory_detach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new empty malloc heap with a specified name."]
    #[doc = ""]
    #[doc = " @note Heaps created via this call will automatically get assigned a unique"]
    #[doc = "   socket ID, which can be found using ``rte_malloc_heap_get_socket()``"]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to create."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on successful creation"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``heap_name`` was NULL, empty or too long"]
    #[doc = "     EEXIST - heap by name of ``heap_name`` already exists"]
    #[doc = "     ENOSPC - no more space in internal config to store a new heap"]
    pub fn rte_malloc_heap_create(heap_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroys a previously created malloc heap with specified name."]
    #[doc = ""]
    #[doc = " @note This function will return a failure result if not all memory allocated"]
    #[doc = "   from the heap has been freed back to the heap"]
    #[doc = ""]
    #[doc = " @note This function will return a failure result if not all memory segments"]
    #[doc = "   were removed from the heap prior to its destruction"]
    #[doc = ""]
    #[doc = " @param heap_name"]
    #[doc = "   Name of the heap to create."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``heap_name`` was NULL, empty or too long"]
    #[doc = "     ENOENT - heap by the name of ``heap_name`` was not found"]
    #[doc = "     EPERM  - attempting to destroy reserved heap"]
    #[doc = "     EBUSY  - heap still contains data"]
    pub fn rte_malloc_heap_destroy(heap_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find socket ID corresponding to a named heap."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   Heap name to find socket ID for"]
    #[doc = " @return"]
    #[doc = "   Socket ID in case of success (a non-negative number)"]
    #[doc = "   -1 in case of error, with rte_errno set to one of the following:"]
    #[doc = "     EINVAL - ``name`` was NULL"]
    #[doc = "     ENOENT - heap identified by the name ``name`` was not found"]
    pub fn rte_malloc_heap_get_socket(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a given socket ID refers to externally allocated memory."]
    #[doc = ""]
    #[doc = " @note Passing SOCKET_ID_ANY will return 0."]
    #[doc = ""]
    #[doc = " @param socket_id"]
    #[doc = "   Socket ID to check"]
    #[doc = " @return"]
    #[doc = "   1 if socket ID refers to externally allocated memory"]
    #[doc = "   0 if socket ID refers to internal DPDK memory"]
    #[doc = "   -1 if socket ID is invalid"]
    pub fn rte_malloc_heap_socket_is_external(socket_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump statistics."]
    #[doc = ""]
    #[doc = " Dump for the specified type to a file. If the type argument is"]
    #[doc = " NULL, all memory types will be dumped."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of objects to dump, or NULL"]
    #[doc = "   to dump all objects."]
    pub fn rte_malloc_dump_stats(f: *mut FILE, type_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Dump contents of all malloc heaps to a file."]
    #[doc = ""]
    #[doc = " @note This function is not thread-safe with respect to"]
    #[doc = "    ``rte_malloc_heap_create()``/``rte_malloc_heap_destroy()`` functions."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_malloc_dump_heaps(f: *mut FILE);
}
extern "C" {
    #[doc = " Set the maximum amount of allocated memory for this type."]
    #[doc = ""]
    #[doc = " This is not yet implemented"]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   A string identifying the type of allocated objects."]
    #[doc = " @param max"]
    #[doc = "   The maximum amount of allocated bytes for this type."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-1): Error."]
    pub fn rte_malloc_set_limit(type_: *const ::std::os::raw::c_char, max: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the IO address of a virtual address obtained through"]
    #[doc = " rte_malloc"]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "   Address obtained from a previous rte_malloc call"]
    #[doc = " @return"]
    #[doc = "   RTE_BAD_IOVA on error"]
    #[doc = "   otherwise return an address suitable for IO"]
    pub fn rte_malloc_virt2iova(addr: *const ::std::os::raw::c_void) -> rte_iova_t;
}
#[doc = " 64 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64u8_t = [u8; 8usize];
#[doc = " 64 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u16_t){ a0, a1, a2, a3 }"]
pub type rte_v64u16_t = [u16; 4usize];
#[doc = " 64 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u32_t){ a0, a1 }"]
pub type rte_v64u32_t = [u32; 2usize];
#[doc = " 128 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128u8_t = [u8; 16usize];
#[doc = " 128 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128u16_t = [u16; 8usize];
#[doc = " 128 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u32_t){ a0, a1, a2, a3 }"]
pub type rte_v128u32_t = [u32; 4usize];
#[doc = " 128 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u64_t){ a0, a1 }"]
pub type rte_v128u64_t = [u64; 2usize];
#[doc = " 256 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256u8_t = [u8; 32usize];
#[doc = " 256 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256u16_t = [u16; 16usize];
#[doc = " 256 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256u32_t = [u32; 8usize];
#[doc = " 256 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u64_t){ a0, a1, a2, a3 }"]
pub type rte_v256u64_t = [u64; 4usize];
#[doc = " 64 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64s8_t = [i8; 8usize];
#[doc = " 64 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s16_t){ a0, a1, a2, a3 }"]
pub type rte_v64s16_t = [i16; 4usize];
#[doc = " 64 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s32_t){ a0, a1 }"]
pub type rte_v64s32_t = [i32; 2usize];
#[doc = " 128 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128s8_t = [i8; 16usize];
#[doc = " 128 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128s16_t = [i16; 8usize];
#[doc = " 128 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s32_t){ a0, a1, a2, a3 }"]
pub type rte_v128s32_t = [i32; 4usize];
#[doc = " 128 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s64_t){ a1, a2 }"]
pub type rte_v128s64_t = [i64; 2usize];
#[doc = " 256 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256s8_t = [i8; 32usize];
#[doc = " 256 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256s16_t = [i16; 16usize];
#[doc = " 256 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256s32_t = [i32; 8usize];
#[doc = " 256 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s64_t){ a0, a1, a2, a3 }"]
pub type rte_v256s64_t = [i64; 4usize];
pub mod rte_vect_max_simd {
    #[doc = " The max SIMD bitwidth value to limit vector path selection."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_VECT_SIMD_DISABLED: Type = 64;
    pub const RTE_VECT_SIMD_128: Type = 128;
    #[doc = "< Limits path selection to AVX2 or below."]
    pub const RTE_VECT_SIMD_256: Type = 256;
    #[doc = "< Limits path selection to AVX512 or below."]
    pub const RTE_VECT_SIMD_512: Type = 512;
    pub const RTE_VECT_SIMD_MAX: Type = 32768;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get the supported SIMD bitwidth."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   uint16_t bitwidth."]
    pub fn rte_vect_get_max_simd_bitwidth() -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Set the supported SIMD bitwidth."]
    #[doc = " This API should only be called once at initialization, before EAL init."]
    #[doc = ""]
    #[doc = " @param bitwidth"]
    #[doc = "   uint16_t bitwidth."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - -EINVAL on invalid bitwidth parameter."]
    #[doc = "   - -EPERM if bitwidth is forced."]
    pub fn rte_vect_set_max_simd_bitwidth(bitwidth: u16) -> ::std::os::raw::c_int;
}
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(
        ::std::mem::size_of::<rte_xmm>(),
        16usize,
        concat!("Size of: ", stringify!(rte_xmm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_xmm>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_xmm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u8_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(u8_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u16_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(u16_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u32_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(u32_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u64_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(u64_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).pd as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_xmm), "::", stringify!(pd))
    );
}
impl Default for rte_xmm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_xmm_t = rte_xmm;
pub type ymm_t = __m256i;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union rte_ymm {
    pub y: ymm_t,
    pub x: [xmm_t; 2usize],
    pub u8_: [u8; 32usize],
    pub u16_: [u16; 16usize],
    pub u32_: [u32; 8usize],
    pub u64_: [u64; 4usize],
    pub pd: [f64; 4usize],
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rte_ymm() {
    assert_eq!(
        ::std::mem::size_of::<rte_ymm>(),
        32usize,
        concat!("Size of: ", stringify!(rte_ymm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ymm>(),
        32usize,
        concat!("Alignment of ", stringify!(rte_ymm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).y as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u8_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(u8_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u16_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(u16_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u32_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(u32_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u64_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(u64_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).pd as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ymm), "::", stringify!(pd))
    );
}
impl Default for rte_ymm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_ymm_t = rte_ymm;
#[doc = " A structure describing a memzone, which is a contiguous portion of"]
#[doc = " physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).addr_64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memzone__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_memzone), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).iova as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_memzone), "::", stringify!(iova))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).len as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rte_memzone), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).hugepage_sz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).socket_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).flags as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(rte_memzone), "::", stringify!(flags))
    );
}
impl Default for rte_memzone {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Reserve a portion of physical memory."]
    #[doc = ""]
    #[doc = " This function reserves some memory and returns a pointer to a"]
    #[doc = " correctly filled memzone descriptor. If the allocation cannot be"]
    #[doc = " done, return NULL."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with alignment on a specified"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with alignment on a specified"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " is not a power of 2, returns NULL."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with specified alignment and"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with specified alignment and"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " or boundary are not a power of 2, returns NULL."]
    #[doc = " Memory buffer is reserved in a way, that it wouldn't cross specified"]
    #[doc = " boundary. That implies that requested length should be less or equal"]
    #[doc = " then boundary."]
    #[doc = ""]
    #[doc = " @note Reserving memzones with len set to 0 will only attempt to allocate"]
    #[doc = "   memzones from memory that is already available. It will not trigger any"]
    #[doc = "   new allocations."]
    #[doc = ""]
    #[doc = " @note: When reserving memzones with len set to 0, it is preferable to also"]
    #[doc = "   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but"]
    #[doc = "   will likely not yield expected results. Specifically, the resulting memzone"]
    #[doc = "   may not necessarily be the biggest memzone available, but rather biggest"]
    #[doc = "   memzone available on socket id corresponding to an lcore from which"]
    #[doc = "   reservation was called."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = "   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous."]
    #[doc = "                               This option should be used when allocating"]
    #[doc = "                               memory intended for hardware rings etc."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @param bound"]
    #[doc = "   Boundary for resulting memzone. Must be a power of 2 or zero."]
    #[doc = "   Zero value implies no boundary condition."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Free a memzone."]
    #[doc = ""]
    #[doc = " @param mz"]
    #[doc = "   A pointer to the memzone"]
    #[doc = " @return"]
    #[doc = "  -EINVAL - invalid parameter."]
    #[doc = "  0 - success"]
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a memzone."]
    #[doc = ""]
    #[doc = " Get a pointer to a descriptor of an already reserved memory"]
    #[doc = " zone identified by the name given as an argument."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone."]
    #[doc = " @return"]
    #[doc = "   A pointer to a read-only memzone descriptor."]
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Dump all reserved memzones to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Walk list of all memzones"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_memzone_walk(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub mod rte_ring_queue_behavior {
    #[doc = " enqueue/dequeue behavior types"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Enq/Deq a fixed number of items from a ring"]
    pub const RTE_RING_QUEUE_FIXED: Type = 0;
    #[doc = " Enq/Deq as many items as possible from ring"]
    pub const RTE_RING_QUEUE_VARIABLE: Type = 1;
}
pub mod rte_ring_sync_type {
    #[doc = " prod/cons sync types"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< multi-thread safe (default mode)"]
    pub const RTE_RING_SYNC_MT: Type = 0;
    #[doc = "< single thread only"]
    pub const RTE_RING_SYNC_ST: Type = 1;
}
#[doc = " structures to hold a pair of head/tail values and other metadata."]
#[doc = " Depending on sync_type format of that structure might be different,"]
#[doc = " but offset for *sync_type* and *tail* values should remain the same."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< prod/consumer head."]
    pub head: u32,
    #[doc = "< prod/consumer tail."]
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    #[doc = " sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type::Type,
    #[doc = " deprecated -  True if single prod/cons"]
    pub single: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ring_headtail__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail__bindgen_ty_1>())).sync_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail__bindgen_ty_1),
            "::",
            stringify!(sync_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail__bindgen_ty_1>())).single as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail__bindgen_ty_1),
            "::",
            stringify!(single)
        )
    );
}
impl Default for rte_ring_headtail__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
}
impl Default for rte_ring_headtail {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    #[doc = " raw 8B value to read/write *cnt* and *pos* as one atomic op"]
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    #[doc = "< head/tail reference counter"]
    pub cnt: u32,
    #[doc = "< head/tail position"]
    pub pos: u32,
}
#[test]
fn bindgen_test_layout___rte_ring_rts_poscnt__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_rts_poscnt__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_rts_poscnt__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_rts_poscnt__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__rte_ring_rts_poscnt__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_rts_poscnt__bindgen_ty_1>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt__bindgen_ty_1),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_rts_poscnt__bindgen_ty_1>())).pos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt__bindgen_ty_1),
            "::",
            stringify!(pos)
        )
    );
}
#[test]
fn bindgen_test_layout___rte_ring_rts_poscnt() {
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_rts_poscnt>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_rts_poscnt))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_rts_poscnt>(),
        8usize,
        concat!("Alignment of ", stringify!(__rte_ring_rts_poscnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_rts_poscnt>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_rts_poscnt>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt),
            "::",
            stringify!(val)
        )
    );
}
impl Default for __rte_ring_rts_poscnt {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type::Type,
    #[doc = "< max allowed distance between head/tail"]
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[test]
fn bindgen_test_layout_rte_ring_rts_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_rts_headtail>(),
        24usize,
        concat!("Size of: ", stringify!(rte_ring_rts_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_rts_headtail>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_ring_rts_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_rts_headtail>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_rts_headtail>())).sync_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(sync_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_rts_headtail>())).htd_max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(htd_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_rts_headtail>())).head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(head)
        )
    );
}
impl Default for rte_ring_rts_headtail {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    #[doc = " raw 8B value to read/write *head* and *tail* as one atomic op"]
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    #[doc = "< head position"]
    pub head: u32,
    #[doc = "< tail position"]
    pub tail: u32,
}
#[test]
fn bindgen_test_layout___rte_ring_hts_pos__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_hts_pos__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_hts_pos__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_hts_pos__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__rte_ring_hts_pos__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_hts_pos__bindgen_ty_1>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_hts_pos__bindgen_ty_1>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout___rte_ring_hts_pos() {
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_hts_pos>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_hts_pos))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_hts_pos>(),
        8usize,
        concat!("Alignment of ", stringify!(__rte_ring_hts_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_hts_pos>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__rte_ring_hts_pos>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos),
            "::",
            stringify!(pos)
        )
    );
}
impl Default for __rte_ring_hts_pos {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    #[doc = "< sync type of prod/cons"]
    pub sync_type: rte_ring_sync_type::Type,
}
#[test]
fn bindgen_test_layout_rte_ring_hts_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_hts_headtail>(),
        16usize,
        concat!("Size of: ", stringify!(rte_ring_hts_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_hts_headtail>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_ring_hts_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_hts_headtail>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_hts_headtail),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_hts_headtail>())).sync_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_hts_headtail),
            "::",
            stringify!(sync_type)
        )
    );
}
impl Default for rte_ring_hts_headtail {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An RTE ring structure."]
#[doc = ""]
#[doc = " The producer and the consumer have a head and a tail index. The particularity"]
#[doc = " of these index is that they are not between 0 and size(ring). These indexes"]
#[doc = " are between 0 and 2^32, and we mask their value when we access the ring[]"]
#[doc = " field. Thanks to this assumption, we can do subtractions between 2 index"]
#[doc = " values in a modulo-32bit base: that's why the overflow of the indexes is not"]
#[doc = " a problem."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    #[doc = "< empty cache line"]
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u64; 7usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    #[doc = "< empty cache line"]
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_2: [u64; 7usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    #[doc = "< empty cache line"]
    pub pad2: ::std::os::raw::c_char,
}
#[doc = " Ring producer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_rte_ring__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(rte_ring__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring__bindgen_ty_1>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_1>())).prod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_1>())).hts_prod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(hts_prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_1>())).rts_prod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(rts_prod)
        )
    );
}
impl Default for rte_ring__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Ring consumer status."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_rte_ring__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring__bindgen_ty_2>(),
        64usize,
        concat!("Size of: ", stringify!(rte_ring__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring__bindgen_ty_2>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_2>())).cons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_2>())).hts_cons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(hts_cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring__bindgen_ty_2>())).rts_cons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(rts_cons)
        )
    );
}
impl Default for rte_ring__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).flags as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).memzone as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).size as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).mask as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).capacity as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(capacity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad0 as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(pad0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad1 as *const _ as usize },
        192usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(pad1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad2 as *const _ as usize },
        320usize,
        concat!("Offset of field: ", stringify!(rte_ring), "::", stringify!(pad2))
    );
}
impl Default for rte_ring {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Calculate the memory size needed for a ring with given element size"]
    #[doc = ""]
    #[doc = " This function returns the number of bytes needed for a ring, given"]
    #[doc = " the number of elements in it and the size of the element. This value"]
    #[doc = " is the sum of the size of the structure rte_ring and the size of the"]
    #[doc = " memory needed for storing the elements. The value is aligned to a cache"]
    #[doc = " line size."]
    #[doc = ""]
    #[doc = " @param esize"]
    #[doc = "   The size of ring element, in bytes. It must be a multiple of 4."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @return"]
    #[doc = "   - The memory size needed for the ring on success."]
    #[doc = "   - -EINVAL - esize is not a multiple of 4 or count provided is not a"]
    #[doc = "\t\t power of 2."]
    pub fn rte_ring_get_memsize_elem(esize: ::std::os::raw::c_uint, count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    #[doc = " Create a new ring named *name* that stores elements with given size."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory. Then it"]
    #[doc = " calls rte_ring_init() to initialize an empty ring."]
    #[doc = ""]
    #[doc = " The new ring size is set to *count*, which must be a power of"]
    #[doc = " two. Water marking is disabled by default. The real usable ring size"]
    #[doc = " is *count-1* instead of *count* to differentiate a free ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is added in RTE_TAILQ_RING list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param esize"]
    #[doc = "   The size of ring element, in bytes. It must be a multiple of 4."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated ring. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - esize is not a multiple of 4 or count provided is not a"]
    #[doc = "\t\t power of 2."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create_elem(
        name: *const ::std::os::raw::c_char,
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    #[doc = " Calculate the memory size needed for a ring"]
    #[doc = ""]
    #[doc = " This function returns the number of bytes needed for a ring, given"]
    #[doc = " the number of elements in it. This value is the sum of the size of"]
    #[doc = " the structure rte_ring and the size of the memory needed by the"]
    #[doc = " objects pointers. The value is aligned to a cache line size."]
    #[doc = ""]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @return"]
    #[doc = "   - The memory size needed for the ring on success."]
    #[doc = "   - -EINVAL if count is not a power of 2."]
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    #[doc = " Initialize a ring structure."]
    #[doc = ""]
    #[doc = " Initialize a ring structure in memory pointed by \"r\". The size of the"]
    #[doc = " memory area must be large enough to store the ring structure and the"]
    #[doc = " object table. It is advised to use rte_ring_get_memsize() to get the"]
    #[doc = " appropriate size."]
    #[doc = ""]
    #[doc = " The ring size is set to *count*, which must be a power of two. Water"]
    #[doc = " marking is disabled by default. The real usable ring size is"]
    #[doc = " *count-1* instead of *count* to differentiate a free ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is not added in RTE_TAILQ_RING global list. Indeed, the"]
    #[doc = " memory given by the caller may not be shareable among dpdk"]
    #[doc = " processes."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   The pointer to the ring structure followed by the objects table."]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = " @return"]
    #[doc = "   0 on success, or a negative value on error."]
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new ring named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory. Then it"]
    #[doc = " calls rte_ring_init() to initialize an empty ring."]
    #[doc = ""]
    #[doc = " The new ring size is set to *count*, which must be a power of"]
    #[doc = " two. Water marking is disabled by default. The real usable ring size"]
    #[doc = " is *count-1* instead of *count* to differentiate a free ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is added in RTE_TAILQ_RING list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The size of the ring (must be a power of 2)."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "   - One of mutually exclusive flags that define producer behavior:"]
    #[doc = "      - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"single-producer\"."]
    #[doc = "      - RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer RTS mode\"."]
    #[doc = "      - RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "        is \"multi-producer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-producer\""]
    #[doc = "     behavior is selected."]
    #[doc = "   - One of mutually exclusive flags that define consumer behavior:"]
    #[doc = "      - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "      - RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer RTS mode\"."]
    #[doc = "      - RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when"]
    #[doc = "        using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "        is \"multi-consumer HTS mode\"."]
    #[doc = "     If none of these flags is set, then default \"multi-consumer\""]
    #[doc = "     behavior is selected."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated ring. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - count provided is not a power of 2"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    #[doc = " De-allocate all memory used by the ring."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   Ring to free"]
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    #[doc = " Dump the status of the ring to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param r"]
    #[doc = "   A pointer to the ring structure."]
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    #[doc = " Flush a ring."]
    #[doc = ""]
    #[doc = " This function flush all the elements in a ring"]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " Make sure the ring is not in use while calling this function."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   A pointer to the ring structure."]
    pub fn rte_ring_reset(r: *mut rte_ring);
}
extern "C" {
    #[doc = " Dump the status of all rings on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a ring from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @return"]
    #[doc = "   The pointer to the ring matching the name, or NULL if not found,"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
extern "C" {
    #[doc = " Takes string \"string\" parameter and splits it at character \"delim\""]
    #[doc = " up to maxtokens-1 times - to give \"maxtokens\" resulting tokens. Like"]
    #[doc = " strtok or strsep functions, this modifies its input string, by replacing"]
    #[doc = " instances of \"delim\" with '\\\\0'. All resultant tokens are returned in the"]
    #[doc = " \"tokens\" array which must have enough entries to hold \"maxtokens\"."]
    #[doc = ""]
    #[doc = " @param string"]
    #[doc = "   The input string to be split into tokens"]
    #[doc = ""]
    #[doc = " @param stringlen"]
    #[doc = "   The max length of the input buffer"]
    #[doc = ""]
    #[doc = " @param tokens"]
    #[doc = "   The array to hold the pointers to the tokens in the string"]
    #[doc = ""]
    #[doc = " @param maxtokens"]
    #[doc = "   The number of elements in the tokens array. At most, maxtokens-1 splits"]
    #[doc = "   of the string will be done."]
    #[doc = ""]
    #[doc = " @param delim"]
    #[doc = "   The character on which the split of the data will be done"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of tokens in the tokens array."]
    pub fn rte_strsplit(
        string: *mut ::std::os::raw::c_char,
        stringlen: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
        maxtokens: ::std::os::raw::c_int,
        delim: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy string src to buffer dst of size dsize."]
    #[doc = " At most dsize-1 chars will be copied."]
    #[doc = " Always NUL-terminates, unless (dsize == 0)."]
    #[doc = " Returns number of bytes copied (terminating NUL-byte excluded) on success ;"]
    #[doc = " negative errno on error."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   The destination string."]
    #[doc = ""]
    #[doc = " @param src"]
    #[doc = "   The input string to be copied."]
    #[doc = ""]
    #[doc = " @param dsize"]
    #[doc = "   Length in bytes of the destination buffer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of bytes copied on success"]
    #[doc = "   -E2BIG if the destination buffer is too small."]
    pub fn rte_strscpy(dst: *mut ::std::os::raw::c_char, src: *const ::std::os::raw::c_char, dsize: usize) -> isize;
}
#[doc = " The tracepoint object."]
pub type rte_trace_point_t = u64;
extern "C" {
    #[doc = " Enable recording events of the given tracepoint in the trace buffer."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "   The tracepoint object to enable."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_enable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable recording events of the given tracepoint in the trace buffer."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "   The tracepoint object to disable."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - (-ERANGE): Trace object is not registered."]
    pub fn rte_trace_point_disable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if recording events from the given tracepoint is enabled."]
    #[doc = ""]
    #[doc = " @param tp"]
    #[doc = "    The tracepoint object."]
    #[doc = " @return"]
    #[doc = "    true if tracepoint is enabled, false otherwise."]
    pub fn rte_trace_point_is_enabled(tp: *mut rte_trace_point_t) -> bool;
}
extern "C" {
    #[doc = " Lookup a tracepoint object from its name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the tracepoint."]
    #[doc = " @return"]
    #[doc = "   The tracepoint object or NULL if not found."]
    pub fn rte_trace_point_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_trace_point_t;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    #[doc = "< Cache objects"]
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        12352usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).flushthresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).objs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
impl Default for rte_mempool_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).elt_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).trailer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).total_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
#[doc = " Mempool object header structure"]
#[doc = ""]
#[doc = " Each object stored in mempools are prefixed by this header structure,"]
#[doc = " it allows to retrieve the mempool pointer from the object and to"]
#[doc = " iterate on all objects attached to a mempool. When debug is enabled,"]
#[doc = " a cookie is also added in this structure preventing corruptions and"]
#[doc = " double-frees."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_1>())).stqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_objhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).iova as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(iova)
        )
    );
}
impl Default for rte_mempool_objhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_objhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_memhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void)>;
#[doc = " Mempool objects memory header structure"]
#[doc = ""]
#[doc = " The memory chunks where objects are stored. Each chunk is virtually"]
#[doc = " and physically contiguous."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_1>())).stqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_memhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).iova as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).free_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
impl Default for rte_mempool_memhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Additional information about the mempool"]
#[doc = ""]
#[doc = " The structure is cache-line aligned to avoid ABI breakages in"]
#[doc = " a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mempool_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_info>())).contig_block_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_info),
            "::",
            stringify!(contig_block_size)
        )
    );
}
impl Default for rte_mempool_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops"]
    #[doc = " structs, which contain callback function pointers."]
    #[doc = " We're using an index here rather than pointers to the callbacks"]
    #[doc = " to facilitate any secondary processes that may want to use"]
    #[doc = " this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
impl Default for rte_mempool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).pool_config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mz as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(mz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).flags as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).socket_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).size as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).cache_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_size as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(elt_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).header_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).trailer_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).private_data_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).ops_index as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).local_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).populated_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_list as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(elt_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).nb_mem_chunks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mem_list as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(rte_mempool), "::", stringify!(mem_list))
    );
}
impl Default for rte_mempool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @internal Check and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   Index of object in object table."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @internal Check contiguous object blocks and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param first_obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (first object of the contiguous"]
    #[doc = "   object blocks)."]
    #[doc = " @param n"]
    #[doc = "   Number of contiguous object blocks."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
#[doc = " Prototype for implementation specific data provisioning function."]
#[doc = ""]
#[doc = " The function should provide the implementation specific memory for"]
#[doc = " use by the other mempool ops functions in a given mempool ops struct."]
#[doc = " E.g. the default ops provides an instance of the rte_ring for this purpose."]
#[doc = " it will most likely point to a different type of data structure, and"]
#[doc = " will be transparent to the application programmer."]
#[doc = " This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue an object into the external pool."]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an object from the external pool."]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects."]
#[doc = ""]
#[doc = " If mempool objects are not required to be IOVA-contiguous"]
#[doc = " (the flag MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines"]
#[doc = " virtually contiguous chunk size. Otherwise, if mempool objects must"]
#[doc = " be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is clear),"]
#[doc = " min_chunk_size defines IOVA-contiguous chunk size."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   Pointer to the memory pool."]
#[doc = " @param[in] obj_num"]
#[doc = "   Number of objects."]
#[doc = " @param[in] pg_shift"]
#[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
#[doc = " @param[out] min_chunk_size"]
#[doc = "   Location for minimum size of the memory chunk which may be used to"]
#[doc = "   store memory pool objects."]
#[doc = " @param[out] align"]
#[doc = "   Location for required memory chunk alignment."]
#[doc = " @return"]
#[doc = "   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
extern "C" {
    #[doc = " @internal Helper to calculate memory size required to store given"]
    #[doc = " number of objects."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " If page boundaries may be ignored, it is just a product of total"]
    #[doc = " object size including header and trailer and number of objects."]
    #[doc = " Otherwise, it is a number of pages required to store given number of"]
    #[doc = " objects without crossing page boundary."]
    #[doc = ""]
    #[doc = " Note that if object size is bigger than page size, then it assumes"]
    #[doc = " that pages are grouped in subsets of physically continuous pages big"]
    #[doc = " enough to store at least one object."]
    #[doc = ""]
    #[doc = " Minimum size of memory chunk is the total element size."]
    #[doc = " Required memory chunk alignment is the cache line size."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects to be added in mempool."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[in] chunk_reserve"]
    #[doc = "   Amount of memory that must be reserved at the beginning of each page,"]
    #[doc = "   or at the beginning of the memory area if pg_shift is 0."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size."]
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: usize,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Default way to calculate memory size required to store given number of"]
    #[doc = " objects."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_calc_mem_size_helper(mp, obj_num, pg_shift,"]
    #[doc = " 0, min_chunk_size, align)."]
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
#[doc = " Function to be called for each populated object."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] opaque"]
#[doc = "   An opaque pointer passed to iterator."]
#[doc = " @param[in] vaddr"]
#[doc = "   Object virtual address."]
#[doc = " @param[in] iova"]
#[doc = "   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk."]
#[doc = ""]
#[doc = " Populated objects should be enqueued to the pool, e.g. using"]
#[doc = " rte_mempool_ops_enqueue_bulk()."]
#[doc = ""]
#[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
#[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
#[doc = " and allocated objects may span two pages."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] max_objs"]
#[doc = "   Maximum number of objects to be populated."]
#[doc = " @param[in] vaddr"]
#[doc = "   The virtual address of memory that should be used to store objects."]
#[doc = " @param[in] iova"]
#[doc = "   The IO address"]
#[doc = " @param[in] len"]
#[doc = "   The length of memory in bytes."]
#[doc = " @param[in] obj_cb"]
#[doc = "   Callback function to be executed for each populated object."]
#[doc = " @param[in] obj_cb_arg"]
#[doc = "   An opaque pointer passed to the callback function."]
#[doc = " @return"]
#[doc = "   The number of objects added on success."]
#[doc = "   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @internal Helper to populate memory pool object using provided memory"]
    #[doc = " chunk: just slice objects one by one, taking care of not"]
    #[doc = " crossing page boundaries."]
    #[doc = ""]
    #[doc = " If RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ is set in flags, the addresses"]
    #[doc = " of object headers will be aligned on a multiple of total_elt_sz."]
    #[doc = " This feature is used by octeontx hardware."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] flags"]
    #[doc = "   Logical OR of following flags:"]
    #[doc = "   - RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: align objects on addresses"]
    #[doc = "     multiple of total_elt_sz."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be added in mempool."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address corresponding to vaddr, or RTE_BAD_IOVA."]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added in mempool."]
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default way to populate memory pool object using provided memory chunk."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_populate_helper(mp, 0, max_objs, vaddr, iova,"]
    #[doc = " len, obj_cb, obj_cb_arg)."]
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(mp: *const rte_mempool, info: *mut rte_mempool_info) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to"]
    #[doc = " store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using"]
    #[doc = " provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mempool_ops), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).free as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_mempool_ops), "::", stringify!(free))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).enqueue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).calc_mem_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(calc_mem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).populate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(populate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue_contig_blocks as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue_contig_blocks)
        )
    );
}
impl Default for rte_mempool_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Structure storing the table of registered ops structs, each of which contain"]
#[doc = " the function pointers for the mempool ops functions."]
#[doc = " Each process has its own storage for this ops struct array so that"]
#[doc = " the mempools can be shared across primary and secondary processes."]
#[doc = " The indices used to access the array are valid across processes, whereas"]
#[doc = " any function pointers stored directly in the mempool struct would not be."]
#[doc = " This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops_table>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).num_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for rte_mempool_ops_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    #[doc = " @internal Wrapper for mempool_ops alloc callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; successfully allocated mempool pool_data."]
    #[doc = "   - <0: Error; code of alloc function."]
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops get_count callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   The number of available objects in the external pool."]
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops calc_mem_size callback."]
    #[doc = " API to calculate size of memory required to store specified number of"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size aligned at page boundary."]
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops populate callback."]
    #[doc = ""]
    #[doc = " Populate memory pool objects using provided memory chunk."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be populated."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address"]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, no objects are populated and a negative errno is returned."]
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wrapper for mempool_ops get_info callback."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[out] info"]
    #[doc = "   Pointer to the rte_mempool_info structure"]
    #[doc = " @return"]
    #[doc = "   - 0: Success; The mempool driver supports retrieving supplementary"]
    #[doc = "        mempool information"]
    #[doc = "   - -ENOTSUP - doesn't support get_info ops (valid case)."]
    pub fn rte_mempool_ops_get_info(mp: *const rte_mempool, info: *mut rte_mempool_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops free callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Set the ops of a mempool."]
    #[doc = ""]
    #[doc = " This can only be done on a mempool that is not populated, i.e. just after"]
    #[doc = " a call to rte_mempool_create_empty()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param name"]
    #[doc = "   Name of the ops structure to use for this mempool."]
    #[doc = " @param pool_config"]
    #[doc = "   Opaque data that can be passed by the application to the ops functions."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the mempool is now using the requested ops functions."]
    #[doc = "   - -EINVAL - Invalid ops struct name provided."]
    #[doc = "   - -EEXIST - mempool already has an ops struct assigned."]
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mempool operations."]
    #[doc = ""]
    #[doc = " @param ops"]
    #[doc = "   Pointer to an ops structure to register."]
    #[doc = " @return"]
    #[doc = "   - >=0: Success; return the index of the ops struct in the table."]
    #[doc = "   - -EINVAL - some missing callbacks while registering ops struct."]
    #[doc = "   - -ENOSPC - the maximum number of ops structs has been reached."]
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
#[doc = " An object callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function."]
#[doc = ""]
#[doc = " Arguments are the mempool and the opaque pointer given by the user in"]
#[doc = " rte_mempool_create()."]
pub type rte_mempool_ctor_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Create a new mempool named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``rte_memzone_reserve()`` to allocate memory. The"]
    #[doc = " pool contains n elements of elt_size. Its size is set to n."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mempool. The optimum size (in terms of"]
    #[doc = "   memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   If cache_size is non-zero, the rte_mempool library will try to"]
    #[doc = "   limit the accesses to the common lockless pool, by maintaining a"]
    #[doc = "   per-lcore object cache. This argument must be lower or equal to"]
    #[doc = "   RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose"]
    #[doc = "   cache_size to have \"n modulo cache_size == 0\": if this is"]
    #[doc = "   not the case, some elements will always stay in the pool and will"]
    #[doc = "   never be used. The access to the per-lcore table is of course"]
    #[doc = "   faster than the multi-producer/consumer pool. The cache can be"]
    #[doc = "   disabled if the cache_size argument is set to 0; it can be useful to"]
    #[doc = "   avoid losing objects in cache."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param mp_init"]
    #[doc = "   A function pointer that is called for initialization of the pool,"]
    #[doc = "   before object initialization. The user can initialize the private"]
    #[doc = "   data in this function if needed. This parameter can be NULL if"]
    #[doc = "   not needed."]
    #[doc = " @param mp_init_arg"]
    #[doc = "   An opaque pointer to data that can be used in the mempool"]
    #[doc = "   constructor function."]
    #[doc = " @param obj_init"]
    #[doc = "   A function pointer that is called for each object at"]
    #[doc = "   initialization of the pool. The user can set some meta data in"]
    #[doc = "   objects if needed. This parameter can be NULL if not needed."]
    #[doc = "   The obj_init() function takes the mempool pointer, the init_arg,"]
    #[doc = "   the object pointer and the object number as parameters."]
    #[doc = " @param obj_init_arg"]
    #[doc = "   An opaque pointer to data that can be used as an argument for"]
    #[doc = "   each call to the object constructor function."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The *flags* arguments is an OR of following flags:"]
    #[doc = "   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread"]
    #[doc = "     between channels in RAM: the pool allocator will add padding"]
    #[doc = "     between objects depending on the hardware configuration. See"]
    #[doc = "     Memory alignment constraints for details. If this flag is set,"]
    #[doc = "     the allocator will just align them to a cache line."]
    #[doc = "   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are"]
    #[doc = "     cache-aligned. This flag removes this constraint, and no"]
    #[doc = "     padding will be present between objects. This flag implies"]
    #[doc = "     MEMPOOL_F_NO_SPREAD."]
    #[doc = "   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_put() or rte_mempool_put_bulk() is"]
    #[doc = "     \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_get() or rte_mempool_get_bulk() is"]
    #[doc = "     \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "   - MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't"]
    #[doc = "     necessarily be contiguous in IO memory."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create an empty mempool"]
    #[doc = ""]
    #[doc = " The mempool is allocated and initialized, but it is not populated: no"]
    #[doc = " memory is allocated for the mempool elements. The user has to call"]
    #[doc = " rte_mempool_populate_*() to add memory chunks to the pool. Once"]
    #[doc = " populated, the user may also want to initialize each object with"]
    #[doc = " rte_mempool_obj_iter()."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The maximum number of elements that can be added in the mempool."]
    #[doc = "   The optimum size (in terms of memory usage) for a mempool is when n"]
    #[doc = "   is a power of two minus one: n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the cache. See rte_mempool_create() for details."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   Flags controlling the behavior of the mempool. See"]
    #[doc = "   rte_mempool_create() for details."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a mempool"]
    #[doc = ""]
    #[doc = " Unlink the mempool from global list, free the memory chunks, and all"]
    #[doc = " memory referenced by the mempool. The objects must not be used by"]
    #[doc = " other cores as they will be freed."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Add physically contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually and physically contiguous memory chunk in the pool"]
    #[doc = " where objects can be instantiated."]
    #[doc = ""]
    #[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
    #[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
    #[doc = " and allocated objects may span two pages."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param iova"]
    #[doc = "   The IO address"]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success (strictly positive)."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool the following code is returned:"]
    #[doc = "     (0): not enough room in chunk for one object."]
    #[doc = "     (-ENOSPC): mempool is already populated."]
    #[doc = "     (-ENOMEM): allocation failure."]
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add virtually contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually contiguous memory chunk in the pool where objects can"]
    #[doc = " be instantiated."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param addr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param pg_sz"]
    #[doc = "   The size of memory pages in this virtual area."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success (strictly positive)."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool the following code is returned:"]
    #[doc = "     (0): not enough room in chunk for one object."]
    #[doc = "     (-ENOSPC): mempool is already populated."]
    #[doc = "     (-ENOMEM): allocation failure."]
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: usize,
        pg_sz: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This is the default function used by rte_mempool_create() to populate"]
    #[doc = " the mempool. It adds memory allocated using rte_memzone_reserve()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory from anonymous mapping for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This function mmap an anonymous memory zone that is locked in"]
    #[doc = " memory to store the objects of the mempool."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, 0 is returned, rte_errno is set, and the chunk is not added in"]
    #[doc = "   the memory list of the mempool."]
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a function for each mempool element"]
    #[doc = ""]
    #[doc = " Iterate across all objects attached to a rte_mempool and call the"]
    #[doc = " callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param obj_cb"]
    #[doc = "   A function pointer that is called for each object."]
    #[doc = " @param obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of objects iterated."]
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Call a function for each mempool memory chunk"]
    #[doc = ""]
    #[doc = " Iterate across all memory chunks attached to a rte_mempool and call"]
    #[doc = " the callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param mem_cb"]
    #[doc = "   A function pointer that is called for each memory chunk."]
    #[doc = " @param mem_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of memory chunks iterated."]
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Dump the status of the mempool to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Create a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " This can be used by unregistered non-EAL threads to enable caching when they"]
    #[doc = " interact with a mempool."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "   The size of the mempool cache. See rte_mempool_create()'s cache_size"]
    #[doc = "   parameter description for more information. The same limits and"]
    #[doc = "   considerations apply here too."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of NUMA. The value can be"]
    #[doc = "   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone."]
    pub fn rte_mempool_cache_create(size: u32, socket_id: ::std::os::raw::c_int) -> *mut rte_mempool_cache;
}
extern "C" {
    #[doc = " Free a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " @param cache"]
    #[doc = "   A pointer to the mempool cache."]
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    #[doc = " Return the number of entries in the mempool."]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes. User-owned mempool caches are not accounted for."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of elements which have been allocated from the mempool"]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of free entries in the mempool."]
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check the consistency of mempool objects."]
    #[doc = ""]
    #[doc = " Verify the coherency of fields in the mempool structure. Also check"]
    #[doc = " that the cookies of mempool objects (even the ones that are not"]
    #[doc = " present in pool) have a correct value. If not, a panic will occur."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Dump the status of all mempools on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a mempool from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the mempool matching the name, or NULL if not found."]
    #[doc = "   NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    #[doc = ""]
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Get the header, trailer and total size of a mempool element."]
    #[doc = ""]
    #[doc = " Given a desired size of the mempool element and mempool flags,"]
    #[doc = " calculates header, trailer, body and total sizes of the mempool object."]
    #[doc = ""]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element, without header and trailer."]
    #[doc = " @param flags"]
    #[doc = "   The flags used for the mempool creation."]
    #[doc = "   Consult rte_mempool_create() for more information about possible values."]
    #[doc = "   The size of each element."]
    #[doc = " @param sz"]
    #[doc = "   The calculated detailed size the mempool object. May be NULL."]
    #[doc = " @return"]
    #[doc = "   Total size of the mempool object."]
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    #[doc = " Walk list of all memory pools"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_mempool_walk(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @internal Get page size used for mempool object allocation."]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    pub fn rte_mempool_get_page_size(mp: *mut rte_mempool, pg_sz: *mut usize) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
extern "C" {
    #[doc = " Get the name of the l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the tunnel packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write the packet type name into the buffer"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @param buf"]
    #[doc = "   The buffer where the string is written."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - (-1) if the buffer is too small"]
    pub fn rte_get_ptype_name(ptype: u32, buf: *mut ::std::os::raw::c_char, buflen: usize) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_sched() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_sched>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_sched>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).queue_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).traffic_class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).color as *const _ as usize },
        5usize,
        concat!("Offset of field: ", stringify!(rte_mbuf_sched), "::", stringify!(color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_sched>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(reserved)
        )
    );
}
pub mod _bindgen_ty_13 {
    #[doc = " enum for the tx_offload bit-fields lengths and offsets."]
    #[doc = " defines the layout of rte_mbuf tx_offload field."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_MBUF_L2_LEN_BITS: Type = 7;
    pub const RTE_MBUF_L3_LEN_BITS: Type = 9;
    pub const RTE_MBUF_L4_LEN_BITS: Type = 8;
    pub const RTE_MBUF_TSO_SEGSZ_BITS: Type = 16;
    pub const RTE_MBUF_OUTL3_LEN_BITS: Type = 9;
    pub const RTE_MBUF_OUTL2_LEN_BITS: Type = 7;
    pub const RTE_MBUF_TXOFLD_UNUSED_BITS: Type = 8;
    pub const RTE_MBUF_L2_LEN_OFS: Type = 0;
    pub const RTE_MBUF_L3_LEN_OFS: Type = 7;
    pub const RTE_MBUF_L4_LEN_OFS: Type = 16;
    pub const RTE_MBUF_TSO_SEGSZ_OFS: Type = 24;
    pub const RTE_MBUF_OUTL3_LEN_OFS: Type = 40;
    pub const RTE_MBUF_OUTL2_LEN_OFS: Type = 49;
    pub const RTE_MBUF_TXOFLD_UNUSED_OFS: Type = 56;
}
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: RTE_MARKER,
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer."]
    #[doc = " Force alignment to 8-bytes, so as to ensure we have the exact"]
    #[doc = " same mbuf cacheline0 layout for 32-bit and 64-bit. This makes"]
    #[doc = " working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub rearm_data: RTE_MARKER64,
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size"]
    #[doc = " of port field (16 bits), to support zero-copy broadcast."]
    #[doc = " It should only be accessed using the following functions:"]
    #[doc = " rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and"]
    #[doc = " rte_mbuf_refcnt_set(). The functionality of these functions (atomic,"]
    #[doc = " or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = "< Number of segments."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports)."]
    #[doc = " The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub rx_descriptor_fields1: RTE_MARKER,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if PKT_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if PKT_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    pub cacheline1: RTE_MARKER,
    #[doc = "< Next segment of scattered packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See"]
    #[doc = " rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect"]
    #[doc = " mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(inner_l2_type: u8, inner_l3_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).inner_esp_next_proto
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inner_esp_next_proto)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1))
    );
}
impl Default for rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).packet_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(packet_type)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter */"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .id as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).hi as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>())).reserved1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>())).reserved2 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>())).txq as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(txq)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>())).fdir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>())).sched as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>())).txadapter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(txadapter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>())).usr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(usr)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1))
    );
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).tx_offload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(tx_offload)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline0 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(cacheline0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(buf_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_iova as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(buf_iova))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rearm_data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(rearm_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(data_off))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).refcnt as *const _ as usize },
        18usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(refcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(nb_segs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).port as *const _ as usize },
        22usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(ol_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rx_descriptor_fields1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(pkt_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(data_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci as *const _ as usize },
        42usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(vlan_tci))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci_outer as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_len as *const _ as usize },
        54usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(buf_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pool as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(pool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline1 as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(cacheline1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).next as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).shinfo as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(shinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).priv_size as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(priv_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timesync as *const _ as usize },
        90usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(timesync))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).dynfield1 as *const _ as usize },
        92usize,
        concat!("Offset of field: ", stringify!(rte_mbuf), "::", stringify!(dynfield1))
    );
}
impl Default for rte_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void)>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_ext_shared_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_ext_shared_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_ext_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).free_cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).fcb_opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(fcb_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).refcnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for rte_mbuf_ext_shared_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Get the name of a RX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the RX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(mask: u64, buf: *mut ::std::os::raw::c_char, buflen: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a TX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag. Usually only one bit must be set."]
    #[doc = "   Several bits can be given if they belong to the same mask."]
    #[doc = "   Ex: PKT_TX_L4_MASK."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the TX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(mask: u64, buf: *mut ::std::os::raw::c_char, buflen: usize)
        -> ::std::os::raw::c_int;
}
#[doc = " Private data in case of pktmbuf pool."]
#[doc = ""]
#[doc = " A structure that contains some pktmbuf_pool-specific data that are"]
#[doc = " appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_pool_private>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_pool_private>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_data_room_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_data_room_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_priv_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Sanity checks on an mbuf."]
    #[doc = ""]
    #[doc = " Check the consistency of the given mbuf. The function will cause a"]
    #[doc = " panic if corruption is detected."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be checked."]
    #[doc = " @param is_header"]
    #[doc = "   True if the mbuf is a packet header, false if it is a sub-segment"]
    #[doc = "   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sanity checks on a mbuf."]
    #[doc = ""]
    #[doc = " Almost like rte_mbuf_sanity_check(), but this function gives the reason"]
    #[doc = " if corruption is detected rather than panic."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be checked."]
    #[doc = " @param is_header"]
    #[doc = "   True if the mbuf is a packet header, false if it is a sub-segment"]
    #[doc = "   of a packet (in this case, some fields like nb_segs are not checked)"]
    #[doc = " @param reason"]
    #[doc = "   A reference to a string pointer where to store the reason why a mbuf is"]
    #[doc = "   considered invalid."]
    #[doc = " @return"]
    #[doc = "   - 0 if no issue has been found, reason is left untouched."]
    #[doc = "   - -1 if a problem is detected, reason then points to a string describing"]
    #[doc = "     the reason why the mbuf is deemed invalid."]
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The packet mbuf constructor."]
    #[doc = ""]
    #[doc = " This function initializes some fields in the mbuf structure that are"]
    #[doc = " not modified by the user once created (origin pool, buffer start"]
    #[doc = " address, and so on). This function is given as a callback function to"]
    #[doc = " rte_mempool_obj_iter() or rte_mempool_create() at pool creation time."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_obj_iter() or rte_mempool_create()."]
    #[doc = " @param m"]
    #[doc = "   The mbuf to initialize."]
    #[doc = " @param i"]
    #[doc = "   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " A  packet mbuf pool constructor."]
    #[doc = ""]
    #[doc = " This function initializes the mempool private data in the case of a"]
    #[doc = " pktmbuf pool. This private data is needed by the driver. The"]
    #[doc = " function must be called on the mempool before it is used, or it"]
    #[doc = " can be given as a callback function to rte_mempool_create() at"]
    #[doc = " pool creation. It can be extended by the user, for example, to"]
    #[doc = " provide another packet size."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Create a mbuf pool."]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool. It is"]
    #[doc = " a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create a mbuf pool with a given mempool ops name"]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool. It is"]
    #[doc = " a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @param ops_name"]
    #[doc = "   The mempool ops name to be used for this mempool instead of"]
    #[doc = "   default mempool. The value can be *NULL* to use default mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
#[doc = " A structure that describes the pinned external buffer segment."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_pktmbuf_extmem {
    #[doc = "< The virtual address of data buffer."]
    pub buf_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The IO address of the data buffer."]
    pub buf_iova: rte_iova_t,
    #[doc = "< External buffer length in bytes."]
    pub buf_len: usize,
    #[doc = "< mbuf element size in bytes."]
    pub elt_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_extmem() {
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_extmem>(),
        32usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_extmem))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_extmem>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_extmem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_extmem>())).buf_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_extmem>())).buf_iova as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_extmem>())).buf_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pktmbuf_extmem>())).elt_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(elt_size)
        )
    );
}
impl Default for rte_pktmbuf_extmem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create a mbuf pool with external pinned data buffers."]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool that contains"]
    #[doc = " only mbufs with external buffer. It is a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @param ext_mem"]
    #[doc = "   Pointer to the array of structures describing the external memory"]
    #[doc = "   for data buffers. It is caller responsibility to register this memory"]
    #[doc = "   with rte_extmem_register() (if needed), map this memory to appropriate"]
    #[doc = "   physical device, etc."]
    #[doc = " @param ext_num"]
    #[doc = "   Number of elements in the ext_mem array."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_extbuf(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ext_mem: *const rte_pktmbuf_extmem,
        ext_num: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools."]
    #[doc = ""]
    #[doc = " Free a bulk of mbufs, and all their segments in case of chained buffers."]
    #[doc = " Each segment is added back into its original mempool."]
    #[doc = ""]
    #[doc = "  @param mbufs"]
    #[doc = "    Array of pointers to packet mbufs."]
    #[doc = "    The array may contain NULL pointers."]
    #[doc = "  @param count"]
    #[doc = "    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Create a \"clone\" of the given packet mbuf."]
    #[doc = ""]
    #[doc = " Walks through all segments of the given packet mbuf, and for each of them:"]
    #[doc = "  - Creates a new packet mbuf from the given pool."]
    #[doc = "  - Attaches newly created mbuf to the segment."]
    #[doc = " Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values"]
    #[doc = " from the original packet mbuf."]
    #[doc = ""]
    #[doc = " @param md"]
    #[doc = "   The packet mbuf to be cloned."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new \"clone\" mbuf on success."]
    #[doc = "   - NULL if allocation fails."]
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Create a full copy of a given packet mbuf."]
    #[doc = ""]
    #[doc = " Copies all the data from a given packet mbuf to a newly allocated"]
    #[doc = " set of mbufs. The private data are is not copied."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be copiedd."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @param offset"]
    #[doc = "   The number of bytes to skip before copying."]
    #[doc = "   If the mbuf does not have that many bytes, it is an error"]
    #[doc = "   and NULL is returned."]
    #[doc = " @param length"]
    #[doc = "   The upper limit on bytes to copy.  Passing UINT32_MAX"]
    #[doc = "   means all data (after offset)."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new \"clone\" mbuf on success."]
    #[doc = "   - NULL if allocation fails."]
    pub fn rte_pktmbuf_copy(m: *const rte_mbuf, mp: *mut rte_mempool, offset: u32, length: u32) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Dump an mbuf structure to a file."]
    #[doc = ""]
    #[doc = " Dump all fields for the given packet mbuf and all its associated"]
    #[doc = " segments (in the case of a chained buffer)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param dump_len"]
    #[doc = "   If dump_len != 0, also dump the \"dump_len\" first data bytes of"]
    #[doc = "   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
pub mod rte_timer_type {
    #[doc = " Timer type: Periodic or single (one-shot)."]
    pub type Type = ::std::os::raw::c_uint;
    pub const SINGLE: Type = 0;
    pub const PERIODICAL: Type = 1;
}
#[doc = " Timer status: A union of the state (stopped, pending, running,"]
#[doc = " config) and an owner (the id of the lcore that owns the timer)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_timer_status {
    pub __bindgen_anon_1: rte_timer_status__bindgen_ty_1,
    #[doc = "< To atomic-set status + owner."]
    pub u32_: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_timer_status__bindgen_ty_1 {
    #[doc = "< Stop, pending, running, config."]
    pub state: u16,
    #[doc = "< The lcore that owns the timer."]
    pub owner: i16,
}
#[test]
fn bindgen_test_layout_rte_timer_status__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).owner as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_timer_status() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_timer_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer_status>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status),
            "::",
            stringify!(u32_)
        )
    );
}
impl Default for rte_timer_status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Callback function type for timer expiry."]
pub type rte_timer_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_timer, arg2: *mut ::std::os::raw::c_void)>;
#[doc = " A structure describing a timer in RTE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_timer {
    #[doc = "< Time when timer expire."]
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    #[doc = "< Status of timer."]
    pub status: rte_timer_status,
    #[doc = "< Period of timer (0 if not periodic)."]
    pub period: u64,
    #[doc = "< Callback function."]
    pub f: rte_timer_cb_t,
    #[doc = "< Argument to callback function."]
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_timer() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer>(),
        120usize,
        concat!("Size of: ", stringify!(rte_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).expire as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(expire))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).sl_next as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(sl_next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).status as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).period as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(period))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).f as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).arg as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(rte_timer), "::", stringify!(arg))
    );
}
impl Default for rte_timer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Allocate a timer data instance in shared memory to track a set of pending"]
    #[doc = " timer lists."]
    #[doc = ""]
    #[doc = " @param id_ptr"]
    #[doc = "   Pointer to variable into which to write the identifier of the allocated"]
    #[doc = "   timer data instance."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOSPC: maximum number of timer data instances already allocated"]
    pub fn rte_timer_data_alloc(id_ptr: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate a timer data instance."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Identifier of the timer data instance to deallocate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: invalid timer data instance identifier"]
    pub fn rte_timer_data_dealloc(id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the timer library."]
    #[doc = ""]
    #[doc = " Initializes internal variables (list, locks and so on) for the RTE"]
    #[doc = " timer library."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This function must be called in every process before using the library."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOMEM: Unable to allocate memory needed to initialize timer"]
    #[doc = "      subsystem"]
    pub fn rte_timer_subsystem_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free timer subsystem resources."]
    pub fn rte_timer_subsystem_finalize();
}
extern "C" {
    #[doc = " Initialize a timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_init() function initializes the timer handle *tim*"]
    #[doc = " for use. No operations can be performed on a timer before it is"]
    #[doc = " initialized."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer to initialize."]
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Reset and start the timer associated with the timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_reset() function resets and starts the timer"]
    #[doc = " associated with the timer handle *tim*. When the timer expires after"]
    #[doc = " *ticks* HPET cycles, the function specified by *fct* will be called"]
    #[doc = " with the argument *arg* on core *tim_lcore*."]
    #[doc = ""]
    #[doc = " If the timer associated with the timer handle is already running"]
    #[doc = " (in the RUNNING state), the function will fail. The user has to check"]
    #[doc = " the return value of the function to see if there is a chance that the"]
    #[doc = " timer is in the RUNNING state."]
    #[doc = ""]
    #[doc = " If the timer is being configured on another core (the CONFIG state),"]
    #[doc = " it will also fail."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped, it will be rescheduled with the"]
    #[doc = " new parameters."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is scheduled."]
    #[doc = "   - (-1): Timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_reset(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type::Type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_reset() succeeds."]
    #[doc = ""]
    #[doc = " Reset and start the timer associated with the timer handle. Always"]
    #[doc = " succeed. See rte_timer_reset() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This API should not be called inside a timer's callback function to"]
    #[doc = "   reset another timer; doing so could hang in certain scenarios. Instead,"]
    #[doc = "   the rte_timer_reset() API can be called directly and its return code"]
    #[doc = "   can be checked for success or failure."]
    pub fn rte_timer_reset_sync(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type::Type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Stop a timer."]
    #[doc = ""]
    #[doc = " The rte_timer_stop() function stops the timer associated with the"]
    #[doc = " timer handle *tim*. It may fail if the timer is currently running or"]
    #[doc = " being configured."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped (for instance, already expired),"]
    #[doc = " the function will succeed. The timer handle tim must have been"]
    #[doc = " initialized using rte_timer_init(), otherwise, undefined behavior"]
    #[doc = " will occur."]
    #[doc = ""]
    #[doc = " This function can be called safely from a timer callback. If it"]
    #[doc = " succeeds, the timer is not referenced anymore by the timer library"]
    #[doc = " and the timer structure can be freed (even in the callback"]
    #[doc = " function)."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is stopped."]
    #[doc = "   - (-1): The timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_stop() succeeds."]
    #[doc = ""]
    #[doc = " After a call to this function, the timer identified by *tim* is"]
    #[doc = " stopped. See rte_timer_stop() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   This API should not be called inside a timer's callback function to"]
    #[doc = "   stop another timer; doing so could hang in certain scenarios. Instead, the"]
    #[doc = "   rte_timer_stop() API can be called directly and its return code can"]
    #[doc = "   be checked for success or failure."]
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Test if a timer is pending."]
    #[doc = ""]
    #[doc = " The rte_timer_pending() function tests the PENDING status"]
    #[doc = " of the timer handle *tim*. A PENDING timer is one that has been"]
    #[doc = " scheduled and whose function has not yet been called."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: The timer is not pending."]
    #[doc = "   - 1: The timer is pending."]
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Time until the next timer on the current lcore"]
    #[doc = " This function gives the ticks until the next timer will be active."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - -EINVAL: invalid timer data instance identifier"]
    #[doc = "   - -ENOENT: no timer pending"]
    #[doc = "   - 0: a timer is pending and will run at next rte_timer_manage()"]
    #[doc = "   - >0: ticks until the next timer is ready"]
    pub fn rte_timer_next_ticks() -> i64;
}
extern "C" {
    #[doc = " Manage the timer list and execute callback functions."]
    #[doc = ""]
    #[doc = " This function must be called periodically from EAL lcores"]
    #[doc = " main_loop(). It browses the list of pending timers and runs all"]
    #[doc = " timers that are expired."]
    #[doc = ""]
    #[doc = " The precision of the timer depends on the call frequency of this"]
    #[doc = " function. However, the more often the function is called, the more"]
    #[doc = " CPU resources it will use."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: timer subsystem not yet initialized"]
    pub fn rte_timer_manage() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump statistics about timers."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -EINVAL: timer subsystem not yet initialized"]
    pub fn rte_timer_dump_stats(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_reset(), except that it allows a"]
    #[doc = " caller to specify the rte_timer_data instance containing the list to which"]
    #[doc = " the timer should be added."]
    #[doc = ""]
    #[doc = " @see rte_timer_reset()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer. This parameter can be NULL if (and"]
    #[doc = "   only if) rte_timer_alt_manage() will be used to manage this timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is scheduled."]
    #[doc = "   - (-1): Timer is in the RUNNING or CONFIG state."]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_reset(
        timer_data_id: u32,
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type::Type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_stop(), except that it allows a"]
    #[doc = " caller to specify the rte_timer_data instance containing the list from which"]
    #[doc = " this timer should be removed."]
    #[doc = ""]
    #[doc = " @see rte_timer_stop()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is stopped."]
    #[doc = "   - (-1): The timer is in the RUNNING or CONFIG state."]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_stop(timer_data_id: u32, tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
#[doc = " Callback function type for rte_timer_alt_manage()."]
pub type rte_timer_alt_manage_cb_t = ::std::option::Option<unsafe extern "C" fn(tim: *mut rte_timer)>;
extern "C" {
    #[doc = " Manage a set of timer lists and execute the specified callback function for"]
    #[doc = " all expired timers. This function is similar to rte_timer_manage(), except"]
    #[doc = " that it allows a caller to specify the timer_data instance that should"]
    #[doc = " be operated on, as well as a set of lcore IDs identifying which timer lists"]
    #[doc = " should be processed.  Callback functions of individual timers are ignored."]
    #[doc = ""]
    #[doc = " @see rte_timer_manage()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param poll_lcores"]
    #[doc = "   An array of lcore ids identifying the timer lists that should be processed."]
    #[doc = "   NULL is allowed - if NULL, the timer list corresponding to the lcore"]
    #[doc = "   calling this routine is processed (same as rte_timer_manage())."]
    #[doc = " @param n_poll_lcores"]
    #[doc = "   The size of the poll_lcores array. If 'poll_lcores' is NULL, this parameter"]
    #[doc = "   is ignored."]
    #[doc = " @param f"]
    #[doc = "   The callback function which should be called for all expired timers."]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_manage(
        timer_data_id: u32,
        poll_lcores: *mut ::std::os::raw::c_uint,
        n_poll_lcores: ::std::os::raw::c_int,
        f: rte_timer_alt_manage_cb_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Callback function type for rte_timer_stop_all()."]
pub type rte_timer_stop_all_cb_t =
    ::std::option::Option<unsafe extern "C" fn(tim: *mut rte_timer, arg: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Walk the pending timer lists for the specified lcore IDs, and for each timer"]
    #[doc = " that is encountered, stop it and call the specified callback function to"]
    #[doc = " process it further."]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param walk_lcores"]
    #[doc = "   An array of lcore ids identifying the timer lists that should be processed."]
    #[doc = " @param nb_walk_lcores"]
    #[doc = "   The size of the walk_lcores array."]
    #[doc = " @param f"]
    #[doc = "   The callback function which should be called for each timers. Can be NULL."]
    #[doc = " @param f_arg"]
    #[doc = "   An arbitrary argument that will be passed to f, if it is called."]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - EINVAL: invalid timer_data_id"]
    pub fn rte_timer_stop_all(
        timer_data_id: u32,
        walk_lcores: *mut ::std::os::raw::c_uint,
        nb_walk_lcores: ::std::os::raw::c_int,
        f: rte_timer_stop_all_cb_t,
        f_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as rte_timer_dump_stats(), except that it allows"]
    #[doc = " the caller to specify the rte_timer_data instance that should be used."]
    #[doc = ""]
    #[doc = " @see rte_timer_dump_stats()"]
    #[doc = ""]
    #[doc = " @param timer_data_id"]
    #[doc = "   An identifier indicating which instance of timer data should be used for"]
    #[doc = "   this operation."]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @return"]
    #[doc = "   - 0: success"]
    #[doc = "   - -EINVAL: invalid timer_data_id"]
    pub fn rte_timer_alt_dump_stats(timer_data_id: u32, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for shared access."]
    pub fn rte_mcfg_mem_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL shared memory configuration for exclusive access."]
    pub fn rte_mcfg_mem_write_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for shared access."]
    pub fn rte_mcfg_tailq_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL TAILQ list for exclusive access."]
    pub fn rte_mcfg_tailq_write_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for shared access."]
    pub fn rte_mcfg_mempool_read_unlock();
}
extern "C" {
    #[doc = " Lock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_lock();
}
extern "C" {
    #[doc = " Unlock the internal EAL Mempool list for exclusive access."]
    pub fn rte_mcfg_mempool_write_unlock();
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Lock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_lock();
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Unlock the internal EAL Timer Library lock for exclusive access."]
    pub fn rte_mcfg_timer_unlock();
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " If true, pages are put in single files (per memseg list),"]
    #[doc = " as opposed to creating a file per page."]
    pub fn rte_mcfg_get_single_file_segments() -> bool;
}
#[doc = " Function to be registered for the specific interrupt"]
pub type rte_intr_callback_fn = ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
#[doc = " Function to call after a callback is unregistered."]
#[doc = " Can be used to close fd and free cb_arg."]
pub type rte_intr_unregister_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(intr_handle: *mut rte_intr_handle, cb_arg: *mut ::std::os::raw::c_void)>;
pub mod rte_intr_handle_type {
    #[doc = " The interrupt source type, e.g. UIO, VFIO, ALARM etc."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< generic unknown handle"]
    pub const RTE_INTR_HANDLE_UNKNOWN: Type = 0;
    #[doc = "< uio device handle"]
    pub const RTE_INTR_HANDLE_UIO: Type = 1;
    #[doc = "< uio generic handle"]
    pub const RTE_INTR_HANDLE_UIO_INTX: Type = 2;
    #[doc = "< vfio device handle (legacy)"]
    pub const RTE_INTR_HANDLE_VFIO_LEGACY: Type = 3;
    #[doc = "< vfio device handle (MSI)"]
    pub const RTE_INTR_HANDLE_VFIO_MSI: Type = 4;
    #[doc = "< vfio device handle (MSIX)"]
    pub const RTE_INTR_HANDLE_VFIO_MSIX: Type = 5;
    #[doc = "< alarm handle"]
    pub const RTE_INTR_HANDLE_ALARM: Type = 6;
    #[doc = "< external handler"]
    pub const RTE_INTR_HANDLE_EXT: Type = 7;
    #[doc = "< virtual device"]
    pub const RTE_INTR_HANDLE_VDEV: Type = 8;
    #[doc = "< device event handle"]
    pub const RTE_INTR_HANDLE_DEV_EVENT: Type = 9;
    #[doc = "< VFIO request handle"]
    pub const RTE_INTR_HANDLE_VFIO_REQ: Type = 10;
    #[doc = "< count of elements"]
    pub const RTE_INTR_HANDLE_MAX: Type = 11;
}
pub type rte_intr_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_data {
    #[doc = "< event type"]
    pub event: u32,
    #[doc = "< User data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< IN: callback fun"]
    pub cb_fun: rte_intr_event_cb_t,
    #[doc = "< IN: callback arg"]
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_data>(),
        32usize,
        concat!("Size of: ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).event as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_epoll_data), "::", stringify!(event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_epoll_data), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_fun as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_arg)
        )
    );
}
impl Default for rte_epoll_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_14 {
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_EPOLL_INVALID: Type = 0;
    pub const RTE_EPOLL_VALID: Type = 1;
    pub const RTE_EPOLL_EXEC: Type = 2;
}
#[doc = " interrupt epoll event obj, taken by epoll_event.ptr"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_event {
    #[doc = "< OUT: event status"]
    pub status: u32,
    #[doc = "< OUT: event fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< OUT: epoll instance the ev associated with"]
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_event>(),
        48usize,
        concat!("Size of: ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).fd as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_epoll_event), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epfd as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_epoll_event), "::", stringify!(epfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epdata)
        )
    );
}
impl Default for rte_epoll_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    #[doc = "< handle type"]
    pub type_: rte_intr_handle_type::Type,
    #[doc = "< max interrupt requested"]
    pub max_intr: u32,
    #[doc = "< number of available efd(event fd)"]
    pub nb_efd: u32,
    #[doc = "< size of efd counter, used for vdev"]
    pub efd_counter_size: u8,
    #[doc = "< intr vectors/efds mapping"]
    pub efds: [::std::os::raw::c_int; 512usize],
    pub elist: [rte_epoll_event; 512usize],
    #[doc = "< intr vector number array"]
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< device driver handle (Windows)"]
    pub handle: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< interrupt event file descriptor"]
    pub fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " VFIO device file descriptor"]
    pub vfio_dev_fd: ::std::os::raw::c_int,
    #[doc = " UIO cfg file desc for uio_pci_generic"]
    pub uio_cfg_fd: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).vfio_dev_fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vfio_dev_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).uio_cfg_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uio_cfg_fd)
        )
    );
}
impl Default for rte_intr_handle__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1__bindgen_ty_1>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
impl Default for rte_intr_handle__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for rte_intr_handle__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle>(),
        26656usize,
        concat!("Size of: ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).max_intr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(max_intr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).nb_efd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(nb_efd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).efd_counter_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efd_counter_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).efds as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_intr_handle), "::", stringify!(efds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).elist as *const _ as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).intr_vec as *const _ as usize },
        26648usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(intr_vec)
        )
    );
}
impl Default for rte_intr_handle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " It waits for events on the epoll instance."]
    #[doc = " Retries if signal received."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller wait for events."]
    #[doc = " @param events"]
    #[doc = "   Memory area contains the events that will be available for the caller."]
    #[doc = " @param maxevents"]
    #[doc = "   Up to maxevents are returned, must greater than zero."]
    #[doc = " @param timeout"]
    #[doc = "   Specifying a timeout of -1 causes a block indefinitely."]
    #[doc = "   Specifying a timeout equal to zero cause to return immediately."]
    #[doc = " @return"]
    #[doc = "   - On success, returns the number of available event."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It waits for events on the epoll instance."]
    #[doc = " Does not retry if signal received."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller wait for events."]
    #[doc = " @param events"]
    #[doc = "   Memory area contains the events that will be available for the caller."]
    #[doc = " @param maxevents"]
    #[doc = "   Up to maxevents are returned, must greater than zero."]
    #[doc = " @param timeout"]
    #[doc = "   Specifying a timeout of -1 causes a block indefinitely."]
    #[doc = "   Specifying a timeout equal to zero cause to return immediately."]
    #[doc = " @return"]
    #[doc = "   - On success, returns the number of available event."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_wait_interruptible(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It performs control operations on epoll instance referred by the epfd."]
    #[doc = " It requests that the operation op be performed for the target fd."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller perform control operations."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the target fd."]
    #[doc = " @param fd"]
    #[doc = "   The target fd on which the control ops perform."]
    #[doc = " @param event"]
    #[doc = "   Describes the object linked to the fd."]
    #[doc = "   Note: The caller must take care the object deletion after CTL_DEL."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The function returns the per thread epoll instance."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   epfd the epoll instance referred to."]
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {ADD, DEL}."]
    #[doc = " @param vec"]
    #[doc = "   RX intr vector number added to the epoll instance wait list."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It deletes registered eventfds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " It enables the packet I/O interrupt event if it's necessary."]
    #[doc = " It creates event fd for each interrupt vector when MSIX is used,"]
    #[doc = " otherwise it multiplexes a single event fd."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param nb_efd"]
    #[doc = "   Number of interrupt vector trying to enable."]
    #[doc = "   The value 0 is not allowed."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_efd_enable(intr_handle: *mut rte_intr_handle, nb_efd: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It disables the packet I/O interrupt event."]
    #[doc = " It deletes registered eventfds and closes the open fds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " The packet I/O interrupt on datapath is enabled or not."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The interrupt handle instance allows other causes or not."]
    #[doc = " Other causes stand for any none packet I/O interrupts."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The multiple interrupt vector capability of interrupt handle instance."]
    #[doc = " It returns zero if no multiple interrupt vector support."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " @internal"]
    #[doc = " Check if currently executing in interrupt context"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - non zero in case of interrupt context"]
    #[doc = "  - zero in case of process context"]
    pub fn rte_thread_is_intr() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It registers the callback for the specific interrupt. Multiple"]
    #[doc = " callbacks can be registered at the same time."]
    #[doc = " @param intr_handle"]
    #[doc = "  Pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It unregisters the callback according to the specified interrupt handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister the callback according to the specified interrupt handle,"]
    #[doc = " after it's no longer active. Fail if source is not active."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb_fn"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = " @param ucb_fn"]
    #[doc = "  callback to call before cb is unregistered (optional)."]
    #[doc = "  can be used to close fd and free cb_arg."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities marked for remove."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister_pending(
        intr_handle: *const rte_intr_handle,
        cb_fn: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
        ucb_fn: rte_intr_unregister_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It enables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It disables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " It acknowledges an interrupt raised for the specified handle."]
    #[doc = ""]
    #[doc = " This function should be called at the end of each interrupt handler either"]
    #[doc = " from application or driver, so that currently raised interrupt is acked and"]
    #[doc = " further new interrupts are raised."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_ack(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
#[doc = " A structure describing an ID for a PCI driver. Each driver provides a"]
#[doc = " table of these IDs for each device that it supports."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_id {
    #[doc = "< Class ID or RTE_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or PCI_ANY_ID."]
    pub subsystem_vendor_id: u16,
    #[doc = "< Subsystem device ID or PCI_ANY_ID."]
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_id>(),
        12usize,
        concat!("Size of: ", stringify!(rte_pci_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).class_id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_pci_id), "::", stringify!(class_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).vendor_id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_pci_id), "::", stringify!(vendor_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).device_id as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(rte_pci_id), "::", stringify!(device_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_vendor_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_device_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_device_id)
        )
    );
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).domain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_pci_addr), "::", stringify!(domain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).bus as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_pci_addr), "::", stringify!(bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).devid as *const _ as usize },
        5usize,
        concat!("Offset of field: ", stringify!(rte_pci_addr), "::", stringify!(devid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).function as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(function)
        )
    );
}
extern "C" {
    #[doc = " Utility function to write a pci device name, this device name can later be"]
    #[doc = " used to retrieve the corresponding rte_pci_addr using eal_parse_pci_*"]
    #[doc = " BDF helpers."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address"]
    #[doc = " @param output"]
    #[doc = "\tThe output buffer string"]
    #[doc = " @param size"]
    #[doc = "\tThe output buffer size"]
    pub fn rte_pci_device_name(addr: *const rte_pci_addr, output: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = " Utility function to compare two PCI device addresses."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address to compare"]
    #[doc = " @param addr2"]
    #[doc = "\tThe PCI Bus-Device-Function address to compare"]
    #[doc = " @return"]
    #[doc = "\t0 on equal PCI address."]
    #[doc = "\tPositive on addr is greater than addr2."]
    #[doc = "\tNegative on addr is less than addr2, or error."]
    pub fn rte_pci_addr_cmp(addr: *const rte_pci_addr, addr2: *const rte_pci_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Utility function to parse a string into a PCI location."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "\tThe string to parse"]
    #[doc = " @param addr"]
    #[doc = "\tThe reference to the structure where the location"]
    #[doc = "\tis stored."]
    #[doc = " @return"]
    #[doc = "\t0 on success"]
    #[doc = "\t<0 otherwise"]
    pub fn rte_pci_addr_parse(str_: *const ::std::os::raw::c_char, addr: *mut rte_pci_addr) -> ::std::os::raw::c_int;
}
pub mod rte_devtype {
    #[doc = " Type of generic device"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_DEVTYPE_ALLOWED: Type = 0;
    pub const RTE_DEVTYPE_BLOCKED: Type = 1;
    pub const RTE_DEVTYPE_VIRTUAL: Type = 2;
}
#[doc = " Structure that stores a device given by the user with its arguments"]
#[doc = ""]
#[doc = " A user device is a physical or a virtual device given by the user to"]
#[doc = " the DPDK application at startup through command line arguments."]
#[doc = ""]
#[doc = " The structure stores the configuration of the device, its PCI"]
#[doc = " identifier if it's a PCI device or the driver name if it's a virtual"]
#[doc = " device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype::Type,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy::Type,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    #[doc = "< bus handle."]
    pub bus: *mut rte_bus,
    #[doc = "< class handle."]
    pub cls: *mut rte_class,
    #[doc = "< bus-related part of device string."]
    pub bus_str: *const ::std::os::raw::c_char,
    #[doc = "< class-related part of device string."]
    pub cls_str: *const ::std::os::raw::c_char,
    #[doc = "< Device string storage."]
    pub data: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    #[doc = " Arguments string as given by user or \"\" for no argument."]
    pub args: *mut ::std::os::raw::c_char,
    pub drv_str: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).args as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).drv_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(drv_str)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_devargs() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs>(),
        136usize,
        concat!("Size of: ", stringify!(rte_devargs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).type_ as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).policy as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(policy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(cls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus_str as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(bus_str))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls_str as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(cls_str))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).data as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(rte_devargs), "::", stringify!(data))
    );
}
impl Default for rte_devargs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Parse a device string."]
    #[doc = ""]
    #[doc = " Verify that a bus is capable of handling the device passed"]
    #[doc = " in argument. Store which bus will handle the device, its name"]
    #[doc = " and the eventual device parameters."]
    #[doc = ""]
    #[doc = " The syntax is:"]
    #[doc = ""]
    #[doc = "     bus:device_identifier,arg1=val1,arg2=val2"]
    #[doc = ""]
    #[doc = " where \"bus:\" is the bus name followed by any character separator."]
    #[doc = " The bus name is optional. If no bus name is specified, each bus"]
    #[doc = " will attempt to recognize the device identifier. The first one"]
    #[doc = " to succeed will be used."]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = ""]
    #[doc = "     pci:0000:05.00.0,arg=val"]
    #[doc = "     05.00.0,arg=val"]
    #[doc = "     vdev:net_ring0"]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   String describing a device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative errno on error."]
    pub fn rte_devargs_parse(da: *mut rte_devargs, dev: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a device string."]
    #[doc = ""]
    #[doc = " Verify that a bus is capable of handling the device passed"]
    #[doc = " in argument. Store which bus will handle the device, its name"]
    #[doc = " and the eventual device parameters."]
    #[doc = ""]
    #[doc = " The device string is built with a printf-like syntax."]
    #[doc = ""]
    #[doc = " The syntax is:"]
    #[doc = ""]
    #[doc = "     bus:device_identifier,arg1=val1,arg2=val2"]
    #[doc = ""]
    #[doc = " where \"bus:\" is the bus name followed by any character separator."]
    #[doc = " The bus name is optional. If no bus name is specified, each bus"]
    #[doc = " will attempt to recognize the device identifier. The first one"]
    #[doc = " to succeed will be used."]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = ""]
    #[doc = "     pci:0000:05.00.0,arg=val"]
    #[doc = "     05.00.0,arg=val"]
    #[doc = "     vdev:net_ring0"]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    #[doc = " @param format"]
    #[doc = "   Format string describing a device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative errno on error."]
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert an rte_devargs in the global list."]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "  The devargs structure to insert."]
    #[doc = "  If a devargs for the same device is already inserted,"]
    #[doc = "  it will be updated and returned. It means *da pointer can change."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - Negative on error."]
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a device to the user device list"]
    #[doc = " See rte_devargs_parse() for details."]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the device."]
    #[doc = " @param devargs_str"]
    #[doc = "   The arguments as given by the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - A negative value on error"]
    pub fn rte_devargs_add(
        devtype: rte_devtype::Type,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a device from the user device list."]
    #[doc = " Its resources are freed."]
    #[doc = " If the devargs cannot be found, nothing happens."]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   The instance or a copy of devargs to remove."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on error."]
    #[doc = "   >0 if the devargs was not within the user device list."]
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of user devices of a specified type"]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the devices to counted."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of devices."]
    pub fn rte_devargs_type_count(devtype: rte_devtype::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " This function dumps the list of user device and their arguments."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_devargs_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Find next rte_devargs matching the provided bus name."]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   Limit the iteration to devargs related to buses"]
    #[doc = "   matching this name."]
    #[doc = "   Will return any next rte_devargs if NULL."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "   Starting iteration point. The iteration will start at"]
    #[doc = "   the first rte_devargs if NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Next rte_devargs entry matching the requested bus,"]
    #[doc = "   NULL if there is none."]
    pub fn rte_devargs_next(busname: *const ::std::os::raw::c_char, start: *const rte_devargs) -> *mut rte_devargs;
}
extern "C" {
    #[doc = " Seed the pseudo-random generator."]
    #[doc = ""]
    #[doc = " The generator is automatically seeded by the EAL init with a timer"]
    #[doc = " value. It may need to be re-seeded by the user with a real random"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " This function is not multi-thread safe in regards to other"]
    #[doc = " rte_srand() calls, nor is it in relation to concurrent rte_rand()"]
    #[doc = " calls."]
    #[doc = ""]
    #[doc = " @param seedval"]
    #[doc = "   The value of the seed."]
    pub fn rte_srand(seedval: u64);
}
extern "C" {
    #[doc = " Get a pseudo-random value."]
    #[doc = ""]
    #[doc = " The generator is not cryptographically secure."]
    #[doc = ""]
    #[doc = " If called from lcore threads, this function is thread-safe."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pseudo-random value between 0 and (1<<64)-1."]
    pub fn rte_rand() -> u64;
}
extern "C" {
    #[doc = " Generates a pseudo-random number with an upper bound."]
    #[doc = ""]
    #[doc = " This function returns an uniformly distributed (unbiased) random"]
    #[doc = " number less than a user-specified maximum value."]
    #[doc = ""]
    #[doc = " If called from lcore threads, this function is thread-safe."]
    #[doc = ""]
    #[doc = " @param upper_bound"]
    #[doc = "   The upper bound of the generated number."]
    #[doc = " @return"]
    #[doc = "   A pseudo-random value between 0 and (upper_bound-1)."]
    pub fn rte_rand_max(upper_bound: u64) -> u64;
}
#[doc = " Ethernet address:"]
#[doc = " A universally administered address is uniquely assigned to a device by its"]
#[doc = " manufacturer. The first three octets (in transmission order) contain the"]
#[doc = " Organizationally Unique Identifier (OUI). The following three (MAC-48 and"]
#[doc = " EUI-48) octets are assigned by that organization with the only constraint"]
#[doc = " of uniqueness."]
#[doc = " A locally administered address is assigned to a device by a network"]
#[doc = " administrator and does not contain OUIs."]
#[doc = " See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_rte_ether_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ether_addr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_addr>())).addr_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
extern "C" {
    #[doc = " Generate a random Ethernet address that is locally administered"]
    #[doc = " and not multicast."]
    #[doc = " @param addr"]
    #[doc = "   A pointer to Ethernet address."]
    pub fn rte_eth_random_addr(addr: *mut u8);
}
extern "C" {
    #[doc = " Format 48bits Ethernet address in pattern xx:xx:xx:xx:xx:xx."]
    #[doc = ""]
    #[doc = " @param buf"]
    #[doc = "   A pointer to buffer contains the formatted MAC address."]
    #[doc = " @param size"]
    #[doc = "   The format buffer size."]
    #[doc = " @param eth_addr"]
    #[doc = "   A pointer to a ether_addr structure."]
    pub fn rte_ether_format_addr(buf: *mut ::std::os::raw::c_char, size: u16, eth_addr: *const rte_ether_addr);
}
extern "C" {
    #[doc = " Convert string with Ethernet address to an ether_addr."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   A pointer to buffer contains the formatted MAC address."]
    #[doc = "   The supported formats are:"]
    #[doc = "     XX:XX:XX:XX:XX:XX or XXXX:XXXX:XXXX"]
    #[doc = "   where XX is a hex digit: 0-9, a-f, or A-F."]
    #[doc = " @param eth_addr"]
    #[doc = "   A pointer to a ether_addr structure."]
    #[doc = " @return"]
    #[doc = "   0 if successful"]
    #[doc = "   -1 and sets rte_errno if invalid string"]
    pub fn rte_ether_unformat_addr(
        str_: *const ::std::os::raw::c_char,
        eth_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Ethernet header: Contains the destination address, source address"]
#[doc = " and frame type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ether_hdr {
    #[doc = "< Destination address."]
    pub d_addr: rte_ether_addr,
    #[doc = "< Source address."]
    pub s_addr: rte_ether_addr,
    #[doc = "< Frame type."]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_ether_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ether_hdr>(),
        14usize,
        concat!("Size of: ", stringify!(rte_ether_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ether_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ether_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).d_addr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_ether_hdr), "::", stringify!(d_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).s_addr as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(rte_ether_hdr), "::", stringify!(s_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ether_hdr>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_hdr),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " Ethernet VLAN Header."]
#[doc = " Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type"]
#[doc = " of the encapsulated frame."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_vlan_hdr {
    #[doc = "< Priority (3) + CFI (1) + Identifier Code (12)"]
    pub vlan_tci: u16,
    #[doc = "< Ethernet type of encapsulated frame."]
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_rte_vlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(rte_vlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_vlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_hdr>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_hdr),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_hdr>())).eth_proto as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_hdr),
            "::",
            stringify!(eth_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_reg_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_reg_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(version)
        )
    );
}
impl Default for rte_dev_reg_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return eeprom"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start eeprom address for access"]
    pub offset: u32,
    #[doc = "< Length of eeprom region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_eeprom_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_eeprom_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).magic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for rte_dev_eeprom_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Placeholder for accessing plugin module eeprom"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module eeprom"]
    pub type_: u32,
    #[doc = "< Length of plugin module eeprom"]
    pub eeprom_len: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_module_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_module_info>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_module_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_module_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_module_info>())).eeprom_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(eeprom_len)
        )
    );
}
extern "C" {
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a device iterator."]
    #[doc = ""]
    #[doc = " This iterator allows accessing a list of devices matching some devargs."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by the function."]
    #[doc = "   The fields bus_str and cls_str might be dynamically allocated,"]
    #[doc = "   and could be freed by calling rte_eth_iterator_cleanup()."]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "   Device description string."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on successful initialization, negative otherwise."]
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates on devices with devargs filter."]
    #[doc = " The ownership is not checked."]
    #[doc = ""]
    #[doc = " The next port id is returned, and the iterator is updated."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by rte_eth_iterator_init()."]
    #[doc = "   Some fields bus_str and cls_str might be freed when no more port is found,"]
    #[doc = "   by calling rte_eth_iterator_cleanup()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A port id if found, RTE_MAX_ETHPORTS otherwise."]
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
extern "C" {
    #[doc = " Free some allocated fields of the iterator."]
    #[doc = ""]
    #[doc = " This function is automatically called by rte_eth_iterator_next()"]
    #[doc = " on the last iteration (i.e. when no more matching port is found)."]
    #[doc = ""]
    #[doc = " It is safe to call this function twice; it will do nothing more."]
    #[doc = ""]
    #[doc = " @param iter"]
    #[doc = "   Device iterator handle initialized by rte_eth_iterator_init()."]
    #[doc = "   The fields bus_str and cls_str are freed if needed."]
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
#[doc = " A structure used to retrieve statistics for an Ethernet port."]
#[doc = " Not all statistics fields in struct rte_eth_stats are supported"]
#[doc = " by any type of network interface card (NIC). If any statistics"]
#[doc = " field is not supported, its value is 0."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ipackets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).opackets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ibytes as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_eth_stats), "::", stringify!(ibytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).obytes as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_eth_stats), "::", stringify!(obytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).imissed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ierrors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).oerrors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).rx_nombuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ipackets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_opackets as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ibytes as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_obytes as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_errors as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_link {
    #[doc = "< ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_link>())).link_speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_link),
            "::",
            stringify!(link_speed)
        )
    );
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure the ring threshold registers of an RX/TX"]
#[doc = " queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).pthresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).hthresh as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).wthresh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
pub mod rte_eth_rx_mq_mode {
    #[doc = "  A set of values to identify what method is to be used to route"]
    #[doc = "  packets to multiple queues."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " None of DCB,RSS or VMDQ mode"]
    pub const ETH_MQ_RX_NONE: Type = 0;
    #[doc = " For RX side, only RSS is on"]
    pub const ETH_MQ_RX_RSS: Type = 1;
    #[doc = " For RX side,only DCB is on."]
    pub const ETH_MQ_RX_DCB: Type = 2;
    #[doc = " Both DCB and RSS enable"]
    pub const ETH_MQ_RX_DCB_RSS: Type = 3;
    #[doc = " Only VMDQ, no RSS nor DCB"]
    pub const ETH_MQ_RX_VMDQ_ONLY: Type = 4;
    #[doc = " RSS mode with VMDQ"]
    pub const ETH_MQ_RX_VMDQ_RSS: Type = 5;
    #[doc = " Use VMDQ+DCB to route traffic to queues"]
    pub const ETH_MQ_RX_VMDQ_DCB: Type = 6;
    #[doc = " Enable both VMDQ and DCB in VMDq"]
    pub const ETH_MQ_RX_VMDQ_DCB_RSS: Type = 7;
}
pub mod rte_eth_tx_mq_mode {
    #[doc = " A set of values to identify what method is to be used to transmit"]
    #[doc = " packets using multi-TCs."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< It is in neither DCB nor VT mode."]
    pub const ETH_MQ_TX_NONE: Type = 0;
    #[doc = "< For TX side,only DCB is on."]
    pub const ETH_MQ_TX_DCB: Type = 1;
    #[doc = "< For TX side,both DCB and VT is on."]
    pub const ETH_MQ_TX_VMDQ_DCB: Type = 2;
    #[doc = "< Only VT on, no DCB"]
    pub const ETH_MQ_TX_VMDQ_ONLY: Type = 3;
}
#[doc = " A structure used to configure the RX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode::Type,
    #[doc = "< Only used if JUMBO_FRAME enabled."]
    pub max_rx_pkt_len: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< hdr buf size (header_split enabled)."]
    pub split_hdr_size: u16,
    #[doc = " Per-port Rx offloads to be set using DEV_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_rx_pkt_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_lro_pkt_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).split_hdr_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(split_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_rxmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_vlan_type {
    #[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN."]
    #[doc = " Note that single VLAN is treated the same as inner VLAN."]
    pub type Type = ::std::os::raw::c_uint;
    pub const ETH_VLAN_TYPE_UNKNOWN: Type = 0;
    #[doc = "< Inner VLAN."]
    pub const ETH_VLAN_TYPE_INNER: Type = 1;
    #[doc = "< Single VLAN, or outer VLAN."]
    pub const ETH_VLAN_TYPE_OUTER: Type = 2;
    pub const ETH_VLAN_TYPE_MAX: Type = 3;
}
#[doc = " A structure used to describe a vlan filter."]
#[doc = " If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_filter_conf>(),
        512usize,
        concat!("Size of: ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_filter_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_filter_conf>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_filter_conf),
            "::",
            stringify!(ids)
        )
    );
}
impl Default for rte_vlan_filter_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature"]
#[doc = " of an Ethernet port."]
#[doc = " If not NULL, the *rss_key* pointer of the *rss_conf* structure points"]
#[doc = " to an array holding the RSS key to use for hashing specific header"]
#[doc = " fields of received packets. The length of this array should be indicated"]
#[doc = " by *rss_key_len* below. Otherwise, a default random hash key is used by"]
#[doc = " the device driver."]
#[doc = ""]
#[doc = " The *rss_key_len* field of the *rss_conf* structure indicates the length"]
#[doc = " in bytes of the array pointed by *rss_key*. To be compatible, this length"]
#[doc = " will be checked in i40e only. Others assume 40 bytes to be used as before."]
#[doc = ""]
#[doc = " The *rss_hf* field of the *rss_conf* structure indicates the different"]
#[doc = " types of IPv4/IPv6 packets to which the RSS hashing must be applied."]
#[doc = " Supplying an *rss_hf* equal to zero disables the RSS feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rss_conf {
    #[doc = "< If not NULL, 40-byte hash key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = "< Hash functions to apply - see below."]
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_hf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
}
impl Default for rte_eth_rss_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure VLAN traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    #[doc = "< mask for valid VLAN ID."]
    pub vlan_mask: u64,
    #[doc = " VLAN ID list for vlan mirroring."]
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vlan_mirror>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vlan_mirror>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_id)
        )
    );
}
impl Default for rte_eth_vlan_mirror {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mirror_conf {
    #[doc = "< Mirroring rule type"]
    pub rule_type: u8,
    #[doc = "< Destination pool for this mirror rule."]
    pub dst_pool: u8,
    #[doc = "< Bitmap of pool for pool mirroring"]
    pub pool_mask: u64,
    #[doc = " VLAN ID setting for VLAN mirroring."]
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mirror_conf>(),
        152usize,
        concat!("Size of: ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mirror_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).rule_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(rule_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).dst_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(dst_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).pool_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(pool_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).vlan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(vlan)
        )
    );
}
impl Default for rte_eth_mirror_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the"]
#[doc = " Receive Side Scaling (RSS) feature of an Ethernet port. To configure"]
#[doc = " more than 64 entries supported by hardware, an array of this structure"]
#[doc = " is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_reta_entry64>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_reta_entry64>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).reta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(reta)
        )
    );
}
impl Default for rte_eth_rss_reta_entry64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_nb_tcs {
    #[doc = " This enum indicates the possible number of traffic classes"]
    #[doc = " in DCB configurations"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< 4 TCs with DCB."]
    pub const ETH_4_TCS: Type = 4;
    #[doc = "< 8 TCs with DCB."]
    pub const ETH_8_TCS: Type = 8;
}
pub mod rte_eth_nb_pools {
    #[doc = " This enum indicates the possible number of queue pools"]
    #[doc = " in VMDQ configurations."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< 8 VMDq pools."]
    pub const ETH_8_POOLS: Type = 8;
    #[doc = "< 16 VMDq pools."]
    pub const ETH_16_POOLS: Type = 16;
    #[doc = "< 32 VMDq pools."]
    pub const ETH_32_POOLS: Type = 32;
    #[doc = "< 64 VMDq pools."]
    pub const ETH_64_POOLS: Type = 64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs::Type,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs::Type,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_tx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
impl Default for rte_eth_vmdq_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure the VMDQ+DCB feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues, based"]
#[doc = " on the vlan id in the vlan tag, and then to a specific queue within"]
#[doc = " that pool, using the user priority vlan tag field."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).vlan_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).pools as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).enable_default_pool as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).default_pool as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_pool_maps as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).pool_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).dcb_tc as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure the VMDQ feature of an Ethernet port when"]
#[doc = " not combined with the DCB feature."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues. By default,"]
#[doc = " the pool selection is based on the MAC address, the vlan id in the"]
#[doc = " vlan tag as specified in the pool_map array."]
#[doc = " Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool"]
#[doc = " selection using only the MAC address. MAC address to pool mapping is done"]
#[doc = " using the rte_eth_dev_mac_addr_add function, with the pool parameter"]
#[doc = " corresponding to the pool id."]
#[doc = ""]
#[doc = " Queue selection within the selected pool will be done using RSS when"]
#[doc = " it is enabled or revert to the first queue of the pool if not."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).vlan_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).pools as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_queue_pools as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_default_pool as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).default_pool as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_loop_back as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_pool_maps as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).rx_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).pool_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
impl Default for rte_eth_vmdq_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure the TX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_txmode {
    #[doc = "< TX multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode::Type,
    #[doc = " Per-port Tx offloads to be set using DEV_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_offload_capa field on rte_eth_dev_info"]
    #[doc = " structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).pvid as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_eth_txmode), "::", stringify!(pvid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_txmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " A structure used to configure an Rx packet segment to split."]
#[doc = ""]
#[doc = " If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,"]
#[doc = " the PMD will split the received packets into multiple segments"]
#[doc = " according to the specification in the description array:"]
#[doc = ""]
#[doc = " - The first network buffer will be allocated from the memory pool,"]
#[doc = "   specified in the first array element, the second buffer, from the"]
#[doc = "   pool in the second element, and so on."]
#[doc = ""]
#[doc = " - The offsets from the segment description elements specify"]
#[doc = "   the data offset from the buffer beginning except the first mbuf."]
#[doc = "   The first segment offset is added with RTE_PKTMBUF_HEADROOM."]
#[doc = ""]
#[doc = " - The lengths in the elements define the maximal data amount"]
#[doc = "   being received to each segment. The receiving starts with filling"]
#[doc = "   up the first mbuf data buffer up to specified length. If the"]
#[doc = "   there are data remaining (packet is longer than buffer in the first"]
#[doc = "   mbuf) the following data will be pushed to the next segment"]
#[doc = "   up to its own length, and so on."]
#[doc = ""]
#[doc = " - If the length in the segment description element is zero"]
#[doc = "   the actual buffer size will be deduced from the appropriate"]
#[doc = "   memory pool properties."]
#[doc = ""]
#[doc = " - If there is not enough elements to describe the buffer for entire"]
#[doc = "   packet of maximal length the following parameters will be used"]
#[doc = "   for the all remaining segments:"]
#[doc = "     - pool from the last valid element"]
#[doc = "     - the buffer size from this pool"]
#[doc = "     - zero offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = "< Reserved field."]
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg_split() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg_split>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg_split))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg_split>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg_split))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_split>())).mp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_split>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_split>())).offset as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_split>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for rte_eth_rxseg_split {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg>())).split as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_rxseg), "::", stringify!(split))
    );
}
impl Default for rte_eth_rxseg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure an RX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxconf {
    #[doc = "< RX ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of RX descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Per-queue Rx offloads to be set using DEV_RX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on rx_queue_offload_capa or rx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet."]
    #[doc = " Array elements are properties for consecutive Rx segments."]
    #[doc = ""]
    #[doc = " The supported capabilities of receiving segmentation is reported"]
    #[doc = " in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_free_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_drop_en as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_deferred_start as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_nseg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_nseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_seg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).reserved_64s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).reserved_ptrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_rxconf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure a TX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_txconf {
    #[doc = "< TX ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing TX buffers if there are"]
    #[doc = "less free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using DEV_TX_OFFLOAD_* flags."]
    #[doc = " Only offloads set on tx_queue_offload_capa or tx_offload_capa"]
    #[doc = " fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_rs_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_free_thresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_deferred_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).reserved_64s as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).reserved_ptrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_txconf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_cap() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_cap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_cap>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_nb_queues as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_nb_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_rx_2_tx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_rx_2_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_tx_2_rx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_tx_2_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_cap>())).max_nb_desc as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_cap),
            "::",
            stringify!(max_nb_desc)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_peer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_peer>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_peer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_peer>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_peer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_peer>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_peer),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_peer>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_peer),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
#[doc = ""]
#[doc = " A structure used to configure hairpin binding."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_hairpin_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hairpin_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hairpin_conf>(),
        132usize,
        concat!("Size of: ", stringify!(rte_eth_hairpin_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hairpin_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_hairpin_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hairpin_conf>())).peers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hairpin_conf),
            "::",
            stringify!(peers)
        )
    );
}
impl rte_eth_hairpin_conf {
    #[inline]
    pub fn peer_count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_peer_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_explicit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_explicit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn manual_bind(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manual_bind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        peer_count: u32,
        tx_explicit: u32,
        manual_bind: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let peer_count: u32 = unsafe { ::std::mem::transmute(peer_count) };
            peer_count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_explicit: u32 = unsafe { ::std::mem::transmute(tx_explicit) };
            tx_explicit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let manual_bind: u32 = unsafe { ::std::mem::transmute(manual_bind) };
            manual_bind as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet."]
    #[doc = ""]
    #[doc = " - For TSO packet this is the total number of data descriptors allowed"]
    #[doc = "   by device."]
    #[doc = ""]
    #[doc = " @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU."]
    #[doc = ""]
    #[doc = " - For non-TSO packet, this is the maximum allowed number of segments"]
    #[doc = "   in a single transmit packet."]
    #[doc = ""]
    #[doc = " - For TSO packet each segment within the TSO may span up to this"]
    #[doc = "   value."]
    #[doc = ""]
    #[doc = " @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_min as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_seg_max as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_mtu_seg_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
pub mod rte_eth_fc_mode {
    #[doc = " This enum indicates the flow control mode"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Disable flow control."]
    pub const RTE_FC_NONE: Type = 0;
    #[doc = "< RX pause frame, enable flowctrl on TX side."]
    pub const RTE_FC_RX_PAUSE: Type = 1;
    #[doc = "< TX pause frame, enable flowctrl on RX side."]
    pub const RTE_FC_TX_PAUSE: Type = 2;
    #[doc = "< Enable flow control on both side."]
    pub const RTE_FC_FULL: Type = 3;
}
#[doc = " A structure used to configure Ethernet flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode::Type,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fc_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).high_water as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(high_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).low_water as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(low_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).pause_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(pause_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).send_xon as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(send_xon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mode as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(rte_eth_fc_conf), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mac_ctrl_frame_fwd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mac_ctrl_frame_fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).autoneg as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(autoneg)
        )
    );
}
impl Default for rte_eth_fc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to configure Ethernet priority flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_pfc_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_pfc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).fc as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_pfc_conf), "::", stringify!(fc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for rte_eth_pfc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_tunnel_type {
    #[doc = " Tunneled type."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_TUNNEL_TYPE_NONE: Type = 0;
    pub const RTE_TUNNEL_TYPE_VXLAN: Type = 1;
    pub const RTE_TUNNEL_TYPE_GENEVE: Type = 2;
    pub const RTE_TUNNEL_TYPE_TEREDO: Type = 3;
    pub const RTE_TUNNEL_TYPE_NVGRE: Type = 4;
    pub const RTE_TUNNEL_TYPE_IP_IN_GRE: Type = 5;
    pub const RTE_L2_TUNNEL_TYPE_E_TAG: Type = 6;
    pub const RTE_TUNNEL_TYPE_VXLAN_GPE: Type = 7;
    pub const RTE_TUNNEL_TYPE_MAX: Type = 8;
}
#[doc = " ARP header IPv4 payload."]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_arp_ipv4 {
    pub arp_sha: rte_ether_addr,
    pub arp_sip: u32,
    pub arp_tha: rte_ether_addr,
    pub arp_tip: u32,
}
#[test]
fn bindgen_test_layout_rte_arp_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_arp_ipv4>(),
        20usize,
        concat!("Size of: ", stringify!(rte_arp_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_arp_ipv4>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_arp_ipv4))
    );
}
#[doc = " ARP header."]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_arp_hdr {
    pub arp_hardware: u16,
    pub arp_protocol: u16,
    pub arp_hlen: u8,
    pub arp_plen: u8,
    pub arp_opcode: u16,
    pub arp_data: rte_arp_ipv4,
}
#[test]
fn bindgen_test_layout_rte_arp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_arp_hdr>(),
        28usize,
        concat!("Size of: ", stringify!(rte_arp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_arp_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_arp_hdr))
    );
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Make a RARP packet based on MAC addr."]
    #[doc = ""]
    #[doc = " @param mpool"]
    #[doc = "   Pointer to the rte_mempool"]
    #[doc = " @param mac"]
    #[doc = "   Pointer to the MAC addr"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - RARP packet pointer on success, or NULL on error"]
    pub fn rte_net_make_rarp_packet(mpool: *mut rte_mempool, mac: *const rte_ether_addr) -> *mut rte_mbuf;
}
#[doc = " ICMP Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: rte_be16_t,
    pub icmp_ident: rte_be16_t,
    pub icmp_seq_nb: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_icmp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_icmp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_icmp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_icmp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_icmp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_cksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_ident as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_icmp_hdr>())).icmp_seq_nb as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_icmp_hdr),
            "::",
            stringify!(icmp_seq_nb)
        )
    );
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(in_addr), "::", stringify!(s_addr))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(in6_addr), "::", stringify!(__in6_u))
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " IPv4 Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ipv4_hdr {
    #[doc = "< version and header length"]
    pub version_ihl: u8,
    #[doc = "< type of service"]
    pub type_of_service: u8,
    #[doc = "< length of packet"]
    pub total_length: rte_be16_t,
    #[doc = "< packet ID"]
    pub packet_id: rte_be16_t,
    #[doc = "< fragmentation offset"]
    pub fragment_offset: rte_be16_t,
    #[doc = "< time to live"]
    pub time_to_live: u8,
    #[doc = "< protocol ID"]
    pub next_proto_id: u8,
    #[doc = "< header checksum"]
    pub hdr_checksum: rte_be16_t,
    #[doc = "< source address"]
    pub src_addr: rte_be32_t,
    #[doc = "< destination address"]
    pub dst_addr: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_ipv4_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ipv4_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(rte_ipv4_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ipv4_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ipv4_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).version_ihl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(version_ihl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).type_of_service as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(type_of_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).total_length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).packet_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).fragment_offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(fragment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).time_to_live as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(time_to_live)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).next_proto_id as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(next_proto_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).hdr_checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(hdr_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).src_addr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv4_hdr>())).dst_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv4_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[doc = " IPv6 Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ipv6_hdr {
    #[doc = "< IP version, traffic class & flow label."]
    pub vtc_flow: rte_be32_t,
    #[doc = "< IP packet length - includes header size"]
    pub payload_len: rte_be16_t,
    #[doc = "< Protocol, next header."]
    pub proto: u8,
    #[doc = "< Hop limits."]
    pub hop_limits: u8,
    #[doc = "< IP address of source host."]
    pub src_addr: [u8; 16usize],
    #[doc = "< IP address of destination host(s)."]
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_ipv6_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ipv6_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(rte_ipv6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ipv6_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ipv6_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).vtc_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(vtc_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).payload_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(payload_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).proto as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(rte_ipv6_hdr), "::", stringify!(proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).hop_limits as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(hop_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).src_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_hdr>())).dst_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ipv6_fragment_ext {
    #[doc = "< Next header type"]
    pub next_header: u8,
    #[doc = "< Reserved"]
    pub reserved: u8,
    #[doc = "< All fragmentation data"]
    pub frag_data: rte_be16_t,
    #[doc = "< Packet ID"]
    pub id: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_ipv6_fragment_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_ipv6_fragment_ext>(),
        8usize,
        concat!("Size of: ", stringify!(rte_ipv6_fragment_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ipv6_fragment_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ipv6_fragment_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_fragment_ext>())).next_header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_fragment_ext),
            "::",
            stringify!(next_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_fragment_ext>())).reserved as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_fragment_ext),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_fragment_ext>())).frag_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_fragment_ext),
            "::",
            stringify!(frag_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ipv6_fragment_ext>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ipv6_fragment_ext),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " SCTP Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_sctp_hdr {
    #[doc = "< Source port."]
    pub src_port: rte_be16_t,
    #[doc = "< Destin port."]
    pub dst_port: rte_be16_t,
    #[doc = "< Validation tag."]
    pub tag: rte_be32_t,
    #[doc = "< Checksum."]
    pub cksum: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_sctp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_sctp_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(rte_sctp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_sctp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_sctp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_sctp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).tag as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_sctp_hdr), "::", stringify!(tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_sctp_hdr>())).cksum as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_sctp_hdr), "::", stringify!(cksum))
    );
}
#[doc = " TCP Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_tcp_hdr {
    #[doc = "< TCP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< TCP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< TX data sequence number."]
    pub sent_seq: rte_be32_t,
    #[doc = "< RX data acknowledgment sequence number."]
    pub recv_ack: rte_be32_t,
    #[doc = "< Data offset."]
    pub data_off: u8,
    #[doc = "< TCP flags"]
    pub tcp_flags: u8,
    #[doc = "< RX flow control window."]
    pub rx_win: rte_be16_t,
    #[doc = "< TCP checksum."]
    pub cksum: rte_be16_t,
    #[doc = "< TCP urgent pointer, if any."]
    pub tcp_urp: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_tcp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_tcp_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(rte_tcp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tcp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_tcp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(src_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(dst_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).sent_seq as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(sent_seq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).recv_ack as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(recv_ack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).data_off as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(data_off))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).tcp_flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tcp_hdr),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).rx_win as *const _ as usize },
        14usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(rx_win))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).cksum as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(cksum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tcp_hdr>())).tcp_urp as *const _ as usize },
        18usize,
        concat!("Offset of field: ", stringify!(rte_tcp_hdr), "::", stringify!(tcp_urp))
    );
}
#[doc = " UDP Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_udp_hdr {
    #[doc = "< UDP source port."]
    pub src_port: rte_be16_t,
    #[doc = "< UDP destination port."]
    pub dst_port: rte_be16_t,
    #[doc = "< UDP datagram length"]
    pub dgram_len: rte_be16_t,
    #[doc = "< UDP datagram checksum"]
    pub dgram_cksum: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_udp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_udp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_udp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_udp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_udp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_udp_hdr), "::", stringify!(src_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(rte_udp_hdr), "::", stringify!(dst_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dgram_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(dgram_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_udp_hdr>())).dgram_cksum as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_udp_hdr),
            "::",
            stringify!(dgram_cksum)
        )
    );
}
#[doc = " ESP Header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_esp_hdr {
    #[doc = "< Security Parameters Index"]
    pub spi: rte_be32_t,
    #[doc = "< packet sequence number"]
    pub seq: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_esp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_esp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_esp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_esp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_esp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_hdr>())).spi as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_esp_hdr), "::", stringify!(spi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_hdr>())).seq as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_esp_hdr), "::", stringify!(seq))
    );
}
#[doc = " ESP Trailer"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_esp_tail {
    #[doc = "< number of pad bytes (0-255)"]
    pub pad_len: u8,
    #[doc = "< IPv4 or IPv6 or next layer header"]
    pub next_proto: u8,
}
#[test]
fn bindgen_test_layout_rte_esp_tail() {
    assert_eq!(
        ::std::mem::size_of::<rte_esp_tail>(),
        2usize,
        concat!("Size of: ", stringify!(rte_esp_tail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_esp_tail>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_esp_tail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_tail>())).pad_len as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_esp_tail), "::", stringify!(pad_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_esp_tail>())).next_proto as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_esp_tail),
            "::",
            stringify!(next_proto)
        )
    );
}
#[doc = " higig2 frc header."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_frc {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_frc() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_frc>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_frc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_frc>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_frc))
    );
}
impl rte_higig2_frc {
    #[inline]
    pub fn ksop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ksop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mcst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn src_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lbid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ppd_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppd_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ksop: u32,
        tc: u32,
        mcst: u32,
        resv: u32,
        dst_modid: u32,
        dst_pid: u32,
        src_modid: u32,
        src_pid: u32,
        lbid: u32,
        ppd_type: u32,
        resv1: u32,
        dp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ksop: u32 = unsafe { ::std::mem::transmute(ksop) };
            ksop as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let tc: u32 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mcst: u32 = unsafe { ::std::mem::transmute(mcst) };
            mcst as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let resv: u32 = unsafe { ::std::mem::transmute(resv) };
            resv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dst_modid: u32 = unsafe { ::std::mem::transmute(dst_modid) };
            dst_modid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dst_pid: u32 = unsafe { ::std::mem::transmute(dst_pid) };
            dst_pid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let src_modid: u32 = unsafe { ::std::mem::transmute(src_modid) };
            src_modid as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let src_pid: u32 = unsafe { ::std::mem::transmute(src_pid) };
            src_pid as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let lbid: u32 = unsafe { ::std::mem::transmute(lbid) };
            lbid as u64
        });
        __bindgen_bitfield_unit.set(56usize, 3u8, {
            let ppd_type: u32 = unsafe { ::std::mem::transmute(ppd_type) };
            ppd_type as u64
        });
        __bindgen_bitfield_unit.set(59usize, 3u8, {
            let resv1: u32 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 2u8, {
            let dp: u32 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type0 header"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_ppt_type0 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_ppt_type0() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_ppt_type0>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_ppt_type0))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_ppt_type0>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_ppt_type0))
    );
}
impl rte_higig2_ppt_type0 {
    #[inline]
    pub fn mirror(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_done(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ingress_tagged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress_tagged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_tgid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dst_tgid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dst_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn label_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_label_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vc_label0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_high(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vid_low(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn opc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn srce_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srce_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hdr_ext_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mirror: u32,
        mirror_done: u32,
        mirror_only: u32,
        ingress_tagged: u32,
        dst_tgid: u32,
        dst_t: u32,
        vc_label2: u32,
        label_present: u32,
        l3: u32,
        res: u32,
        vc_label1: u32,
        vc_label0: u32,
        vid_high: u32,
        vid_low: u32,
        opc: u32,
        res1: u32,
        srce_t: u32,
        pf: u32,
        res2: u32,
        hdr_ext_length: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirror: u32 = unsafe { ::std::mem::transmute(mirror) };
            mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mirror_done: u32 = unsafe { ::std::mem::transmute(mirror_done) };
            mirror_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mirror_only: u32 = unsafe { ::std::mem::transmute(mirror_only) };
            mirror_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ingress_tagged: u32 = unsafe { ::std::mem::transmute(ingress_tagged) };
            ingress_tagged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let dst_tgid: u32 = unsafe { ::std::mem::transmute(dst_tgid) };
            dst_tgid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dst_t: u32 = unsafe { ::std::mem::transmute(dst_t) };
            dst_t as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let vc_label2: u32 = unsafe { ::std::mem::transmute(vc_label2) };
            vc_label2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let label_present: u32 = unsafe { ::std::mem::transmute(label_present) };
            label_present as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let l3: u32 = unsafe { ::std::mem::transmute(l3) };
            l3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let vc_label1: u32 = unsafe { ::std::mem::transmute(vc_label1) };
            vc_label1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let vc_label0: u32 = unsafe { ::std::mem::transmute(vc_label0) };
            vc_label0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let vid_high: u32 = unsafe { ::std::mem::transmute(vid_high) };
            vid_high as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vid_low: u32 = unsafe { ::std::mem::transmute(vid_low) };
            vid_low as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(51usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let srce_t: u32 = unsafe { ::std::mem::transmute(srce_t) };
            srce_t as u64
        });
        __bindgen_bitfield_unit.set(54usize, 2u8, {
            let pf: u32 = unsafe { ::std::mem::transmute(pf) };
            pf as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let hdr_ext_length: u32 = unsafe { ::std::mem::transmute(hdr_ext_length) };
            hdr_ext_length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 ppt type1 header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_higig2_ppt_type1 {
    pub classification: u16,
    pub resv: u16,
    pub vid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_higig2_ppt_type1() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_ppt_type1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_ppt_type1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_ppt_type1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_higig2_ppt_type1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).classification as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(classification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).resv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_ppt_type1>())).vid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_ppt_type1),
            "::",
            stringify!(vid)
        )
    );
}
impl rte_higig2_ppt_type1 {
    #[inline]
    pub fn opcode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn resv1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn src_t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_src_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pfm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn resv2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_resv2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_ext_len(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_hdr_ext_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opcode: u16,
        resv1: u16,
        src_t: u16,
        pfm: u16,
        resv2: u16,
        hdr_ext_len: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let opcode: u16 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let resv1: u16 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let src_t: u16 = unsafe { ::std::mem::transmute(src_t) };
            src_t as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let pfm: u16 = unsafe { ::std::mem::transmute(pfm) };
            pfm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let resv2: u16 = unsafe { ::std::mem::transmute(resv2) };
            resv2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdr_ext_len: u16 = unsafe { ::std::mem::transmute(hdr_ext_len) };
            hdr_ext_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_hdr {
    pub fcr: rte_higig2_frc,
    pub __bindgen_anon_1: rte_higig2_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_higig2_hdr__bindgen_ty_1 {
    pub ppt0: rte_higig2_ppt_type0,
    pub ppt1: rte_higig2_ppt_type1,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_rte_higig2_hdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_hdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_higig2_hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_hdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_hdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_hdr__bindgen_ty_1>())).ppt0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_hdr__bindgen_ty_1),
            "::",
            stringify!(ppt0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_hdr__bindgen_ty_1>())).ppt1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_higig2_hdr__bindgen_ty_1),
            "::",
            stringify!(ppt1)
        )
    );
}
impl Default for rte_higig2_hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_higig2_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_higig2_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_higig2_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_higig2_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_higig2_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_higig2_hdr>())).fcr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_higig2_hdr), "::", stringify!(fcr))
    );
}
impl Default for rte_higig2_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " eCPRI Common Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_common_hdr {
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_common_hdr__bindgen_ty_1 {
    #[doc = "< 4B common header in BE"]
    pub u32_: rte_be32_t,
    pub __bindgen_anon_1: rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_ecpri_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn c(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn revision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_revision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        type_: u32,
        c: u32,
        res: u32,
        revision: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let c: u32 = unsafe { ::std::mem::transmute(c) };
            c as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let revision: u32 = unsafe { ::std::mem::transmute(revision) };
            revision as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_ecpri_common_hdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_common_hdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_common_hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_common_hdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_common_hdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_common_hdr__bindgen_ty_1>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_common_hdr__bindgen_ty_1),
            "::",
            stringify!(u32_)
        )
    );
}
impl Default for rte_ecpri_common_hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_ecpri_common_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_common_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_common_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_common_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_common_hdr))
    );
}
impl Default for rte_ecpri_common_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " eCPRI Message Header of Type #0: IQ Data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_iq_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_iq_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_iq_data>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_iq_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_iq_data>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_iq_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_iq_data>())).pc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_iq_data),
            "::",
            stringify!(pc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_iq_data>())).seq_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_iq_data),
            "::",
            stringify!(seq_id)
        )
    );
}
#[doc = " eCPRI Message Header of Type #1: Bit Sequence"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_bit_seq {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_bit_seq() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_bit_seq>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_bit_seq))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_bit_seq>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_bit_seq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_bit_seq>())).pc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_bit_seq),
            "::",
            stringify!(pc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_bit_seq>())).seq_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_bit_seq),
            "::",
            stringify!(seq_id)
        )
    );
}
#[doc = " eCPRI Message Header of Type #2: Real-Time Control Data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_rtc_ctrl {
    #[doc = "< Real-Time Control Data ID"]
    pub rtc_id: rte_be16_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_rtc_ctrl() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_rtc_ctrl>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_rtc_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_rtc_ctrl>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_rtc_ctrl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_rtc_ctrl>())).rtc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_rtc_ctrl),
            "::",
            stringify!(rtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_rtc_ctrl>())).seq_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_rtc_ctrl),
            "::",
            stringify!(seq_id)
        )
    );
}
#[doc = " eCPRI Message Header of Type #3: Generic Data Transfer"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_gen_data {
    #[doc = "< Physical channel ID"]
    pub pc_id: rte_be32_t,
    #[doc = "< Sequence ID"]
    pub seq_id: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_gen_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_gen_data>(),
        8usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_gen_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_gen_data>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_gen_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_gen_data>())).pc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_gen_data),
            "::",
            stringify!(pc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_gen_data>())).seq_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_gen_data),
            "::",
            stringify!(seq_id)
        )
    );
}
#[doc = " eCPRI Message Header of Type #4: Remote Memory Access"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_rm_access {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< 48-bits address"]
    pub addr: [u8; 6usize],
    #[doc = "< number of bytes"]
    pub length: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_rm_access() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_rm_access>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_rm_access))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_rm_access>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_rm_access))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_rm_access>())).addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_rm_access),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_rm_access>())).length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_rm_access),
            "::",
            stringify!(length)
        )
    );
}
impl rte_ecpri_msg_rm_access {
    #[inline]
    pub fn ele_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ele_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn rr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rma_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rma_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ele_id: u32, rr: u32, rw: u32, rma_id: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ele_id: u32 = unsafe { ::std::mem::transmute(ele_id) };
            ele_id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rr: u32 = unsafe { ::std::mem::transmute(rr) };
            rr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let rw: u32 = unsafe { ::std::mem::transmute(rw) };
            rw as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let rma_id: u32 = unsafe { ::std::mem::transmute(rma_id) };
            rma_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " eCPRI Message Header of Type #5: One-Way Delay Measurement"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_delay_measure {
    #[doc = "< Measurement ID"]
    pub msr_id: u8,
    #[doc = "< Action Type"]
    pub act_type: u8,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_delay_measure() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_delay_measure>(),
        2usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_delay_measure))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_delay_measure>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_delay_measure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_delay_measure>())).msr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_delay_measure),
            "::",
            stringify!(msr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_delay_measure>())).act_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_delay_measure),
            "::",
            stringify!(act_type)
        )
    );
}
#[doc = " eCPRI Message Header of Type #6: Remote Reset"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_remote_reset {
    #[doc = "< Reset ID"]
    pub rst_id: rte_be16_t,
    #[doc = "< Reset Code Op"]
    pub rst_op: u8,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_remote_reset() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_remote_reset>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_remote_reset))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_remote_reset>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_remote_reset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_remote_reset>())).rst_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_remote_reset),
            "::",
            stringify!(rst_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_remote_reset>())).rst_op as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_remote_reset),
            "::",
            stringify!(rst_op)
        )
    );
}
#[doc = " eCPRI Message Header of Type #7: Event Indication"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ecpri_msg_event_ind {
    #[doc = "< Event ID"]
    pub evt_id: u8,
    #[doc = "< Event Type"]
    pub evt_type: u8,
    #[doc = "< Sequence Number"]
    pub seq: u8,
    #[doc = "< Number of Faults/Notif"]
    pub number: u8,
}
#[test]
fn bindgen_test_layout_rte_ecpri_msg_event_ind() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_msg_event_ind>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ecpri_msg_event_ind))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_msg_event_ind>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_ecpri_msg_event_ind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_event_ind>())).evt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_event_ind),
            "::",
            stringify!(evt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_event_ind>())).evt_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_event_ind),
            "::",
            stringify!(evt_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_event_ind>())).seq as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_event_ind),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_msg_event_ind>())).number as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_msg_event_ind),
            "::",
            stringify!(number)
        )
    );
}
#[doc = " eCPRI Combined Message Header Format: Common Header + Message Types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ecpri_combined_msg_hdr {
    pub common: rte_ecpri_common_hdr,
    pub __bindgen_anon_1: rte_ecpri_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ecpri_combined_msg_hdr__bindgen_ty_1 {
    pub type0: rte_ecpri_msg_iq_data,
    pub type1: rte_ecpri_msg_bit_seq,
    pub type2: rte_ecpri_msg_rtc_ctrl,
    pub type3: rte_ecpri_msg_gen_data,
    pub type4: rte_ecpri_msg_rm_access,
    pub type5: rte_ecpri_msg_delay_measure,
    pub type6: rte_ecpri_msg_remote_reset,
    pub type7: rte_ecpri_msg_event_ind,
    pub dummy: [rte_be32_t; 3usize],
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_ecpri_combined_msg_hdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).type7 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr__bindgen_ty_1>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
impl Default for rte_ecpri_combined_msg_hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_ecpri_combined_msg_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_ecpri_combined_msg_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_ecpri_combined_msg_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ecpri_combined_msg_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ecpri_combined_msg_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ecpri_combined_msg_hdr>())).common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ecpri_combined_msg_hdr),
            "::",
            stringify!(common)
        )
    );
}
impl Default for rte_ecpri_combined_msg_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Structure describing the parameters of a mbuf dynamic field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynfield {
    #[doc = "< Name of the field."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< The number of bytes to reserve."]
    pub size: usize,
    #[doc = "< The alignment constraint (power of 2)."]
    pub align: usize,
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mbuf_dynfield() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_dynfield>(),
        88usize,
        concat!("Size of: ", stringify!(rte_mbuf_dynfield))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_dynfield>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_dynfield))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).align as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynfield>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynfield),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_mbuf_dynfield {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Structure describing the parameters of a mbuf dynamic flag."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf_dynflag {
    #[doc = "< Name of the dynamic flag."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Reserved for future use, must be 0."]
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mbuf_dynflag() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_dynflag>(),
        68usize,
        concat!("Size of: ", stringify!(rte_mbuf_dynflag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_dynflag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_dynflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynflag>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynflag),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf_dynflag>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_dynflag),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_mbuf_dynflag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Register space for a dynamic field in the mbuf structure."]
    #[doc = ""]
    #[doc = " If the field is already registered (same name and parameters), its"]
    #[doc = " offset is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters (name, size,"]
    #[doc = "   alignment constraint and flags)."]
    #[doc = " @return"]
    #[doc = "   The offset in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: not enough room in mbuf."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name does not ends with \\0."]
    pub fn rte_mbuf_dynfield_register(params: *const rte_mbuf_dynfield) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register space for a dynamic field in the mbuf structure at offset."]
    #[doc = ""]
    #[doc = " If the field is already registered (same name, parameters and offset),"]
    #[doc = " the offset is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters (name, size,"]
    #[doc = "   alignment constraint and flags)."]
    #[doc = " @param offset"]
    #[doc = "   The requested offset. Ignored if SIZE_MAX is passed."]
    #[doc = " @return"]
    #[doc = "   The offset in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, flags, or offset)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EBUSY: the requested offset cannot be used."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: not enough room in mbuf."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name does not ends with \\0."]
    pub fn rte_mbuf_dynfield_register_offset(params: *const rte_mbuf_dynfield, offset: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a registered dynamic mbuf field."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A string identifying the dynamic field."]
    #[doc = " @param params"]
    #[doc = "   If not NULL, and if the lookup is successful, the structure is"]
    #[doc = "   filled with the parameters of the dynamic field."]
    #[doc = " @return"]
    #[doc = "   The offset of this field in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - ENOENT: no dynamic field matches this name."]
    pub fn rte_mbuf_dynfield_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynfield,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic flag in the mbuf structure."]
    #[doc = ""]
    #[doc = " If the flag is already registered (same name and parameters), its"]
    #[doc = " bitnum is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters of the dynamic"]
    #[doc = "   flag (name and options)."]
    #[doc = " @return"]
    #[doc = "   The number of the reserved bit, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name is longer than RTE_MBUF_DYN_NAMESIZE - 1."]
    pub fn rte_mbuf_dynflag_register(params: *const rte_mbuf_dynflag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic flag in the mbuf structure specifying bitnum."]
    #[doc = ""]
    #[doc = " If the flag is already registered (same name, parameters and bitnum),"]
    #[doc = " the bitnum is returned."]
    #[doc = ""]
    #[doc = " @param params"]
    #[doc = "   A structure containing the requested parameters of the dynamic"]
    #[doc = "   flag (name and options)."]
    #[doc = " @param bitnum"]
    #[doc = "   The requested bitnum. Ignored if UINT_MAX is passed."]
    #[doc = " @return"]
    #[doc = "   The number of the reserved bit, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EINVAL: invalid parameters (size, align, or flags)."]
    #[doc = "   - EEXIST: this name is already register with different parameters."]
    #[doc = "   - EBUSY: the requested bitnum cannot be used."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    #[doc = "   - ENAMETOOLONG: name is longer than RTE_MBUF_DYN_NAMESIZE - 1."]
    pub fn rte_mbuf_dynflag_register_bitnum(
        params: *const rte_mbuf_dynflag,
        bitnum: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a registered dynamic mbuf flag."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   A string identifying the dynamic flag."]
    #[doc = " @param params"]
    #[doc = "   If not NULL, and if the lookup is successful, the structure is"]
    #[doc = "   filled with the parameters of the dynamic flag."]
    #[doc = " @return"]
    #[doc = "   The offset of this flag in the mbuf structure, or -1 on error."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - ENOENT: no dynamic flag matches this name."]
    pub fn rte_mbuf_dynflag_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynflag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the status of dynamic fields and flags."]
    #[doc = ""]
    #[doc = " @param out"]
    #[doc = "   The stream where the status is displayed."]
    pub fn rte_mbuf_dyn_dump(out: *mut FILE);
}
pub type rte_mbuf_timestamp_t = u64;
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Register dynamic mbuf field and flag for Rx timestamp."]
    #[doc = ""]
    #[doc = " @param field_offset"]
    #[doc = "   Pointer to the offset of the registered mbuf field, can be NULL."]
    #[doc = "   The same field is shared for Rx and Tx timestamp."]
    #[doc = " @param rx_flag"]
    #[doc = "   Pointer to the mask of the registered offload flag, can be NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, -1 otherwise."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EEXIST: already registered with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more field or flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    pub fn rte_mbuf_dyn_rx_timestamp_register(
        field_offset: *mut ::std::os::raw::c_int,
        rx_flag: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Register dynamic mbuf field and flag for Tx timestamp."]
    #[doc = ""]
    #[doc = " @param field_offset"]
    #[doc = "   Pointer to the offset of the registered mbuf field, can be NULL."]
    #[doc = "   The same field is shared for Rx and Tx timestamp."]
    #[doc = " @param tx_flag"]
    #[doc = "   Pointer to the mask of the registered offload flag, can be NULL."]
    #[doc = " @return"]
    #[doc = "   0 on success, -1 otherwise."]
    #[doc = "   Possible values for rte_errno:"]
    #[doc = "   - EEXIST: already registered with different parameters."]
    #[doc = "   - EPERM: called from a secondary process."]
    #[doc = "   - ENOENT: no more field or flag available."]
    #[doc = "   - ENOMEM: allocation failure."]
    pub fn rte_mbuf_dyn_tx_timestamp_register(
        field_offset: *mut ::std::os::raw::c_int,
        tx_flag: *mut u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Flow rule attributes."]
#[doc = ""]
#[doc = " Priorities are set on a per rule based within groups."]
#[doc = ""]
#[doc = " Lower values denote higher priority, the highest priority for a flow rule"]
#[doc = " is 0, so that a flow that matches for than one rule, the rule with the"]
#[doc = " lowest priority value will always be matched."]
#[doc = ""]
#[doc = " Although optional, applications are encouraged to group similar rules as"]
#[doc = " much as possible to fully take advantage of hardware capabilities"]
#[doc = " (e.g. optimized matching) and work around limitations (e.g. a single"]
#[doc = " pattern type possibly allowed in a given group). Applications should be"]
#[doc = " aware that groups are not linked by default, and that they must be"]
#[doc = " explicitly linked by the application using the JUMP action."]
#[doc = ""]
#[doc = " Priority levels are arbitrary and up to the application, they"]
#[doc = " do not need to be contiguous nor start from 0, however the maximum number"]
#[doc = " varies between devices and may be affected by existing flow rules."]
#[doc = ""]
#[doc = " If a packet is matched by several rules of a given group for a given"]
#[doc = " priority level, the outcome is undefined. It can take any path, may be"]
#[doc = " duplicated or even cause unrecoverable errors."]
#[doc = ""]
#[doc = " Note that support for more than a single group and priority level is not"]
#[doc = " guaranteed."]
#[doc = ""]
#[doc = " Flow rules can apply to inbound and/or outbound traffic (ingress/egress)."]
#[doc = ""]
#[doc = " Several pattern items and actions are valid and can be used in both"]
#[doc = " directions. Those valid for only one direction are described as such."]
#[doc = ""]
#[doc = " At least one direction must be specified."]
#[doc = ""]
#[doc = " Specifying both directions at once for a given rule is not recommended"]
#[doc = " but may be valid in a few cases (e.g. shared counter)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_attr {
    #[doc = "< Priority group."]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_attr() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_attr>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_attr>())).group as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_flow_attr), "::", stringify!(group))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_attr>())).priority as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_attr),
            "::",
            stringify!(priority)
        )
    );
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod rte_flow_item_type {
    #[doc = " Matching pattern item types."]
    #[doc = ""]
    #[doc = " Pattern items fall in two categories:"]
    #[doc = ""]
    #[doc = " - Matching protocol headers and packet data, usually associated with a"]
    #[doc = "   specification structure. These must be stacked in the same order as the"]
    #[doc = "   protocol layers to match inside packets, starting from the lowest."]
    #[doc = ""]
    #[doc = " - Matching meta-data or affecting pattern processing, often without a"]
    #[doc = "   specification structure. Since they do not match packet contents, their"]
    #[doc = "   position in the list is usually not relevant."]
    #[doc = ""]
    #[doc = " See the description of individual types for more information. Those"]
    #[doc = " marked with [META] fall into the second category."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " End marker for item lists. Prevents further processing of items,"]
    #[doc = " thereby ending the pattern."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    pub const RTE_FLOW_ITEM_TYPE_END: Type = 0;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Used as a placeholder for convenience. It is ignored and simply"]
    #[doc = " discarded by PMDs."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    pub const RTE_FLOW_ITEM_TYPE_VOID: Type = 1;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Inverted matching, i.e. process packets that do not match the"]
    #[doc = " pattern."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    pub const RTE_FLOW_ITEM_TYPE_INVERT: Type = 2;
    #[doc = " Matches any protocol in place of the current layer, a single ANY"]
    #[doc = " may also stand for several protocol layers."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_any."]
    pub const RTE_FLOW_ITEM_TYPE_ANY: Type = 3;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress)"]
    #[doc = " the physical function of the current device."]
    #[doc = ""]
    #[doc = " No associated specification structure."]
    pub const RTE_FLOW_ITEM_TYPE_PF: Type = 4;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " given virtual function of the current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vf."]
    pub const RTE_FLOW_ITEM_TYPE_VF: Type = 5;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " physical port of the underlying device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_phy_port."]
    pub const RTE_FLOW_ITEM_TYPE_PHY_PORT: Type = 6;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
    #[doc = " given DPDK port ID."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_port_id."]
    pub const RTE_FLOW_ITEM_TYPE_PORT_ID: Type = 7;
    #[doc = " Matches a byte string of a given length at a given offset."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_raw."]
    pub const RTE_FLOW_ITEM_TYPE_RAW: Type = 8;
    #[doc = " Matches an Ethernet header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_eth."]
    pub const RTE_FLOW_ITEM_TYPE_ETH: Type = 9;
    #[doc = " Matches an 802.1Q/ad VLAN tag."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vlan."]
    pub const RTE_FLOW_ITEM_TYPE_VLAN: Type = 10;
    #[doc = " Matches an IPv4 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv4."]
    pub const RTE_FLOW_ITEM_TYPE_IPV4: Type = 11;
    #[doc = " Matches an IPv6 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6."]
    pub const RTE_FLOW_ITEM_TYPE_IPV6: Type = 12;
    #[doc = " Matches an ICMP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP: Type = 13;
    #[doc = " Matches a UDP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_udp."]
    pub const RTE_FLOW_ITEM_TYPE_UDP: Type = 14;
    #[doc = " Matches a TCP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_tcp."]
    pub const RTE_FLOW_ITEM_TYPE_TCP: Type = 15;
    #[doc = " Matches a SCTP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_sctp."]
    pub const RTE_FLOW_ITEM_TYPE_SCTP: Type = 16;
    #[doc = " Matches a VXLAN header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vxlan."]
    pub const RTE_FLOW_ITEM_TYPE_VXLAN: Type = 17;
    #[doc = " Matches a E_TAG header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_e_tag."]
    pub const RTE_FLOW_ITEM_TYPE_E_TAG: Type = 18;
    #[doc = " Matches a NVGRE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_nvgre."]
    pub const RTE_FLOW_ITEM_TYPE_NVGRE: Type = 19;
    #[doc = " Matches a MPLS header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_mpls."]
    pub const RTE_FLOW_ITEM_TYPE_MPLS: Type = 20;
    #[doc = " Matches a GRE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gre."]
    pub const RTE_FLOW_ITEM_TYPE_GRE: Type = 21;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Fuzzy pattern match, expect faster than default."]
    #[doc = ""]
    #[doc = " This is for device that support fuzzy matching option."]
    #[doc = " Usually a fuzzy matching is fast but the cost is accuracy."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_fuzzy."]
    pub const RTE_FLOW_ITEM_TYPE_FUZZY: Type = 22;
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    pub const RTE_FLOW_ITEM_TYPE_GTP: Type = 23;
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP-C packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    pub const RTE_FLOW_ITEM_TYPE_GTPC: Type = 24;
    #[doc = " Matches a GTP header."]
    #[doc = ""]
    #[doc = " Configure flow for GTP-U packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp."]
    pub const RTE_FLOW_ITEM_TYPE_GTPU: Type = 25;
    #[doc = " Matches a ESP header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_esp."]
    pub const RTE_FLOW_ITEM_TYPE_ESP: Type = 26;
    #[doc = " Matches a GENEVE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_geneve."]
    pub const RTE_FLOW_ITEM_TYPE_GENEVE: Type = 27;
    #[doc = " Matches a VXLAN-GPE header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_vxlan_gpe."]
    pub const RTE_FLOW_ITEM_TYPE_VXLAN_GPE: Type = 28;
    #[doc = " Matches an ARP header for Ethernet/IPv4."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_arp_eth_ipv4."]
    pub const RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: Type = 29;
    #[doc = " Matches the presence of any IPv6 extension header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6_ext."]
    pub const RTE_FLOW_ITEM_TYPE_IPV6_EXT: Type = 30;
    #[doc = " Matches any ICMPv6 header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6: Type = 31;
    #[doc = " Matches an ICMPv6 neighbor discovery solicitation."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_ns."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: Type = 32;
    #[doc = " Matches an ICMPv6 neighbor discovery advertisement."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_na."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: Type = 33;
    #[doc = " Matches the presence of any ICMPv6 neighbor discovery option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: Type = 34;
    #[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer"]
    #[doc = " address option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: Type = 35;
    #[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer"]
    #[doc = " address option."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
    pub const RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: Type = 36;
    #[doc = " Matches specified mark field."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_mark."]
    pub const RTE_FLOW_ITEM_TYPE_MARK: Type = 37;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches a metadata value."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_meta."]
    pub const RTE_FLOW_ITEM_TYPE_META: Type = 38;
    #[doc = " Matches a GRE optional key field."]
    #[doc = ""]
    #[doc = " The value should a big-endian 32bit integer."]
    #[doc = ""]
    #[doc = " When this item present the K bit is implicitly matched as \"1\""]
    #[doc = " in the default mask."]
    #[doc = ""]
    #[doc = " @p spec/mask type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    pub const RTE_FLOW_ITEM_TYPE_GRE_KEY: Type = 39;
    #[doc = " Matches a GTP extension header: PDU session container."]
    #[doc = ""]
    #[doc = " Configure flow for GTP packets with extension header type 0x85."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_gtp_psc."]
    pub const RTE_FLOW_ITEM_TYPE_GTP_PSC: Type = 40;
    #[doc = " Matches a PPPoE header."]
    #[doc = ""]
    #[doc = " Configure flow for PPPoE session packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe."]
    pub const RTE_FLOW_ITEM_TYPE_PPPOES: Type = 41;
    #[doc = " Matches a PPPoE header."]
    #[doc = ""]
    #[doc = " Configure flow for PPPoE discovery packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe."]
    pub const RTE_FLOW_ITEM_TYPE_PPPOED: Type = 42;
    #[doc = " Matches a PPPoE optional proto_id field."]
    #[doc = ""]
    #[doc = " It only applies to PPPoE session packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_pppoe_proto_id."]
    pub const RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: Type = 43;
    #[doc = " Matches Network service header (NSH)."]
    #[doc = " See struct rte_flow_item_nsh."]
    #[doc = ""]
    pub const RTE_FLOW_ITEM_TYPE_NSH: Type = 44;
    #[doc = " Matches Internet Group Management Protocol (IGMP)."]
    #[doc = " See struct rte_flow_item_igmp."]
    #[doc = ""]
    pub const RTE_FLOW_ITEM_TYPE_IGMP: Type = 45;
    #[doc = " Matches IP Authentication Header (AH)."]
    #[doc = " See struct rte_flow_item_ah."]
    #[doc = ""]
    pub const RTE_FLOW_ITEM_TYPE_AH: Type = 46;
    #[doc = " Matches a HIGIG header."]
    #[doc = " see struct rte_flow_item_higig2_hdr."]
    pub const RTE_FLOW_ITEM_TYPE_HIGIG2: Type = 47;
    #[doc = " [META]"]
    #[doc = ""]
    #[doc = " Matches a tag value."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_tag."]
    pub const RTE_FLOW_ITEM_TYPE_TAG: Type = 48;
    #[doc = " Matches a L2TPv3 over IP header."]
    #[doc = ""]
    #[doc = " Configure flow for L2TPv3 over IP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_l2tpv3oip."]
    pub const RTE_FLOW_ITEM_TYPE_L2TPV3OIP: Type = 49;
    #[doc = " Matches PFCP Header."]
    #[doc = " See struct rte_flow_item_pfcp."]
    #[doc = ""]
    pub const RTE_FLOW_ITEM_TYPE_PFCP: Type = 50;
    #[doc = " Matches eCPRI Header."]
    #[doc = ""]
    #[doc = " Configure flow for eCPRI over ETH or UDP packets."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ecpri."]
    pub const RTE_FLOW_ITEM_TYPE_ECPRI: Type = 51;
    #[doc = " Matches the presence of IPv6 fragment extension header."]
    #[doc = ""]
    #[doc = " See struct rte_flow_item_ipv6_frag_ext."]
    pub const RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT: Type = 52;
}
#[doc = " RTE_FLOW_ITEM_TYPE_HIGIG2"]
#[doc = " Matches higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_higig2_hdr {
    pub hdr: rte_higig2_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_higig2_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_higig2_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_item_higig2_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_higig2_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_higig2_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_higig2_hdr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_higig2_hdr),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for rte_flow_item_higig2_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static rte_flow_item_higig2_hdr_mask: rte_flow_item_higig2_hdr;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ANY"]
#[doc = ""]
#[doc = " Matches any protocol in place of the current layer, a single ANY may also"]
#[doc = " stand for several protocol layers."]
#[doc = ""]
#[doc = " This is usually specified as the first pattern item when looking for a"]
#[doc = " protocol anywhere in a packet."]
#[doc = ""]
#[doc = " A zeroed mask stands for any number of layers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_any {
    #[doc = "< Number of layers covered."]
    pub num: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_any() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_any>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_any))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_any>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_any))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_any>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_any),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VF"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a given"]
#[doc = " virtual function of the current device."]
#[doc = ""]
#[doc = " If supported, should work even if the virtual function is not managed by"]
#[doc = " the application and thus not associated with a DPDK port ID."]
#[doc = ""]
#[doc = " Note this pattern item does not match VF representors traffic which, as"]
#[doc = " separate entities, should be addressed through their own DPDK port IDs."]
#[doc = ""]
#[doc = " - Can be specified multiple times to match traffic addressed to several"]
#[doc = "   VF IDs."]
#[doc = " - Can be combined with a PF item to match both PF and VF traffic."]
#[doc = ""]
#[doc = " A zeroed mask can be used to match any VF ID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vf {
    #[doc = "< VF ID."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vf() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_vf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vf>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_flow_item_vf), "::", stringify!(id))
    );
}
extern "C" {
    pub static rte_flow_item_vf_mask: rte_flow_item_vf;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PHY_PORT"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a"]
#[doc = " physical port of the underlying device."]
#[doc = ""]
#[doc = " The first PHY_PORT item overrides the physical port normally associated"]
#[doc = " with the specified DPDK input port (port_id). This item can be provided"]
#[doc = " several times to match additional physical ports."]
#[doc = ""]
#[doc = " Note that physical ports are not necessarily tied to DPDK input ports"]
#[doc = " (port_id) when those are not under DPDK control. Possible values are"]
#[doc = " specific to each device, they are not necessarily indexed from zero and"]
#[doc = " may not be contiguous."]
#[doc = ""]
#[doc = " As a device property, the list of allowed values as well as the value"]
#[doc = " associated with a port_id should be retrieved by other means."]
#[doc = ""]
#[doc = " A zeroed mask can be used to match any port index."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_phy_port {
    #[doc = "< Physical port index."]
    pub index: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_phy_port() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_phy_port>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_phy_port))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_phy_port>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_phy_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_phy_port>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_phy_port),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub static rte_flow_item_phy_port_mask: rte_flow_item_phy_port;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[doc = ""]
#[doc = " Matches traffic originating from (ingress) or going to (egress) a given"]
#[doc = " DPDK port ID."]
#[doc = ""]
#[doc = " Normally only supported if the port ID in question is known by the"]
#[doc = " underlying PMD and related to the device the flow rule is created"]
#[doc = " against."]
#[doc = ""]
#[doc = " This must not be confused with @p PHY_PORT which refers to the physical"]
#[doc = " port of a device, whereas @p PORT_ID refers to a struct rte_eth_dev"]
#[doc = " object on the application side (also known as \"port representor\""]
#[doc = " depending on the kind of underlying device)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_port_id {
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_port_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_port_id>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_port_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_port_id),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_port_id_mask: rte_flow_item_port_id;
}
#[doc = " RTE_FLOW_ITEM_TYPE_RAW"]
#[doc = ""]
#[doc = " Matches a byte string of a given length at a given offset."]
#[doc = ""]
#[doc = " Offset is either absolute (using the start of the packet) or relative to"]
#[doc = " the end of the previous matched item in the stack, in which case negative"]
#[doc = " values are allowed."]
#[doc = ""]
#[doc = " If search is enabled, offset is used as the starting point. The search"]
#[doc = " area can be delimited by setting limit to a nonzero value, which is the"]
#[doc = " maximum number of bytes after offset where the pattern may start."]
#[doc = ""]
#[doc = " Matching a zero-length pattern is allowed, doing so resets the relative"]
#[doc = " offset for subsequent items."]
#[doc = ""]
#[doc = " This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_item_raw {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Absolute or relative offset for pattern."]
    pub offset: i32,
    #[doc = "< Search area limit for start of pattern."]
    pub limit: u16,
    #[doc = "< Pattern length."]
    pub length: u16,
    #[doc = "< Byte string to look for."]
    pub pattern: *const u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_raw() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_raw>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_raw>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_item_raw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).length as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_raw>())).pattern as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_raw),
            "::",
            stringify!(pattern)
        )
    );
}
impl Default for rte_flow_item_raw {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(relative: u32, search: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relative: u32 = unsafe { ::std::mem::transmute(relative) };
            relative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let search: u32 = unsafe { ::std::mem::transmute(search) };
            search as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ETH"]
#[doc = ""]
#[doc = " Matches an Ethernet header."]
#[doc = ""]
#[doc = " The @p type field either stands for \"EtherType\" or \"TPID\" when followed"]
#[doc = " by so-called layer 2.5 pattern items such as RTE_FLOW_ITEM_TYPE_VLAN. In"]
#[doc = " the latter case, @p type refers to that of the outer header, with the"]
#[doc = " inner EtherType/TPID provided by the subsequent pattern item. This is the"]
#[doc = " same order as on the wire."]
#[doc = " If the @p type field contains a TPID value, then only tagged packets with the"]
#[doc = " specified TPID will match the pattern."]
#[doc = " The field @p has_vlan can be used to match any type of tagged packets,"]
#[doc = " instead of using the @p type field."]
#[doc = " If the @p type and @p has_vlan fields are not specified, then both tagged"]
#[doc = " and untagged packets will match the pattern."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_eth {
    #[doc = "< Destination MAC."]
    pub dst: rte_ether_addr,
    #[doc = "< Source MAC."]
    pub src: rte_ether_addr,
    #[doc = "< EtherType or TPID."]
    pub type_: rte_be16_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_eth>(),
        20usize,
        concat!("Size of: ", stringify!(rte_flow_item_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_eth>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).src as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_eth>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_eth),
            "::",
            stringify!(type_)
        )
    );
}
impl rte_flow_item_eth {
    #[inline]
    pub fn has_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vlan: u32 = unsafe { ::std::mem::transmute(has_vlan) };
            has_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VLAN"]
#[doc = ""]
#[doc = " Matches an 802.1Q/ad VLAN tag."]
#[doc = ""]
#[doc = " The corresponding standard outer EtherType (TPID) values are"]
#[doc = " RTE_ETHER_TYPE_VLAN or RTE_ETHER_TYPE_QINQ. It can be overridden by"]
#[doc = " the preceding pattern item."]
#[doc = " If a @p VLAN item is present in the pattern, then only tagged packets will"]
#[doc = " match the pattern."]
#[doc = " The field @p has_more_vlan can be used to match any type of tagged packets,"]
#[doc = " instead of using the @p inner_type field."]
#[doc = " If the @p inner_type and @p has_more_vlan fields are not specified,"]
#[doc = " then any tagged packets will match the pattern."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vlan {
    #[doc = "< Tag control information."]
    pub tci: rte_be16_t,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vlan>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_vlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vlan>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vlan>())).tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vlan),
            "::",
            stringify!(tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vlan>())).inner_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vlan),
            "::",
            stringify!(inner_type)
        )
    );
}
impl rte_flow_item_vlan {
    #[inline]
    pub fn has_more_vlan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_more_vlan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_more_vlan: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_more_vlan: u32 = unsafe { ::std::mem::transmute(has_more_vlan) };
            has_more_vlan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV4"]
#[doc = ""]
#[doc = " Matches an IPv4 header."]
#[doc = ""]
#[doc = " Note: IPv4 options are handled by dedicated pattern items."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv4 {
    #[doc = "< IPv4 header definition."]
    pub hdr: rte_ipv4_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv4>(),
        20usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv4>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv4>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv4),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6."]
#[doc = ""]
#[doc = " Matches an IPv6 header."]
#[doc = ""]
#[doc = " Dedicated flags indicate if header contains specific extension headers."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv6 {
    #[doc = "< IPv6 header definition."]
    pub hdr: rte_ipv6_hdr,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv6>(),
        44usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv6>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv6>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv6),
            "::",
            stringify!(hdr)
        )
    );
}
impl rte_flow_item_ipv6 {
    #[inline]
    pub fn has_hop_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_route_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_route_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_frag_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frag_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_auth_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_auth_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_esp_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_esp_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_dest_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_dest_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_mobil_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mobil_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hip_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hip_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_shim6_ext(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_shim6_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_ext: u32,
        has_route_ext: u32,
        has_frag_ext: u32,
        has_auth_ext: u32,
        has_esp_ext: u32,
        has_dest_ext: u32,
        has_mobil_ext: u32,
        has_hip_ext: u32,
        has_shim6_ext: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_ext: u32 = unsafe { ::std::mem::transmute(has_hop_ext) };
            has_hop_ext as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_route_ext: u32 = unsafe { ::std::mem::transmute(has_route_ext) };
            has_route_ext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_frag_ext: u32 = unsafe { ::std::mem::transmute(has_frag_ext) };
            has_frag_ext as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_auth_ext: u32 = unsafe { ::std::mem::transmute(has_auth_ext) };
            has_auth_ext as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_esp_ext: u32 = unsafe { ::std::mem::transmute(has_esp_ext) };
            has_esp_ext as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_dest_ext: u32 = unsafe { ::std::mem::transmute(has_dest_ext) };
            has_dest_ext as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_mobil_ext: u32 = unsafe { ::std::mem::transmute(has_mobil_ext) };
            has_mobil_ext as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_hip_ext: u32 = unsafe { ::std::mem::transmute(has_hip_ext) };
            has_hip_ext as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_shim6_ext: u32 = unsafe { ::std::mem::transmute(has_shim6_ext) };
            has_shim6_ext as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP."]
#[doc = ""]
#[doc = " Matches an ICMP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp {
    #[doc = "< ICMP header definition."]
    pub hdr: rte_icmp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_UDP."]
#[doc = ""]
#[doc = " Matches a UDP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_udp {
    #[doc = "< UDP header definition."]
    pub hdr: rte_udp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_udp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_udp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_udp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_udp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_udp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_udp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_udp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_TCP."]
#[doc = ""]
#[doc = " Matches a TCP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_tcp {
    #[doc = "< TCP header definition."]
    pub hdr: rte_tcp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_tcp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_tcp>(),
        20usize,
        concat!("Size of: ", stringify!(rte_flow_item_tcp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_tcp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_tcp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tcp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tcp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_SCTP."]
#[doc = ""]
#[doc = " Matches a SCTP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_sctp {
    #[doc = "< SCTP header definition."]
    pub hdr: rte_sctp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_sctp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_sctp>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_item_sctp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_sctp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_sctp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_sctp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_sctp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN."]
#[doc = ""]
#[doc = " Matches a VXLAN header (RFC 7348)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vxlan {
    #[doc = "< Normally 0x08 (I flag)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x000000."]
    pub rsvd0: [u8; 3usize],
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vxlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vxlan>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_vxlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vxlan>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vxlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).rsvd0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_E_TAG."]
#[doc = ""]
#[doc = " Matches a E-tag header."]
#[doc = ""]
#[doc = " The corresponding standard outer EtherType (TPID) value is"]
#[doc = " RTE_ETHER_TYPE_ETAG. It can be overridden by the preceding pattern item."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_e_tag {
    #[doc = " E-Tag control information (E-TCI)."]
    #[doc = " E-PCP (3b), E-DEI (1b), ingress E-CID base (12b)."]
    pub epcp_edei_in_ecid_b: rte_be16_t,
    #[doc = " Reserved (2b), GRP (2b), E-CID base (12b)."]
    pub rsvd_grp_ecid_b: rte_be16_t,
    #[doc = "< Ingress E-CID ext."]
    pub in_ecid_e: u8,
    #[doc = "< E-CID ext."]
    pub ecid_e: u8,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_e_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_e_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_e_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_e_tag>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_e_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).epcp_edei_in_ecid_b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(epcp_edei_in_ecid_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).rsvd_grp_ecid_b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(rsvd_grp_ecid_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).in_ecid_e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(in_ecid_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).ecid_e as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(ecid_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_e_tag>())).inner_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_e_tag),
            "::",
            stringify!(inner_type)
        )
    );
}
extern "C" {
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_NVGRE."]
#[doc = ""]
#[doc = " Matches a NVGRE header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_nvgre {
    #[doc = " Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),"]
    #[doc = " reserved 0 (9b), version (3b)."]
    #[doc = ""]
    #[doc = " c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637."]
    pub c_k_s_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type (0x6558)."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual subnet ID."]
    pub tni: [u8; 3usize],
    #[doc = "< Flow ID."]
    pub flow_id: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_nvgre() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_nvgre>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_nvgre))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_nvgre>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_nvgre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).c_k_s_rsvd0_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(c_k_s_rsvd0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).tni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(tni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_nvgre>())).flow_id as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_nvgre),
            "::",
            stringify!(flow_id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_MPLS."]
#[doc = ""]
#[doc = " Matches a MPLS header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_mpls {
    #[doc = " Label (20b), TC (3b), Bottom of Stack (1b)."]
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_mpls>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_mpls>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mpls>())).label_tc_s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mpls),
            "::",
            stringify!(label_tc_s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mpls>())).ttl as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mpls),
            "::",
            stringify!(ttl)
        )
    );
}
extern "C" {
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE."]
#[doc = ""]
#[doc = " Matches a GRE header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gre {
    #[doc = " Checksum (1b), reserved 0 (12b), version (3b)."]
    #[doc = " Refer to RFC 2784."]
    pub c_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gre() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gre>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_gre))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gre>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gre>())).c_rsvd0_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gre),
            "::",
            stringify!(c_rsvd0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gre>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gre),
            "::",
            stringify!(protocol)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_FUZZY"]
#[doc = ""]
#[doc = " Fuzzy pattern match, expect faster than default."]
#[doc = ""]
#[doc = " This is for device that support fuzzy match option."]
#[doc = " Usually a fuzzy match is fast but the cost is accuracy."]
#[doc = " i.e. Signature Match only match pattern's hash value, but it is"]
#[doc = " possible two different patterns have the same hash value."]
#[doc = ""]
#[doc = " Matching accuracy level can be configure by threshold."]
#[doc = " Driver can divide the range of threshold and map to different"]
#[doc = " accuracy levels that device support."]
#[doc = ""]
#[doc = " Threshold 0 means perfect match (no fuzziness), while threshold"]
#[doc = " 0xffffffff means fuzziest match."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_fuzzy {
    #[doc = "< Accuracy threshold."]
    pub thresh: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_fuzzy() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_fuzzy>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_fuzzy))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_fuzzy>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_fuzzy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_fuzzy>())).thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_fuzzy),
            "::",
            stringify!(thresh)
        )
    );
}
extern "C" {
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP."]
#[doc = ""]
#[doc = " Matches a GTPv1 header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gtp {
    #[doc = " Version (3b), protocol type (1b), reserved (1b),"]
    #[doc = " Extension header flag (1b),"]
    #[doc = " Sequence number flag (1b),"]
    #[doc = " N-PDU number flag (1b)."]
    pub v_pt_rsv_flags: u8,
    #[doc = "< Message type."]
    pub msg_type: u8,
    #[doc = "< Message length."]
    pub msg_len: rte_be16_t,
    #[doc = "< Tunnel endpoint identifier."]
    pub teid: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gtp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gtp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_gtp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gtp>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gtp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).v_pt_rsv_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(v_pt_rsv_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).msg_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).msg_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(msg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp>())).teid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp),
            "::",
            stringify!(teid)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gtp_mask: rte_flow_item_gtp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ESP"]
#[doc = ""]
#[doc = " Matches an ESP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_esp {
    #[doc = "< ESP header definition."]
    pub hdr: rte_esp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_esp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_esp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_esp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_esp>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_esp),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_esp_mask: rte_flow_item_esp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE."]
#[doc = ""]
#[doc = " Matches a GENEVE header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_geneve {
    #[doc = " Version (2b), length of the options fields (6b), OAM packet (1b),"]
    #[doc = " critical options present (1b), reserved 0 (6b)."]
    pub ver_opt_len_o_c_rsvd0: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual Network Identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_geneve() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_geneve>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_geneve))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_geneve>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_geneve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).ver_opt_len_o_c_rsvd0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(ver_opt_len_o_c_rsvd0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_geneve>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_geneve),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_geneve_mask: rte_flow_item_geneve;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN_GPE (draft-ietf-nvo3-vxlan-gpe-05)."]
#[doc = ""]
#[doc = " Matches a VXLAN-GPE header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_vxlan_gpe {
    #[doc = "< Normally 0x0c (I and P flags)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x0000."]
    pub rsvd0: [u8; 2usize],
    #[doc = "< Protocol type."]
    pub protocol: u8,
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vxlan_gpe() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_vxlan_gpe>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_vxlan_gpe))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_vxlan_gpe>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_vxlan_gpe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).rsvd0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(rsvd0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).protocol as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(vni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_vxlan_gpe>())).rsvd1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_vxlan_gpe),
            "::",
            stringify!(rsvd1)
        )
    );
}
extern "C" {
    pub static rte_flow_item_vxlan_gpe_mask: rte_flow_item_vxlan_gpe;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4"]
#[doc = ""]
#[doc = " Matches an ARP header for Ethernet/IPv4."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_arp_eth_ipv4 {
    #[doc = "< Hardware type, normally 1."]
    pub hrd: rte_be16_t,
    #[doc = "< Protocol type, normally 0x0800."]
    pub pro: rte_be16_t,
    #[doc = "< Hardware address length, normally 6."]
    pub hln: u8,
    #[doc = "< Protocol address length, normally 4."]
    pub pln: u8,
    #[doc = "< Opcode (1 for request, 2 for reply)."]
    pub op: rte_be16_t,
    #[doc = "< Sender hardware address."]
    pub sha: rte_ether_addr,
    #[doc = "< Sender IPv4 address."]
    pub spa: rte_be32_t,
    #[doc = "< Target hardware address."]
    pub tha: rte_ether_addr,
    #[doc = "< Target IPv4 address."]
    pub tpa: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_arp_eth_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_arp_eth_ipv4>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_item_arp_eth_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_arp_eth_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_arp_eth_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).hrd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(hrd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).pro as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(pro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).hln as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(hln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).pln as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(pln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).op as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).sha as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(sha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).spa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(spa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).tha as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(tha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_arp_eth_ipv4>())).tpa as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_arp_eth_ipv4),
            "::",
            stringify!(tpa)
        )
    );
}
extern "C" {
    pub static rte_flow_item_arp_eth_ipv4_mask: rte_flow_item_arp_eth_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[doc = ""]
#[doc = " Matches the presence of any IPv6 extension header."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6"]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv6_ext {
    #[doc = "< Next header."]
    pub next_hdr: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv6_ext>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv6_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv6_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv6_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv6_ext>())).next_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv6_ext),
            "::",
            stringify!(next_hdr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_ipv6_ext_mask: rte_flow_item_ipv6_ext;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_FRAG_EXT"]
#[doc = ""]
#[doc = " Matches the presence of IPv6 fragment extension header."]
#[doc = ""]
#[doc = " Preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6"]
#[doc = " - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ipv6_frag_ext {
    pub hdr: rte_ipv6_fragment_ext,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6_frag_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ipv6_frag_ext>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_ipv6_frag_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ipv6_frag_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ipv6_frag_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ipv6_frag_ext>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ipv6_frag_ext),
            "::",
            stringify!(hdr)
        )
    );
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6"]
#[doc = ""]
#[doc = " Matches any ICMPv6 header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6 {
    #[doc = "< ICMPv6 type."]
    pub type_: u8,
    #[doc = "< ICMPv6 code."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6),
            "::",
            stringify!(checksum)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_mask: rte_flow_item_icmp6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery solicitation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_ns {
    #[doc = "< ICMPv6 type, normally 135."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = "< Reserved, normally 0."]
    pub reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_ns() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_ns>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_ns))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_ns>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_ns))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_ns>())).target_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_ns),
            "::",
            stringify!(target_addr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_ns_mask: rte_flow_item_icmp6_nd_ns;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery advertisement."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_na {
    #[doc = "< ICMPv6 type, normally 136."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = " Route flag (1b), solicited flag (1b), override flag (1b),"]
    #[doc = " reserved (29b)."]
    pub rso_reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_na() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_na>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_na))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_na>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_na))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).rso_reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(rso_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_na>())).target_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_na),
            "::",
            stringify!(target_addr)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_na_mask: rte_flow_item_icmp6_nd_na;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[doc = ""]
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt {
    #[doc = "< ND option type."]
    pub type_: u8,
    #[doc = "< ND option length."]
    pub length: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt>())).length as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_mask: rte_flow_item_icmp6_nd_opt;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer address"]
#[doc = " option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt_sla_eth {
    #[doc = "< ND option type, normally 1."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Source Ethernet LLA."]
    pub sla: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt_sla_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_sla_eth>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt_sla_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_sla_eth>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_opt_sla_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).length as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_sla_eth>())).sla as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_sla_eth),
            "::",
            stringify!(sla)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_sla_eth_mask: rte_flow_item_icmp6_nd_opt_sla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH"]
#[doc = ""]
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer address"]
#[doc = " option."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS"]
#[doc = " - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_icmp6_nd_opt_tla_eth {
    #[doc = "< ND option type, normally 2."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Target Ethernet LLA."]
    pub tla: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp6_nd_opt_tla_eth() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_tla_eth>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_icmp6_nd_opt_tla_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_tla_eth>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_icmp6_nd_opt_tla_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).length as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_icmp6_nd_opt_tla_eth>())).tla as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_icmp6_nd_opt_tla_eth),
            "::",
            stringify!(tla)
        )
    );
}
extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_tla_eth_mask: rte_flow_item_icmp6_nd_opt_tla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_META"]
#[doc = ""]
#[doc = " Matches a specified metadata value. On egress, metadata can be set"]
#[doc = " either by mbuf dynamic metadata field with PKT_TX_DYNF_METADATA flag or"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_META. On ingress, RTE_FLOW_ACTION_TYPE_SET_META"]
#[doc = " sets metadata for a packet and the metadata will be reported via mbuf"]
#[doc = " metadata dynamic field with PKT_RX_DYNF_METADATA flag. The dynamic mbuf"]
#[doc = " field must be registered in advance by rte_flow_dynf_metadata_register()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_meta {
    pub data: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_meta() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_meta>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_meta>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_meta>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_meta),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub static rte_flow_item_meta_mask: rte_flow_item_meta;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP_PSC."]
#[doc = ""]
#[doc = " Matches a GTP PDU extension header with type 0x85."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_gtp_psc {
    #[doc = "< PDU type."]
    pub pdu_type: u8,
    #[doc = "< QoS flow identifier."]
    pub qfi: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gtp_psc() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_gtp_psc>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_gtp_psc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_gtp_psc>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_item_gtp_psc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp_psc>())).pdu_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp_psc),
            "::",
            stringify!(pdu_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_gtp_psc>())).qfi as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_gtp_psc),
            "::",
            stringify!(qfi)
        )
    );
}
extern "C" {
    pub static rte_flow_item_gtp_psc_mask: rte_flow_item_gtp_psc;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE."]
#[doc = ""]
#[doc = " Matches a PPPoE header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_pppoe {
    #[doc = " Version (4b), type (4b)."]
    pub version_type: u8,
    #[doc = "< Message type."]
    pub code: u8,
    #[doc = "< Session identifier."]
    pub session_id: rte_be16_t,
    #[doc = "< Payload length."]
    pub length: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_pppoe() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_pppoe>(),
        6usize,
        concat!("Size of: ", stringify!(rte_flow_item_pppoe))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_pppoe>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_pppoe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).version_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(version_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).session_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID."]
#[doc = ""]
#[doc = " Matches a PPPoE optional proto_id field."]
#[doc = ""]
#[doc = " It only applies to PPPoE session packets."]
#[doc = ""]
#[doc = " Normally preceded by any of:"]
#[doc = ""]
#[doc = " - RTE_FLOW_ITEM_TYPE_PPPOE"]
#[doc = " - RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_pppoe_proto_id {
    #[doc = "< PPP protocol identifier."]
    pub proto_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_pppoe_proto_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_pppoe_proto_id>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_item_pppoe_proto_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_pppoe_proto_id>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_item_pppoe_proto_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pppoe_proto_id>())).proto_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pppoe_proto_id),
            "::",
            stringify!(proto_id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_pppoe_proto_id_mask: rte_flow_item_pppoe_proto_id;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_TAG"]
#[doc = ""]
#[doc = " Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tag>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tag),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_tag>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_tag),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub static rte_flow_item_tag_mask: rte_flow_item_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_L2TPV3OIP."]
#[doc = ""]
#[doc = " Matches a L2TPv3 over IP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_l2tpv3oip {
    #[doc = "< Session ID."]
    pub session_id: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_l2tpv3oip() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_l2tpv3oip>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_l2tpv3oip))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_l2tpv3oip>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_l2tpv3oip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_l2tpv3oip>())).session_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_l2tpv3oip),
            "::",
            stringify!(session_id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_l2tpv3oip_mask: rte_flow_item_l2tpv3oip;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_MARK"]
#[doc = ""]
#[doc = " Matches an arbitrary integer value which was set using the ``MARK`` action"]
#[doc = " in a previously matched rule."]
#[doc = ""]
#[doc = " This item can only be specified once as a match criteria as the ``MARK``"]
#[doc = " action can only be specified once in a flow action."]
#[doc = ""]
#[doc = " This value is arbitrary and application-defined. Maximum allowed value"]
#[doc = " depends on the underlying implementation."]
#[doc = ""]
#[doc = " Depending on the underlying implementation the MARK item may be supported on"]
#[doc = " the physical device, with virtual groups in the PMD or not at all."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_mark {
    #[doc = "< Integer value to match against."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_mark() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_mark>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_item_mark))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_mark>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_mark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_mark>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_mark),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    pub static rte_flow_item_mark_mask: rte_flow_item_mark;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_NSH"]
#[doc = ""]
#[doc = " Match network service header (NSH), RFC 8300"]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_nsh {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_nsh() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_nsh>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_nsh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_nsh>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_nsh))
    );
}
impl rte_flow_item_nsh {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn oam_pkt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oam_pkt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ttl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mdtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mdtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn next_proto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_proto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn spi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_spi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn sindex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sindex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        oam_pkt: u32,
        reserved: u32,
        ttl: u32,
        length: u32,
        reserved1: u32,
        mdtype: u32,
        next_proto: u32,
        spi: u32,
        sindex: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let oam_pkt: u32 = unsafe { ::std::mem::transmute(oam_pkt) };
            oam_pkt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let mdtype: u32 = unsafe { ::std::mem::transmute(mdtype) };
            mdtype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let next_proto: u32 = unsafe { ::std::mem::transmute(next_proto) };
            next_proto as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let spi: u32 = unsafe { ::std::mem::transmute(spi) };
            spi as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let sindex: u32 = unsafe { ::std::mem::transmute(sindex) };
            sindex as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_nsh_mask: rte_flow_item_nsh;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_IGMP"]
#[doc = ""]
#[doc = " Match Internet Group Management Protocol (IGMP), RFC 2236"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_igmp {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub group_addr: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_igmp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_igmp>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_item_igmp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_igmp>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_igmp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_igmp>())).group_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_igmp),
            "::",
            stringify!(group_addr)
        )
    );
}
impl rte_flow_item_igmp {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_resp_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_resp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn checksum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_checksum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: u32, max_resp_time: u32, checksum: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let max_resp_time: u32 = unsafe { ::std::mem::transmute(max_resp_time) };
            max_resp_time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let checksum: u32 = unsafe { ::std::mem::transmute(checksum) };
            checksum as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_igmp_mask: rte_flow_item_igmp;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_AH"]
#[doc = ""]
#[doc = " Match IP Authentication Header (AH), RFC 4302"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_ah {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub spi: u32,
    pub seq_num: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ah() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ah>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_item_ah))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ah>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ah))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ah>())).spi as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_flow_item_ah), "::", stringify!(spi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ah>())).seq_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ah),
            "::",
            stringify!(seq_num)
        )
    );
}
impl rte_flow_item_ah {
    #[inline]
    pub fn next_hdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_hdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn payload_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_payload_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(next_hdr: u32, payload_len: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let next_hdr: u32 = unsafe { ::std::mem::transmute(next_hdr) };
            next_hdr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let payload_len: u32 = unsafe { ::std::mem::transmute(payload_len) };
            payload_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static rte_flow_item_ah_mask: rte_flow_item_ah;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_PFCP"]
#[doc = ""]
#[doc = " Match PFCP Header"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_item_pfcp {
    pub s_field: u8,
    pub msg_type: u8,
    pub msg_len: rte_be16_t,
    pub seid: rte_be64_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_pfcp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_pfcp>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_item_pfcp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_pfcp>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_item_pfcp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pfcp>())).s_field as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pfcp),
            "::",
            stringify!(s_field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pfcp>())).msg_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pfcp),
            "::",
            stringify!(msg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pfcp>())).msg_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pfcp),
            "::",
            stringify!(msg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_pfcp>())).seid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_pfcp),
            "::",
            stringify!(seid)
        )
    );
}
extern "C" {
    pub static rte_flow_item_pfcp_mask: rte_flow_item_pfcp;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_ECPRI"]
#[doc = ""]
#[doc = " Match eCPRI Header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_ecpri {
    pub hdr: rte_ecpri_combined_msg_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ecpri() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item_ecpri>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_item_ecpri))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item_ecpri>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_item_ecpri))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item_ecpri>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_item_ecpri),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for rte_flow_item_ecpri {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static rte_flow_item_ecpri_mask: rte_flow_item_ecpri;
}
#[doc = " Matching pattern item definition."]
#[doc = ""]
#[doc = " A pattern is formed by stacking items starting from the lowest protocol"]
#[doc = " layer to match. This stacking restriction does not apply to meta items"]
#[doc = " which can be placed anywhere in the stack without affecting the meaning"]
#[doc = " of the resulting pattern."]
#[doc = ""]
#[doc = " Patterns are terminated by END items."]
#[doc = ""]
#[doc = " The spec field should be a valid pointer to a structure of the related"]
#[doc = " item type. It may remain unspecified (NULL) in many cases to request"]
#[doc = " broad (nonspecific) matching. In such cases, last and mask must also be"]
#[doc = " set to NULL."]
#[doc = ""]
#[doc = " Optionally, last can point to a structure of the same type to define an"]
#[doc = " inclusive range. This is mostly supported by integer and address fields,"]
#[doc = " may cause errors otherwise. Fields that do not support ranges must be set"]
#[doc = " to 0 or to the same value as the corresponding fields in spec."]
#[doc = ""]
#[doc = " Only the fields defined to nonzero values in the default masks (see"]
#[doc = " rte_flow_item_{name}_mask constants) are considered relevant by"]
#[doc = " default. This can be overridden by providing a mask structure of the"]
#[doc = " same type with applicable bits set to one. It can also be used to"]
#[doc = " partially filter out specific fields (e.g. as an alternate mean to match"]
#[doc = " ranges of IP addresses)."]
#[doc = ""]
#[doc = " Mask is a simple bit-mask applied before interpreting the contents of"]
#[doc = " spec and last, which may yield unexpected results if not used"]
#[doc = " carefully. For example, if for an IPv4 address field, spec provides"]
#[doc = " 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the"]
#[doc = " effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type::Type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_item() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_item>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_item))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_item>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_item))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_flow_item), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).spec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_flow_item), "::", stringify!(spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).last as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_flow_item), "::", stringify!(last))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_item>())).mask as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_flow_item), "::", stringify!(mask))
    );
}
impl Default for rte_flow_item {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_flow_action_type {
    #[doc = " Action types."]
    #[doc = ""]
    #[doc = " Each possible action is represented by a type."]
    #[doc = " An action can have an associated configuration object."]
    #[doc = " Several actions combined in a list can be assigned"]
    #[doc = " to a flow rule and are performed in order."]
    #[doc = ""]
    #[doc = " They fall in three categories:"]
    #[doc = ""]
    #[doc = " - Actions that modify the fate of matching traffic, for instance by"]
    #[doc = "   dropping or assigning it a specific destination."]
    #[doc = ""]
    #[doc = " - Actions that modify matching traffic contents or its properties. This"]
    #[doc = "   includes adding/removing encapsulation, encryption, compression and"]
    #[doc = "   marks."]
    #[doc = ""]
    #[doc = " - Actions related to the flow rule itself, such as updating counters or"]
    #[doc = "   making it non-terminating."]
    #[doc = ""]
    #[doc = " Flow rules being terminating by default, not specifying any action of the"]
    #[doc = " fate kind results in undefined behavior. This applies to both ingress and"]
    #[doc = " egress."]
    #[doc = ""]
    #[doc = " PASSTHRU, when supported, makes a flow rule non-terminating."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " End marker for action lists. Prevents further processing of"]
    #[doc = " actions, thereby ending the list."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_END: Type = 0;
    #[doc = " Used as a placeholder for convenience. It is ignored and simply"]
    #[doc = " discarded by PMDs."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_VOID: Type = 1;
    #[doc = " Leaves traffic up for additional processing by subsequent flow"]
    #[doc = " rules; makes a flow rule non-terminating."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_PASSTHRU: Type = 2;
    #[doc = " RTE_FLOW_ACTION_TYPE_JUMP"]
    #[doc = ""]
    #[doc = " Redirects packets to a group on the current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_jump."]
    pub const RTE_FLOW_ACTION_TYPE_JUMP: Type = 3;
    #[doc = " Attaches an integer value to packets and sets PKT_RX_FDIR and"]
    #[doc = " PKT_RX_FDIR_ID mbuf flags."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_mark."]
    pub const RTE_FLOW_ACTION_TYPE_MARK: Type = 4;
    #[doc = " Flags packets. Similar to MARK without a specific value; only"]
    #[doc = " sets the PKT_RX_FDIR mbuf flag."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_FLAG: Type = 5;
    #[doc = " Assigns packets to a given queue index."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_queue."]
    pub const RTE_FLOW_ACTION_TYPE_QUEUE: Type = 6;
    #[doc = " Drops packets."]
    #[doc = ""]
    #[doc = " PASSTHRU overrides this action if both are specified."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_DROP: Type = 7;
    #[doc = " Enables counters for this flow rule."]
    #[doc = ""]
    #[doc = " These counters can be retrieved and reset through rte_flow_query() or"]
    #[doc = " rte_flow_shared_action_query() if the action provided via handle,"]
    #[doc = " see struct rte_flow_query_count."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_count."]
    pub const RTE_FLOW_ACTION_TYPE_COUNT: Type = 8;
    #[doc = " Similar to QUEUE, except RSS is additionally performed on packets"]
    #[doc = " to spread them among several queues according to the provided"]
    #[doc = " parameters."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_rss."]
    pub const RTE_FLOW_ACTION_TYPE_RSS: Type = 9;
    #[doc = " Directs matching traffic to the physical function (PF) of the"]
    #[doc = " current device."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_PF: Type = 10;
    #[doc = " Directs matching traffic to a given virtual function of the"]
    #[doc = " current device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_vf."]
    pub const RTE_FLOW_ACTION_TYPE_VF: Type = 11;
    #[doc = " Directs packets to a given physical port index of the underlying"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_phy_port."]
    pub const RTE_FLOW_ACTION_TYPE_PHY_PORT: Type = 12;
    #[doc = " Directs matching traffic to a given DPDK port ID."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_port_id."]
    pub const RTE_FLOW_ACTION_TYPE_PORT_ID: Type = 13;
    #[doc = " Traffic metering and policing (MTR)."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_meter."]
    #[doc = " See file rte_mtr.h for MTR object configuration."]
    pub const RTE_FLOW_ACTION_TYPE_METER: Type = 14;
    #[doc = " Redirects packets to security engine of current device for security"]
    #[doc = " processing as specified by security session."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_security."]
    pub const RTE_FLOW_ACTION_TYPE_SECURITY: Type = 15;
    #[doc = " Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the"]
    #[doc = " OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_mpls_ttl."]
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL: Type = 16;
    #[doc = " Implements OFPAT_DEC_MPLS_TTL (\"decrement MPLS TTL\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL: Type = 17;
    #[doc = " Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_nw_ttl."]
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL: Type = 18;
    #[doc = " Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: Type = 19;
    #[doc = " Implements OFPAT_COPY_TTL_OUT (\"copy TTL \"outwards\" -- from"]
    #[doc = " next-to-outermost to outermost\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT: Type = 20;
    #[doc = " Implements OFPAT_COPY_TTL_IN (\"copy TTL \"inwards\" -- from"]
    #[doc = " outermost to next-to-outermost\") as defined by the OpenFlow"]
    #[doc = " Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN: Type = 21;
    #[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: Type = 22;
    #[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_push_vlan."]
    pub const RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: Type = 23;
    #[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN id\") as"]
    #[doc = " defined by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_vlan_vid."]
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: Type = 24;
    #[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as"]
    #[doc = " defined by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_set_vlan_pcp."]
    pub const RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: Type = 25;
    #[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined"]
    #[doc = " by the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_pop_mpls."]
    pub const RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: Type = 26;
    #[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by"]
    #[doc = " the OpenFlow Switch Specification."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_of_push_mpls."]
    pub const RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: Type = 27;
    #[doc = " Encapsulate flow in VXLAN tunnel as defined in"]
    #[doc = " rte_flow_action_vxlan_encap action structure."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_vxlan_encap."]
    pub const RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: Type = 28;
    #[doc = " Decapsulate outer most VXLAN tunnel from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid VXLAN tunnel (as specified by"]
    #[doc = " RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION"]
    #[doc = " error."]
    pub const RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: Type = 29;
    #[doc = " Encapsulate flow in NVGRE tunnel defined in the"]
    #[doc = " rte_flow_action_nvgre_encap action structure."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_nvgre_encap."]
    pub const RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: Type = 30;
    #[doc = " Decapsulate outer most NVGRE tunnel from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid NVGRE tunnel (as specified by"]
    #[doc = " RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION"]
    #[doc = " error."]
    pub const RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: Type = 31;
    #[doc = " Add outer header whose template is provided in its data buffer"]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_raw_encap."]
    pub const RTE_FLOW_ACTION_TYPE_RAW_ENCAP: Type = 32;
    #[doc = " Remove outer header whose template is provided in its data buffer."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_raw_decap"]
    pub const RTE_FLOW_ACTION_TYPE_RAW_DECAP: Type = 33;
    #[doc = " Modify IPv4 source address in the outermost IPv4 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv4."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: Type = 34;
    #[doc = " Modify IPv4 destination address in the outermost IPv4 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv4."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: Type = 35;
    #[doc = " Modify IPv6 source address in the outermost IPv6 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv6."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: Type = 36;
    #[doc = " Modify IPv6 destination address in the outermost IPv6 header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ipv6."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: Type = 37;
    #[doc = " Modify source port number in the outermost TCP/UDP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP"]
    #[doc = " or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a"]
    #[doc = " RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tp."]
    pub const RTE_FLOW_ACTION_TYPE_SET_TP_SRC: Type = 38;
    #[doc = " Modify destination port number in the outermost TCP/UDP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP"]
    #[doc = " or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a"]
    #[doc = " RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tp."]
    pub const RTE_FLOW_ACTION_TYPE_SET_TP_DST: Type = 39;
    #[doc = " Swap the source and destination MAC addresses in the outermost"]
    #[doc = " Ethernet header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_MAC_SWAP: Type = 40;
    #[doc = " Decrease TTL value directly"]
    #[doc = ""]
    #[doc = " No associated configuration structure."]
    pub const RTE_FLOW_ACTION_TYPE_DEC_TTL: Type = 41;
    #[doc = " Set TTL value"]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_ttl"]
    pub const RTE_FLOW_ACTION_TYPE_SET_TTL: Type = 42;
    #[doc = " Set source MAC address from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_mac."]
    pub const RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: Type = 43;
    #[doc = " Set destination MAC address from matched flow."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,"]
    #[doc = " the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_mac."]
    pub const RTE_FLOW_ACTION_TYPE_SET_MAC_DST: Type = 44;
    #[doc = " Increase sequence number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to increase"]
    #[doc = " TCP sequence number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    pub const RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: Type = 45;
    #[doc = " Decrease sequence number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to decrease"]
    #[doc = " TCP sequence number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    pub const RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: Type = 46;
    #[doc = " Increase acknowledgment number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to increase"]
    #[doc = " TCP acknowledgment number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    pub const RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: Type = 47;
    #[doc = " Decrease acknowledgment number in the outermost TCP header."]
    #[doc = ""]
    #[doc = " Action configuration specifies the value to decrease"]
    #[doc = " TCP acknowledgment number as a big-endian 32 bit integer."]
    #[doc = ""]
    #[doc = " @p conf type:"]
    #[doc = " @code rte_be32_t * @endcode"]
    #[doc = ""]
    #[doc = " Using this action on non-matching traffic will result in"]
    #[doc = " undefined behavior."]
    pub const RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: Type = 48;
    #[doc = " Set Tag."]
    #[doc = ""]
    #[doc = " Tag is for internal flow usage only and"]
    #[doc = " is not delivered to the application."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_tag."]
    pub const RTE_FLOW_ACTION_TYPE_SET_TAG: Type = 49;
    #[doc = " Set metadata on ingress or egress path."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_meta."]
    pub const RTE_FLOW_ACTION_TYPE_SET_META: Type = 50;
    #[doc = " Modify IPv4 DSCP in the outermost IP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_dscp."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP: Type = 51;
    #[doc = " Modify IPv6 DSCP in the outermost IP header."]
    #[doc = ""]
    #[doc = " If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,"]
    #[doc = " then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_set_dscp."]
    pub const RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP: Type = 52;
    #[doc = " Report as aged flow if timeout passed without any matching on the"]
    #[doc = " flow."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_age."]
    #[doc = " See function rte_flow_get_aged_flows"]
    #[doc = " see enum RTE_ETH_EVENT_FLOW_AGED"]
    #[doc = " See struct rte_flow_query_age"]
    pub const RTE_FLOW_ACTION_TYPE_AGE: Type = 53;
    #[doc = " The matching packets will be duplicated with specified ratio and"]
    #[doc = " applied with own set of actions with a fate action."]
    #[doc = ""]
    #[doc = " See struct rte_flow_action_sample."]
    pub const RTE_FLOW_ACTION_TYPE_SAMPLE: Type = 54;
    #[doc = " Describe action shared across multiple flow rules."]
    #[doc = ""]
    #[doc = " Allow multiple rules reference the same action by handle (see"]
    #[doc = " struct rte_flow_shared_action)."]
    pub const RTE_FLOW_ACTION_TYPE_SHARED: Type = 55;
}
#[doc = " RTE_FLOW_ACTION_TYPE_MARK"]
#[doc = ""]
#[doc = " Attaches an integer value to packets and sets PKT_RX_FDIR and"]
#[doc = " PKT_RX_FDIR_ID mbuf flags."]
#[doc = ""]
#[doc = " This value is arbitrary and application-defined. Maximum allowed value"]
#[doc = " depends on the underlying implementation. It is returned in the"]
#[doc = " hash.fdir.hi mbuf field."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_mark {
    #[doc = "< Integer value to return with packets."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_mark() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_mark>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_mark))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_mark>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_mark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_mark>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_mark),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP"]
#[doc = ""]
#[doc = " Redirects packets to a group on the current device."]
#[doc = ""]
#[doc = " In a hierarchy of groups, which can be used to represent physical or logical"]
#[doc = " flow tables on the device, this action allows the action to be a redirect to"]
#[doc = " a group on that device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_jump {
    pub group: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_jump() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_jump>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_jump))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_jump>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_jump))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_jump>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_jump),
            "::",
            stringify!(group)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_QUEUE"]
#[doc = ""]
#[doc = " Assign packets to a given queue index."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_queue {
    #[doc = "< Queue index to use."]
    pub index: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_queue() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_queue>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_queue>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_queue>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_queue),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_AGE"]
#[doc = ""]
#[doc = " Report flow as aged-out if timeout passed without any matching"]
#[doc = " on the flow. RTE_ETH_EVENT_FLOW_AGED event is triggered when a"]
#[doc = " port detects new aged-out flows."]
#[doc = ""]
#[doc = " The flow context and the flow handle will be reported by the"]
#[doc = " rte_flow_get_aged_flows API."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_age {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action_age() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_age>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_age))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_age>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_age))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_age>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_age),
            "::",
            stringify!(context)
        )
    );
}
impl Default for rte_flow_action_age {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_flow_action_age {
    #[inline]
    pub fn timeout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(timeout: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let timeout: u32 = unsafe { ::std::mem::transmute(timeout) };
            timeout as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_AGE (query)"]
#[doc = ""]
#[doc = " Query structure to retrieve the aging status information of a"]
#[doc = " shared AGE action, or a flow rule using the AGE action."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_query_age {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_rte_flow_query_age() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_query_age>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_query_age))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_query_age>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_query_age))
    );
}
impl rte_flow_query_age {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn aged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sec_since_last_hit_valid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sec_since_last_hit(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_sec_since_last_hit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        aged: u32,
        sec_since_last_hit_valid: u32,
        sec_since_last_hit: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let aged: u32 = unsafe { ::std::mem::transmute(aged) };
            aged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sec_since_last_hit_valid: u32 = unsafe { ::std::mem::transmute(sec_since_last_hit_valid) };
            sec_since_last_hit_valid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let sec_since_last_hit: u32 = unsafe { ::std::mem::transmute(sec_since_last_hit) };
            sec_since_last_hit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT"]
#[doc = ""]
#[doc = " Adds a counter action to a matched flow."]
#[doc = ""]
#[doc = " If more than one count action is specified in a single flow rule, then each"]
#[doc = " action must specify a unique id."]
#[doc = ""]
#[doc = " Counters can be retrieved and reset through ``rte_flow_query()``, see"]
#[doc = " ``struct rte_flow_query_count``."]
#[doc = ""]
#[doc = " @deprecated Shared attribute is deprecated, use generic"]
#[doc = " RTE_FLOW_ACTION_TYPE_SHARED action."]
#[doc = ""]
#[doc = " The shared flag indicates whether the counter is unique to the flow rule the"]
#[doc = " action is specified with, or whether it is a shared counter."]
#[doc = ""]
#[doc = " For a count action with the shared flag set, then then a global device"]
#[doc = " namespace is assumed for the counter id, so that any matched flow rules using"]
#[doc = " a count action with the same counter id on the same port will contribute to"]
#[doc = " that counter."]
#[doc = ""]
#[doc = " For ports within the same switch domain then the counter id namespace extends"]
#[doc = " to all ports within that switch domain."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_count {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Counter ID."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_count() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_count>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_count))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_count>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_count>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_count),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_count {
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(shared: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT (query)"]
#[doc = ""]
#[doc = " Query structure to retrieve and reset flow rule counters."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_query_count {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Number of hits for this rule [out]."]
    pub hits: u64,
    #[doc = "< Number of bytes through this rule [out]."]
    pub bytes: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_query_count() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_query_count>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_query_count))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_query_count>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_query_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_query_count>())).hits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_query_count),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_query_count>())).bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_query_count),
            "::",
            stringify!(bytes)
        )
    );
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod rte_eth_hash_function {
    #[doc = " Hash function types."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_HASH_FUNCTION_DEFAULT: Type = 0;
    #[doc = "< Toeplitz"]
    pub const RTE_ETH_HASH_FUNCTION_TOEPLITZ: Type = 1;
    #[doc = "< Simple XOR"]
    pub const RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: Type = 2;
    #[doc = " Symmetric Toeplitz: src, dst will be replaced by"]
    #[doc = " xor(src, dst). For the case with src/dst only,"]
    #[doc = " src or dst address will xor with zero pair."]
    pub const RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: Type = 3;
    #[doc = " Symmetric Toeplitz: src, dst will be replaced by"]
    #[doc = " xor(src, dst). For the case with src/dst only,"]
    #[doc = " src or dst address will xor with zero pair."]
    pub const RTE_ETH_HASH_FUNCTION_MAX: Type = 4;
}
#[doc = " RTE_FLOW_ACTION_TYPE_RSS"]
#[doc = ""]
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets to"]
#[doc = " spread them among several queues according to the provided parameters."]
#[doc = ""]
#[doc = " Unlike global RSS settings used by other DPDK APIs, unsetting the"]
#[doc = " @p types field does not disable RSS in a flow rule. Doing so instead"]
#[doc = " requests safe unspecified \"best-effort\" settings from the underlying PMD,"]
#[doc = " which depending on the flow rule, may result in anything ranging from"]
#[doc = " empty (single queue) to all-inclusive RSS."]
#[doc = ""]
#[doc = " Note: RSS hash result is stored in the hash.rss mbuf field which overlaps"]
#[doc = " hash.fdir.lo. Since the MARK action sets the hash.fdir.hi field only,"]
#[doc = " both can be requested simultaneously."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_rss {
    #[doc = "< RSS hash function to apply."]
    pub func: rte_eth_hash_function::Type,
    #[doc = " Packet encapsulation level RSS hash @p types apply to."]
    #[doc = ""]
    #[doc = " - @p 0 requests the default behavior. Depending on the packet"]
    #[doc = "   type, it can mean outermost, innermost, anything in between or"]
    #[doc = "   even no RSS."]
    #[doc = ""]
    #[doc = "   It basically stands for the innermost encapsulation level RSS"]
    #[doc = "   can be performed on according to PMD and device capabilities."]
    #[doc = ""]
    #[doc = " - @p 1 requests RSS to be performed on the outermost packet"]
    #[doc = "   encapsulation level."]
    #[doc = ""]
    #[doc = " - @p 2 and subsequent values request RSS to be performed on the"]
    #[doc = "   specified inner packet encapsulation level, from outermost to"]
    #[doc = "   innermost (lower to higher values)."]
    #[doc = ""]
    #[doc = " Values other than @p 0 are not necessarily supported."]
    #[doc = ""]
    #[doc = " Requesting a specific RSS level on unrecognized traffic results"]
    #[doc = " in undefined behavior. For predictable results, it is recommended"]
    #[doc = " to make the flow rule pattern match packet headers up to the"]
    #[doc = " requested encapsulation level so that only matching traffic goes"]
    #[doc = " through."]
    pub level: u32,
    #[doc = "< Specific RSS hash types (see ETH_RSS_*)."]
    pub types: u64,
    #[doc = "< Hash key length in bytes."]
    pub key_len: u32,
    #[doc = "< Number of entries in @p queue."]
    pub queue_num: u32,
    #[doc = "< Hash key."]
    pub key: *const u8,
    #[doc = "< Queue indices to use."]
    pub queue: *const u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_rss() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_rss>(),
        40usize,
        concat!("Size of: ", stringify!(rte_flow_action_rss))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_rss>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_rss))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).key_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).queue_num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_rss>())).queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_rss),
            "::",
            stringify!(queue)
        )
    );
}
impl Default for rte_flow_action_rss {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_VF"]
#[doc = ""]
#[doc = " Directs matching traffic to a given virtual function of the current"]
#[doc = " device."]
#[doc = ""]
#[doc = " Packets matched by a VF pattern item can be redirected to their original"]
#[doc = " VF ID instead of the specified one. This parameter may not be available"]
#[doc = " and is not guaranteed to work properly if the VF part is matched by a"]
#[doc = " prior flow rule or if packets are not addressed to a VF in the first"]
#[doc = " place."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_vf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< VF ID."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_vf() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_vf>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_vf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_vf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_vf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_vf>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_vf),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_PHY_PORT"]
#[doc = ""]
#[doc = " Directs packets to a given physical port index of the underlying"]
#[doc = " device."]
#[doc = ""]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PHY_PORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_phy_port {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Physical port index."]
    pub index: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_phy_port() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_phy_port>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_phy_port))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_phy_port>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_phy_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_phy_port>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_phy_port),
            "::",
            stringify!(index)
        )
    );
}
impl rte_flow_action_phy_port {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_PORT_ID"]
#[doc = ""]
#[doc = " Directs matching traffic to a given DPDK port ID."]
#[doc = ""]
#[doc = " @see RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_port_id {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_port_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_port_id>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_port_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_port_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_port_id>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_port_id),
            "::",
            stringify!(id)
        )
    );
}
impl rte_flow_action_port_id {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER"]
#[doc = ""]
#[doc = " Traffic metering and policing (MTR)."]
#[doc = ""]
#[doc = " Packets matched by items of this type can be either dropped or passed to the"]
#[doc = " next item with their color set by the MTR object."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_meter {
    #[doc = "< MTR object ID created with rte_mtr_create()."]
    pub mtr_id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_meter() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_meter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_meter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_meter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_meter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_meter>())).mtr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_meter),
            "::",
            stringify!(mtr_id)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_SECURITY"]
#[doc = ""]
#[doc = " Perform the security action on flows matched by the pattern items"]
#[doc = " according to the configuration of the security session."]
#[doc = ""]
#[doc = " This action modifies the payload of matched flows. For INLINE_CRYPTO, the"]
#[doc = " security protocol headers and IV are fully provided by the application as"]
#[doc = " specified in the flow pattern. The payload of matching packets is"]
#[doc = " encrypted on egress, and decrypted and authenticated on ingress."]
#[doc = " For INLINE_PROTOCOL, the security protocol is fully offloaded to HW,"]
#[doc = " providing full encapsulation and decapsulation of packets in security"]
#[doc = " protocols. The flow pattern specifies both the outer security header fields"]
#[doc = " and the inner packet fields. The security session specified in the action"]
#[doc = " must match the pattern parameters."]
#[doc = ""]
#[doc = " The security session specified in the action must be created on the same"]
#[doc = " port as the flow action that is being specified."]
#[doc = ""]
#[doc = " The ingress/egress flow attribute should match that specified in the"]
#[doc = " security session if the security session supports the definition of the"]
#[doc = " direction."]
#[doc = ""]
#[doc = " Multiple flows can be configured to use the same security session."]
#[doc = ""]
#[doc = " The NULL value is allowed for security session. If security session is NULL,"]
#[doc = " then SPI field in ESP flow item and IP addresses in flow items 'IPv4' and"]
#[doc = " 'IPv6' will be allowed to be a range. The rule thus created can enable"]
#[doc = " security processing on multiple flows."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_security {
    #[doc = "< Pointer to security session structure."]
    pub security_session: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action_security() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_security>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_security))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_security>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_security))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_security>())).security_session as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_security),
            "::",
            stringify!(security_session)
        )
    );
}
impl Default for rte_flow_action_security {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the OpenFlow"]
#[doc = " Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_mpls_ttl {
    #[doc = "< MPLS TTL."]
    pub mpls_ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_mpls_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_mpls_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_mpls_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_mpls_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_mpls_ttl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_set_mpls_ttl>())).mpls_ttl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_mpls_ttl),
            "::",
            stringify!(mpls_ttl)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow Switch"]
#[doc = " Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_nw_ttl {
    #[doc = "< IP TTL."]
    pub nw_ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_nw_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_nw_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_nw_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_nw_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_nw_ttl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_set_nw_ttl>())).nw_ttl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_nw_ttl),
            "::",
            stringify!(nw_ttl)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN"]
#[doc = ""]
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_push_vlan {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_push_vlan() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_push_vlan>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_push_vlan))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_push_vlan>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_push_vlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_push_vlan>())).ethertype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_push_vlan),
            "::",
            stringify!(ethertype)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN id\") as defined by"]
#[doc = " the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_vlan_vid {
    #[doc = "< VLAN id."]
    pub vlan_vid: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_vlan_vid() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_vlan_vid>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_vlan_vid))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_vlan_vid>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_vlan_vid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_set_vlan_vid>())).vlan_vid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_vlan_vid),
            "::",
            stringify!(vlan_vid)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP"]
#[doc = ""]
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as defined by"]
#[doc = " the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_set_vlan_pcp {
    #[doc = "< VLAN priority."]
    pub vlan_pcp: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_set_vlan_pcp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_set_vlan_pcp>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_set_vlan_pcp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_set_vlan_pcp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_set_vlan_pcp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_set_vlan_pcp>())).vlan_pcp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_set_vlan_pcp),
            "::",
            stringify!(vlan_pcp)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_POP_MPLS"]
#[doc = ""]
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_pop_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_pop_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_pop_mpls>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_pop_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_pop_mpls>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_pop_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_pop_mpls>())).ethertype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_pop_mpls),
            "::",
            stringify!(ethertype)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS"]
#[doc = ""]
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by the"]
#[doc = " OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_of_push_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_of_push_mpls() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_of_push_mpls>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_of_push_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_of_push_mpls>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_of_push_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_of_push_mpls>())).ethertype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_of_push_mpls),
            "::",
            stringify!(ethertype)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP"]
#[doc = ""]
#[doc = " VXLAN tunnel end-point encapsulation data definition"]
#[doc = ""]
#[doc = " The tunnel definition is provided through the flow item pattern, the"]
#[doc = " provided pattern must conform to RFC7348 for the tunnel specified. The flow"]
#[doc = " definition must be provided in order from the RTE_FLOW_ITEM_TYPE_ETH"]
#[doc = " definition up the end item which is specified by RTE_FLOW_ITEM_TYPE_END."]
#[doc = ""]
#[doc = " The mask field allows user to specify which fields in the flow item"]
#[doc = " definitions can be ignored and which have valid data and can be used"]
#[doc = " verbatim."]
#[doc = ""]
#[doc = " Note: the last field is not used in the definition of a tunnel and can be"]
#[doc = " ignored."]
#[doc = ""]
#[doc = " Valid flow definition for RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP include:"]
#[doc = ""]
#[doc = " - ETH / IPV4 / UDP / VXLAN / END"]
#[doc = " - ETH / IPV6 / UDP / VXLAN / END"]
#[doc = " - ETH / VLAN / IPV4 / UDP / VXLAN / END"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_vxlan_encap {
    #[doc = " Encapsulating vxlan tunnel definition"]
    #[doc = " (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[test]
fn bindgen_test_layout_rte_flow_action_vxlan_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_vxlan_encap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_vxlan_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_vxlan_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_vxlan_encap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_vxlan_encap>())).definition as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_vxlan_encap),
            "::",
            stringify!(definition)
        )
    );
}
impl Default for rte_flow_action_vxlan_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP"]
#[doc = ""]
#[doc = " NVGRE tunnel end-point encapsulation data definition"]
#[doc = ""]
#[doc = " The tunnel definition is provided through the flow item pattern  the"]
#[doc = " provided pattern must conform with RFC7637. The flow definition must be"]
#[doc = " provided in order from the RTE_FLOW_ITEM_TYPE_ETH definition up the end item"]
#[doc = " which is specified by RTE_FLOW_ITEM_TYPE_END."]
#[doc = ""]
#[doc = " The mask field allows user to specify which fields in the flow item"]
#[doc = " definitions can be ignored and which have valid data and can be used"]
#[doc = " verbatim."]
#[doc = ""]
#[doc = " Note: the last field is not used in the definition of a tunnel and can be"]
#[doc = " ignored."]
#[doc = ""]
#[doc = " Valid flow definition for RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP include:"]
#[doc = ""]
#[doc = " - ETH / IPV4 / NVGRE / END"]
#[doc = " - ETH / VLAN / IPV6 / NVGRE / END"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_nvgre_encap {
    #[doc = " Encapsulating vxlan tunnel definition"]
    #[doc = " (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[test]
fn bindgen_test_layout_rte_flow_action_nvgre_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_nvgre_encap>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_nvgre_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_nvgre_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_nvgre_encap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_nvgre_encap>())).definition as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_nvgre_encap),
            "::",
            stringify!(definition)
        )
    );
}
impl Default for rte_flow_action_nvgre_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_RAW_ENCAP"]
#[doc = ""]
#[doc = " Raw tunnel end-point encapsulation data definition."]
#[doc = ""]
#[doc = " The data holds the headers definitions to be applied on the packet."]
#[doc = " The data must start with ETH header up to the tunnel item header itself."]
#[doc = " When used right after RAW_DECAP (for decapsulating L3 tunnel type for"]
#[doc = " example MPLSoGRE) the data will just hold layer 2 header."]
#[doc = ""]
#[doc = " The preserve parameter holds which bits in the packet the PMD is not allowed"]
#[doc = " to change, this parameter can also be NULL and then the PMD is allowed"]
#[doc = " to update any field."]
#[doc = ""]
#[doc = " size holds the number of bytes in @p data and @p preserve."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_raw_encap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Bit-mask of @p data to preserve on output."]
    pub preserve: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rte_flow_action_raw_encap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_raw_encap>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_action_raw_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_raw_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_raw_encap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).preserve as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(preserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_encap>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_encap),
            "::",
            stringify!(size)
        )
    );
}
impl Default for rte_flow_action_raw_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_RAW_DECAP"]
#[doc = ""]
#[doc = " Raw tunnel end-point decapsulation data definition."]
#[doc = ""]
#[doc = " The data holds the headers definitions to be removed from the packet."]
#[doc = " The data must start with ETH header up to the tunnel item header itself."]
#[doc = " When used right before RAW_DECAP (for encapsulating L3 tunnel type for"]
#[doc = " example MPLSoGRE) the data will just hold layer 2 header."]
#[doc = ""]
#[doc = " size holds the number of bytes in @p data."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_raw_decap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_rte_flow_action_raw_decap() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_raw_decap>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_raw_decap))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_raw_decap>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_raw_decap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_decap>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_decap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_raw_decap>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_raw_decap),
            "::",
            stringify!(size)
        )
    );
}
impl Default for rte_flow_action_raw_decap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_DST"]
#[doc = ""]
#[doc = " Allows modification of IPv4 source (RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC)"]
#[doc = " and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV4_DST) in the"]
#[doc = " specified outermost IPv4 header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ipv4 {
    pub ipv4_addr: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ipv4>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_ipv4>())).ipv4_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ipv4),
            "::",
            stringify!(ipv4_addr)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_DST"]
#[doc = ""]
#[doc = " Allows modification of IPv6 source (RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC)"]
#[doc = " and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV6_DST) in the"]
#[doc = " specified outermost IPv6 header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ipv6 {
    pub ipv6_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ipv6>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ipv6>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_ipv6>())).ipv6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ipv6),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TP_SRC"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TP_DST"]
#[doc = ""]
#[doc = " Allows modification of source (RTE_FLOW_ACTION_TYPE_SET_TP_SRC)"]
#[doc = " and destination (RTE_FLOW_ACTION_TYPE_SET_TP_DST) port numbers"]
#[doc = " in the specified outermost TCP/UDP header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_tp {
    pub port: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_tp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_tp>(),
        2usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_tp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_tp>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_tp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tp>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tp),
            "::",
            stringify!(port)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TTL"]
#[doc = ""]
#[doc = " Set the TTL value directly for IPv4 or IPv6"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_ttl {
    pub ttl_value: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_ttl() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_ttl>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_ttl))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_ttl>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_ttl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_ttl>())).ttl_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_ttl),
            "::",
            stringify!(ttl_value)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_MAC"]
#[doc = ""]
#[doc = " Set MAC address from the matched flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_mac {
    pub mac_addr: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_mac() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_mac>(),
        6usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_mac))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_mac>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_mac))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_mac>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_mac),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TAG"]
#[doc = ""]
#[doc = " Set a tag which is a transient data used during flow matching. This is not"]
#[doc = " delivered to application. Multiple tags are supported by specifying index."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_tag {
    pub data: u32,
    pub mask: u32,
    pub index: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_tag() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_tag>(),
        12usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_tag>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_tag),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_META"]
#[doc = ""]
#[doc = " Set metadata. Metadata set by mbuf metadata dynamic field with"]
#[doc = " PKT_TX_DYNF_DATA flag on egress will be overridden by this action. On"]
#[doc = " ingress, the metadata will be carried by mbuf metadata dynamic field"]
#[doc = " with PKT_RX_DYNF_METADATA flag if set.  The dynamic mbuf field must be"]
#[doc = " registered in advance by rte_flow_dynf_metadata_register()."]
#[doc = ""]
#[doc = " Altering partial bits is supported with mask. For bits which have never"]
#[doc = " been set, unpredictable value will be seen depending on driver"]
#[doc = " implementation. For loopback/hairpin packet, metadata set on Rx/Tx may"]
#[doc = " or may not be propagated to the other path depending on HW capability."]
#[doc = ""]
#[doc = " RTE_FLOW_ITEM_TYPE_META matches metadata."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_meta {
    pub data: u32,
    pub mask: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_meta() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_meta>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_meta>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_meta>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_meta),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_meta>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_meta),
            "::",
            stringify!(mask)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV4_DSCP"]
#[doc = " RTE_FLOW_ACTION_TYPE_SET_IPV6_DSCP"]
#[doc = ""]
#[doc = " Set the DSCP value for IPv4/IPv6 header."]
#[doc = " DSCP in low 6 bits, rest ignored."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_action_set_dscp {
    pub dscp: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_action_set_dscp() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_set_dscp>(),
        1usize,
        concat!("Size of: ", stringify!(rte_flow_action_set_dscp))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_set_dscp>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_action_set_dscp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_set_dscp>())).dscp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_set_dscp),
            "::",
            stringify!(dscp)
        )
    );
}
#[doc = " RTE_FLOW_ACTION_TYPE_SHARED"]
#[doc = ""]
#[doc = " Opaque type returned after successfully creating a shared action."]
#[doc = ""]
#[doc = " This handle can be used to manage and query the related action:"]
#[doc = " - share it across multiple flow rules"]
#[doc = " - update action configuration"]
#[doc = " - query action data"]
#[doc = " - destroy action"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_shared_action {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_offs: i32;
}
extern "C" {
    pub static mut rte_flow_dynf_metadata_mask: u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type::Type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action>())).conf as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_flow_action), "::", stringify!(conf))
    );
}
impl Default for rte_flow_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Opaque type returned after successfully creating a flow."]
#[doc = ""]
#[doc = " This handle can be used to manage and query the related flow (e.g. to"]
#[doc = " destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice"]
#[doc = ""]
#[doc = " RTE_FLOW_ACTION_TYPE_SAMPLE"]
#[doc = ""]
#[doc = " Adds a sample action to a matched flow."]
#[doc = ""]
#[doc = " The matching packets will be duplicated with specified ratio and applied"]
#[doc = " with own set of actions with a fate action, the sampled packet could be"]
#[doc = " redirected to queue or port. All the packets continue processing on the"]
#[doc = " default flow path."]
#[doc = ""]
#[doc = " When the sample ratio is set to 1 then the packets will be 100% mirrored."]
#[doc = " Additional action list be supported to add for sampled or mirrored packets."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_action_sample {
    #[doc = "< packets sampled equals to '1/ratio'."]
    pub ratio: u32,
    pub actions: *const rte_flow_action,
}
#[test]
fn bindgen_test_layout_rte_flow_action_sample() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_action_sample>(),
        16usize,
        concat!("Size of: ", stringify!(rte_flow_action_sample))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_action_sample>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_action_sample))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_sample>())).ratio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_sample),
            "::",
            stringify!(ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_action_sample>())).actions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_action_sample),
            "::",
            stringify!(actions)
        )
    );
}
impl Default for rte_flow_action_sample {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_flow_error_type {
    #[doc = " Verbose error types."]
    #[doc = ""]
    #[doc = " Most of them provide the type of the object referenced by struct"]
    #[doc = " rte_flow_error.cause."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< No error."]
    pub const RTE_FLOW_ERROR_TYPE_NONE: Type = 0;
    #[doc = "< Cause unspecified."]
    pub const RTE_FLOW_ERROR_TYPE_UNSPECIFIED: Type = 1;
    #[doc = "< Flow rule (handle)."]
    pub const RTE_FLOW_ERROR_TYPE_HANDLE: Type = 2;
    #[doc = "< Group field."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR_GROUP: Type = 3;
    #[doc = "< Priority field."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: Type = 4;
    #[doc = "< Ingress field."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: Type = 5;
    #[doc = "< Egress field."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: Type = 6;
    #[doc = "< Transfer field."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: Type = 7;
    #[doc = "< Attributes structure."]
    pub const RTE_FLOW_ERROR_TYPE_ATTR: Type = 8;
    #[doc = "< Pattern length."]
    pub const RTE_FLOW_ERROR_TYPE_ITEM_NUM: Type = 9;
    #[doc = "< Item specification."]
    pub const RTE_FLOW_ERROR_TYPE_ITEM_SPEC: Type = 10;
    #[doc = "< Item specification range."]
    pub const RTE_FLOW_ERROR_TYPE_ITEM_LAST: Type = 11;
    #[doc = "< Item specification mask."]
    pub const RTE_FLOW_ERROR_TYPE_ITEM_MASK: Type = 12;
    #[doc = "< Specific pattern item."]
    pub const RTE_FLOW_ERROR_TYPE_ITEM: Type = 13;
    #[doc = "< Number of actions."]
    pub const RTE_FLOW_ERROR_TYPE_ACTION_NUM: Type = 14;
    #[doc = "< Action configuration."]
    pub const RTE_FLOW_ERROR_TYPE_ACTION_CONF: Type = 15;
    #[doc = "< Specific action."]
    pub const RTE_FLOW_ERROR_TYPE_ACTION: Type = 16;
}
#[doc = " Verbose error structure definition."]
#[doc = ""]
#[doc = " This object is normally allocated by applications and set by PMDs, the"]
#[doc = " message points to a constant string which does not need to be freed by"]
#[doc = " the application, however its pointer can be considered valid only as long"]
#[doc = " as its associated DPDK port remains configured. Closing the underlying"]
#[doc = " device or unloading the PMD invalidates it."]
#[doc = ""]
#[doc = " Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_flow_error {
    #[doc = "< Cause field and error types."]
    pub type_: rte_flow_error_type::Type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_flow_error() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_error>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_error>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_flow_error), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).cause as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_flow_error), "::", stringify!(cause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_error>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_error),
            "::",
            stringify!(message)
        )
    );
}
impl Default for rte_flow_error {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Complete flow rule description."]
#[doc = ""]
#[doc = " This object type is used when converting a flow rule description."]
#[doc = ""]
#[doc = " @see RTE_FLOW_CONV_OP_RULE"]
#[doc = " @see rte_flow_conv()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_conv_rule {
    pub __bindgen_anon_1: rte_flow_conv_rule__bindgen_ty_1,
    pub __bindgen_anon_2: rte_flow_conv_rule__bindgen_ty_2,
    pub __bindgen_anon_3: rte_flow_conv_rule__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_1 {
    #[doc = "< RO attributes."]
    pub attr_ro: *const rte_flow_attr,
    #[doc = "< Attributes."]
    pub attr: *mut rte_flow_attr,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_conv_rule__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_1>())).attr_ro as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_1),
            "::",
            stringify!(attr_ro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_1>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_2 {
    #[doc = "< RO pattern."]
    pub pattern_ro: *const rte_flow_item,
    #[doc = "< Pattern items."]
    pub pattern: *mut rte_flow_item,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_conv_rule__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_2>())).pattern_ro as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_2),
            "::",
            stringify!(pattern_ro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_2>())).pattern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_2),
            "::",
            stringify!(pattern)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_3 {
    #[doc = "< RO actions."]
    pub actions_ro: *const rte_flow_action,
    #[doc = "< List of actions."]
    pub actions: *mut rte_flow_action,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_conv_rule__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_3>())).actions_ro as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_3),
            "::",
            stringify!(actions_ro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_conv_rule__bindgen_ty_3>())).actions as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_conv_rule__bindgen_ty_3),
            "::",
            stringify!(actions)
        )
    );
}
impl Default for rte_flow_conv_rule__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_flow_conv_rule() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_conv_rule>(),
        24usize,
        concat!("Size of: ", stringify!(rte_flow_conv_rule))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_conv_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_conv_rule))
    );
}
impl Default for rte_flow_conv_rule {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_flow_conv_op {
    #[doc = " Conversion operations for flow API objects."]
    #[doc = ""]
    #[doc = " @see rte_flow_conv()"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " No operation to perform."]
    #[doc = ""]
    #[doc = " rte_flow_conv() simply returns 0."]
    pub const RTE_FLOW_CONV_OP_NONE: Type = 0;
    #[doc = " Convert attributes structure."]
    #[doc = ""]
    #[doc = " This is a basic copy of an attributes structure."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_attr * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_attr * @endcode"]
    pub const RTE_FLOW_CONV_OP_ATTR: Type = 1;
    #[doc = " Convert a single item."]
    #[doc = ""]
    #[doc = " Duplicates @p spec, @p last and @p mask but not outside objects."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_item * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_item * @endcode"]
    pub const RTE_FLOW_CONV_OP_ITEM: Type = 2;
    #[doc = " Convert a single action."]
    #[doc = ""]
    #[doc = " Duplicates @p conf but not outside objects."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_action * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_action * @endcode"]
    pub const RTE_FLOW_CONV_OP_ACTION: Type = 3;
    #[doc = " Convert an entire pattern."]
    #[doc = ""]
    #[doc = " Duplicates all pattern items at once with the same constraints as"]
    #[doc = " RTE_FLOW_CONV_OP_ITEM."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_item * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_item * @endcode"]
    pub const RTE_FLOW_CONV_OP_PATTERN: Type = 4;
    #[doc = " Convert a list of actions."]
    #[doc = ""]
    #[doc = " Duplicates the entire list of actions at once with the same"]
    #[doc = " constraints as RTE_FLOW_CONV_OP_ACTION."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_action * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_action * @endcode"]
    pub const RTE_FLOW_CONV_OP_ACTIONS: Type = 5;
    #[doc = " Convert a complete flow rule description."]
    #[doc = ""]
    #[doc = " Comprises attributes, pattern and actions together at once with"]
    #[doc = " the usual constraints."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code const struct rte_flow_conv_rule * @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code struct rte_flow_conv_rule * @endcode"]
    pub const RTE_FLOW_CONV_OP_RULE: Type = 6;
    #[doc = " Convert item type to its name string."]
    #[doc = ""]
    #[doc = " Writes a NUL-terminated string to @p dst. Like snprintf(), the"]
    #[doc = " returned value excludes the terminator which is always written"]
    #[doc = " nonetheless."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_item_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code char * @endcode"]
    pub const RTE_FLOW_CONV_OP_ITEM_NAME: Type = 7;
    #[doc = " Convert action type to its name string."]
    #[doc = ""]
    #[doc = " Writes a NUL-terminated string to @p dst. Like snprintf(), the"]
    #[doc = " returned value excludes the terminator which is always written"]
    #[doc = " nonetheless."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_action_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code char * @endcode"]
    pub const RTE_FLOW_CONV_OP_ACTION_NAME: Type = 8;
    #[doc = " Convert item type to pointer to item name."]
    #[doc = ""]
    #[doc = " Retrieves item name pointer from its type. The string itself is"]
    #[doc = " not copied; instead, a unique pointer to an internal static"]
    #[doc = " constant storage is written to @p dst."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_item_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code const char ** @endcode"]
    pub const RTE_FLOW_CONV_OP_ITEM_NAME_PTR: Type = 9;
    #[doc = " Convert action type to pointer to action name."]
    #[doc = ""]
    #[doc = " Retrieves action name pointer from its type. The string itself is"]
    #[doc = " not copied; instead, a unique pointer to an internal static"]
    #[doc = " constant storage is written to @p dst."]
    #[doc = ""]
    #[doc = " - @p src type:"]
    #[doc = "   @code (const void *)enum rte_flow_action_type @endcode"]
    #[doc = " - @p dst type:"]
    #[doc = "   @code const char ** @endcode"]
    pub const RTE_FLOW_CONV_OP_ACTION_NAME_PTR: Type = 10;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Dump hardware internal representation information of"]
    #[doc = " rte flow to file."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] file"]
    #[doc = "   A pointer to a file for output."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   0 on success, a nagative value otherwise."]
    pub fn rte_flow_dev_dump(port_id: u16, file: *mut FILE, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mbuf dynamic field and flag for metadata."]
    #[doc = ""]
    #[doc = " This function must be called prior to use SET_META action in order to"]
    #[doc = " register the dynamic mbuf field. Otherwise, the data cannot be delivered to"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_dynf_metadata_register() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a flow rule can be created on a given port."]
    #[doc = ""]
    #[doc = " The flow rule is validated for correctness and whether it could be accepted"]
    #[doc = " by the device given sufficient resources. The rule is checked against the"]
    #[doc = " current device mode and queue configuration. The flow rule may also"]
    #[doc = " optionally be validated against existing flow rules and device resources."]
    #[doc = " This function has no effect on the target device."]
    #[doc = ""]
    #[doc = " The returned value is guaranteed to remain valid only as long as no"]
    #[doc = " successful calls to rte_flow_create() or rte_flow_destroy() are made in"]
    #[doc = " the meantime and no device parameter affecting flow rules in any way are"]
    #[doc = " modified, due to possible collisions or resource limitations (although in"]
    #[doc = " such cases EINVAL should not be returned)."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] pattern"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 if flow rule is valid and can be created. A negative errno value"]
    #[doc = "   otherwise (rte_errno is also set), the following errors are defined:"]
    #[doc = ""]
    #[doc = "   -ENOSYS: underlying device does not support this functionality."]
    #[doc = ""]
    #[doc = "   -EIO: underlying device is removed."]
    #[doc = ""]
    #[doc = "   -EINVAL: unknown or invalid rule specification."]
    #[doc = ""]
    #[doc = "   -ENOTSUP: valid but unsupported rule specification (e.g. partial"]
    #[doc = "   bit-masks are unsupported)."]
    #[doc = ""]
    #[doc = "   -EEXIST: collision with an existing rule. Only returned if device"]
    #[doc = "   supports flow rule collision checking and there was a flow rule"]
    #[doc = "   collision. Not receiving this return code is no guarantee that creating"]
    #[doc = "   the rule will not fail due to a collision."]
    #[doc = ""]
    #[doc = "   -ENOMEM: not enough memory to execute the function, or if the device"]
    #[doc = "   supports resource validation, resource limitation on the device."]
    #[doc = ""]
    #[doc = "   -EBUSY: action cannot be performed due to busy device resources, may"]
    #[doc = "   succeed if the affected queues or even the entire port are in a stopped"]
    #[doc = "   state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop())."]
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a flow rule on a given port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] pattern"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A valid handle in case of success, NULL otherwise and rte_errno is set"]
    #[doc = "   to the positive version of one of the error codes defined for"]
    #[doc = "   rte_flow_validate()."]
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
extern "C" {
    #[doc = " Destroy a flow rule on a given port."]
    #[doc = ""]
    #[doc = " Failure to destroy a flow rule handle may occur when other flow rules"]
    #[doc = " depend on it, and destroying it would result in an inconsistent state."]
    #[doc = ""]
    #[doc = " This function is only guaranteed to succeed if handles are destroyed in"]
    #[doc = " reverse order of their creation."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param flow"]
    #[doc = "   Flow rule handle to destroy."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_destroy(port_id: u16, flow: *mut rte_flow, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy all flow rules associated with a port."]
    #[doc = ""]
    #[doc = " In the unlikely event of failure, handles are still considered destroyed"]
    #[doc = " and no longer valid but the port must be assumed to be in an inconsistent"]
    #[doc = " state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query an existing flow rule."]
    #[doc = ""]
    #[doc = " This function allows retrieving flow-specific data such as counters."]
    #[doc = " Data is gathered by special actions which must be present in the flow"]
    #[doc = " rule definition."]
    #[doc = ""]
    #[doc = " \\see RTE_FLOW_ACTION_TYPE_COUNT"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param flow"]
    #[doc = "   Flow rule handle to query."]
    #[doc = " @param action"]
    #[doc = "   Action definition as defined in original flow rule."]
    #[doc = " @param[in, out] data"]
    #[doc = "   Pointer to storage for the associated query data type."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_query(
        port_id: u16,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restrict ingress traffic to the defined flow rules."]
    #[doc = ""]
    #[doc = " Isolated mode guarantees that all ingress traffic comes from defined flow"]
    #[doc = " rules only (current and future)."]
    #[doc = ""]
    #[doc = " Besides making ingress more deterministic, it allows PMDs to safely reuse"]
    #[doc = " resources otherwise assigned to handle the remaining traffic, such as"]
    #[doc = " global RSS configuration settings, VLAN filters, MAC address entries,"]
    #[doc = " legacy filter API rules and so on in order to expand the set of possible"]
    #[doc = " flow rule types."]
    #[doc = ""]
    #[doc = " Calling this function as soon as possible after device initialization,"]
    #[doc = " ideally before the first call to rte_eth_dev_configure(), is recommended"]
    #[doc = " to avoid possible failures due to conflicting settings."]
    #[doc = ""]
    #[doc = " Once effective, leaving isolated mode may not be possible depending on"]
    #[doc = " PMD implementation."]
    #[doc = ""]
    #[doc = " Additionally, the following functionality has no effect on the underlying"]
    #[doc = " port and may return errors such as ENOTSUP (\"not supported\"):"]
    #[doc = ""]
    #[doc = " - Toggling promiscuous mode."]
    #[doc = " - Toggling allmulticast mode."]
    #[doc = " - Configuring MAC addresses."]
    #[doc = " - Configuring multicast addresses."]
    #[doc = " - Configuring VLAN filters."]
    #[doc = " - Configuring Rx filters through the legacy API (e.g. FDIR)."]
    #[doc = " - Configuring global RSS settings."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param set"]
    #[doc = "   Nonzero to enter isolated mode, attempt to leave it otherwise."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_isolate(
        port_id: u16,
        set: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize flow error structure."]
    #[doc = ""]
    #[doc = " @param[out] error"]
    #[doc = "   Pointer to flow error structure (may be NULL)."]
    #[doc = " @param code"]
    #[doc = "   Related error code (rte_errno)."]
    #[doc = " @param type"]
    #[doc = "   Cause field and error types."]
    #[doc = " @param cause"]
    #[doc = "   Object responsible for the error."]
    #[doc = " @param message"]
    #[doc = "   Human-readable error message."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Negative error code (errno value) and rte_errno is set."]
    pub fn rte_flow_error_set(
        error: *mut rte_flow_error,
        code: ::std::os::raw::c_int,
        type_: rte_flow_error_type::Type,
        cause: *const ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @deprecated"]
#[doc = " @see rte_flow_copy()"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_flow_desc {
    #[doc = "< Allocated space including data[]."]
    pub size: usize,
    #[doc = "< Attributes."]
    pub attr: rte_flow_attr,
    #[doc = "< Items."]
    pub items: *mut rte_flow_item,
    #[doc = "< Actions."]
    pub actions: *mut rte_flow_action,
    #[doc = "< Storage for items/actions."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_flow_desc() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_desc>(),
        40usize,
        concat!("Size of: ", stringify!(rte_flow_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_desc>())).size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_flow_desc), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_desc>())).attr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_flow_desc), "::", stringify!(attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_desc>())).items as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(rte_flow_desc), "::", stringify!(items))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_desc>())).actions as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_desc),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_desc>())).data as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rte_flow_desc), "::", stringify!(data))
    );
}
impl Default for rte_flow_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @deprecated"]
    #[doc = " Copy an rte_flow rule description."]
    #[doc = ""]
    #[doc = " This interface is kept for compatibility with older applications but is"]
    #[doc = " implemented as a wrapper to rte_flow_conv(). It is deprecated due to its"]
    #[doc = " lack of flexibility and reliance on a type unusable with C++ programs"]
    #[doc = " (struct rte_flow_desc)."]
    #[doc = ""]
    #[doc = " @param[in] fd"]
    #[doc = "   Flow rule description."]
    #[doc = " @param[in] len"]
    #[doc = "   Total size of allocated data for the flow description."]
    #[doc = " @param[in] attr"]
    #[doc = "   Flow rule attributes."]
    #[doc = " @param[in] items"]
    #[doc = "   Pattern specification (list terminated by the END pattern item)."]
    #[doc = " @param[in] actions"]
    #[doc = "   Associated actions (list terminated by the END action)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   If len is greater or equal to the size of the flow, the total size of the"]
    #[doc = "   flow description and its data."]
    #[doc = "   If len is lower than the size of the flow, the number of bytes that would"]
    #[doc = "   have been written to desc had it been sufficient. Nothing is written."]
    pub fn rte_flow_copy(
        fd: *mut rte_flow_desc,
        len: usize,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
    ) -> usize;
}
extern "C" {
    #[doc = " Flow object conversion helper."]
    #[doc = ""]
    #[doc = " This function performs conversion of various flow API objects to a"]
    #[doc = " pre-allocated destination buffer. See enum rte_flow_conv_op for possible"]
    #[doc = " operations and details about each of them."]
    #[doc = ""]
    #[doc = " Since destination buffer must be large enough, it works in a manner"]
    #[doc = " reminiscent of snprintf():"]
    #[doc = ""]
    #[doc = " - If @p size is 0, @p dst may be a NULL pointer, otherwise @p dst must be"]
    #[doc = "   non-NULL."]
    #[doc = " - If positive, the returned value represents the number of bytes needed"]
    #[doc = "   to store the conversion of @p src to @p dst according to @p op"]
    #[doc = "   regardless of the @p size parameter."]
    #[doc = " - Since no more than @p size bytes can be written to @p dst, output is"]
    #[doc = "   truncated and may be inconsistent when the returned value is larger"]
    #[doc = "   than that."]
    #[doc = " - In case of conversion error, a negative error code is returned and"]
    #[doc = "   @p dst contents are unspecified."]
    #[doc = ""]
    #[doc = " @param op"]
    #[doc = "   Operation to perform, related to the object type of @p dst."]
    #[doc = " @param[out] dst"]
    #[doc = "   Destination buffer address. Must be suitably aligned by the caller."]
    #[doc = " @param size"]
    #[doc = "   Destination buffer size in bytes."]
    #[doc = " @param[in] src"]
    #[doc = "   Source object to copy. Depending on @p op, its type may differ from"]
    #[doc = "   that of @p dst."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. Initialized in case of"]
    #[doc = "   error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of bytes required to convert @p src to @p dst on success, a"]
    #[doc = "   negative errno value otherwise and rte_errno is set."]
    #[doc = ""]
    #[doc = " @see rte_flow_conv_op"]
    pub fn rte_flow_conv(
        op: rte_flow_conv_op::Type,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        src: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get aged-out flows of a given port."]
    #[doc = ""]
    #[doc = " RTE_ETH_EVENT_FLOW_AGED event will be triggered when at least one new aged"]
    #[doc = " out flow was detected after the last call to rte_flow_get_aged_flows."]
    #[doc = " This function can be called to get the aged flows usynchronously from the"]
    #[doc = " event callback or synchronously regardless the event."]
    #[doc = " This is not safe to call rte_flow_get_aged_flows function with other flow"]
    #[doc = " functions from multiple threads simultaneously."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in, out] contexts"]
    #[doc = "   The address of an array of pointers to the aged-out flows contexts."]
    #[doc = " @param[in] nb_contexts"]
    #[doc = "   The length of context array pointers."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. Initialized in case of"]
    #[doc = "   error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   if nb_contexts is 0, return the amount of all aged contexts."]
    #[doc = "   if nb_contexts is not 0 , return the amount of aged flows reported"]
    #[doc = "   in the context array, otherwise negative errno value."]
    #[doc = ""]
    #[doc = " @see rte_flow_action_age"]
    #[doc = " @see RTE_ETH_EVENT_FLOW_AGED"]
    pub fn rte_flow_get_aged_flows(
        port_id: u16,
        contexts: *mut *mut ::std::os::raw::c_void,
        nb_contexts: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Specify shared action configuration"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_shared_action_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_flow_shared_action_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_shared_action_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_flow_shared_action_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_shared_action_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_shared_action_conf))
    );
}
impl rte_flow_shared_action_conf {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ingress: u32, egress: u32, transfer: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Create shared action for reuse in multiple flow rules."]
    #[doc = " The created shared action has single state and configuration"]
    #[doc = " across all flow rules using it."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] conf"]
    #[doc = "   Shared action configuration."]
    #[doc = " @param[in] action"]
    #[doc = "   Action configuration for shared action creation."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   A valid handle in case of success, NULL otherwise and rte_errno is set"]
    #[doc = "   to one of the error codes defined:"]
    #[doc = "   - (ENODEV) if *port_id* invalid."]
    #[doc = "   - (ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (EIO) if underlying device is removed."]
    #[doc = "   - (EINVAL) if *action* invalid."]
    #[doc = "   - (ENOTSUP) if *action* valid but unsupported."]
    pub fn rte_flow_shared_action_create(
        port_id: u16,
        conf: *const rte_flow_shared_action_conf,
        action: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow_shared_action;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Destroy the shared action by handle."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] action"]
    #[doc = "   Handle for the shared action to be destroyed."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   - (0) if success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (-EIO) if underlying device is removed."]
    #[doc = "   - (-ENOENT) if action pointed by *action* handle was not found."]
    #[doc = "   - (-EBUSY) if action pointed by *action* handle still used by some rules"]
    #[doc = "   rte_errno is also set."]
    pub fn rte_flow_shared_action_destroy(
        port_id: u16,
        action: *mut rte_flow_shared_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Update in-place the shared action configuration pointed by *action* handle"]
    #[doc = " with the configuration provided as *update* argument."]
    #[doc = " The update of the shared action configuration effects all flow rules reusing"]
    #[doc = " the action via handle."]
    #[doc = ""]
    #[doc = " @param[in] port_id"]
    #[doc = "    The port identifier of the Ethernet device."]
    #[doc = " @param[in] action"]
    #[doc = "   Handle for the shared action to be updated."]
    #[doc = " @param[in] update"]
    #[doc = "   Action specification used to modify the action pointed by handle."]
    #[doc = "   *update* should be of same type with the action pointed by the *action*"]
    #[doc = "   handle argument, otherwise considered as invalid."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = " @return"]
    #[doc = "   - (0) if success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOSYS) if underlying device does not support this functionality."]
    #[doc = "   - (-EIO) if underlying device is removed."]
    #[doc = "   - (-EINVAL) if *update* invalid."]
    #[doc = "   - (-ENOTSUP) if *update* valid but unsupported."]
    #[doc = "   - (-ENOENT) if action pointed by *ctx* was not found."]
    #[doc = "   rte_errno is also set."]
    pub fn rte_flow_shared_action_update(
        port_id: u16,
        action: *mut rte_flow_shared_action,
        update: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Query the shared action by handle."]
    #[doc = ""]
    #[doc = " Retrieve action-specific data such as counters."]
    #[doc = " Data is gathered by special action which may be present/referenced in"]
    #[doc = " more than one flow rule definition."]
    #[doc = ""]
    #[doc = " \\see RTE_FLOW_ACTION_TYPE_COUNT"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] action"]
    #[doc = "   Handle for the shared action to query."]
    #[doc = " @param[in, out] data"]
    #[doc = "   Pointer to storage for the associated query data type."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_shared_action_query(
        port_id: u16,
        action: *const rte_flow_shared_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_tunnel {
    #[doc = " Tunnel type, for example RTE_FLOW_ITEM_TYPE_VXLAN,"]
    #[doc = " RTE_FLOW_ITEM_TYPE_NVGRE etc."]
    pub type_: rte_flow_item_type::Type,
    #[doc = "< Tunnel identification."]
    pub tun_id: u64,
    pub __bindgen_anon_1: rte_flow_tunnel__bindgen_ty_1,
    #[doc = "< Tunnel port source."]
    pub tp_src: rte_be16_t,
    #[doc = "< Tunnel port destination."]
    pub tp_dst: rte_be16_t,
    #[doc = "< Tunnel flags."]
    pub tun_flags: u16,
    #[doc = "< True for valid IPv6 fields. Otherwise IPv4."]
    pub is_ipv6: bool,
    #[doc = "< TOS for IPv4, TC for IPv6."]
    pub tos: u8,
    #[doc = "< TTL for IPv4, HL for IPv6."]
    pub ttl: u8,
    #[doc = "< Flow Label for IPv6."]
    pub label: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_tunnel__bindgen_ty_1 {
    pub ipv4: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< IPv4 source address."]
    pub src_addr: rte_be32_t,
    #[doc = "< IPv4 destination address."]
    pub dst_addr: rte_be32_t,
}
#[test]
fn bindgen_test_layout_rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1>())).src_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1>())).dst_addr as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< IPv6 source address."]
    pub src_addr: [u8; 16usize],
    #[doc = "< IPv6 destination address."]
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2>())).src_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2>())).dst_addr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dst_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_flow_tunnel__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_tunnel__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(rte_flow_tunnel__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_tunnel__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_flow_tunnel__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1>())).ipv4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel__bindgen_ty_1>())).ipv6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
}
impl Default for rte_flow_tunnel__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_flow_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_tunnel>(),
        64usize,
        concat!("Size of: ", stringify!(rte_flow_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_tunnel>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).tun_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(tun_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).tp_src as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(tp_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).tp_dst as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(tp_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).tun_flags as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(tun_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).is_ipv6 as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(is_ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).tos as *const _ as usize },
        55usize,
        concat!("Offset of field: ", stringify!(rte_flow_tunnel), "::", stringify!(tos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).ttl as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_flow_tunnel), "::", stringify!(ttl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_tunnel>())).label as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_tunnel),
            "::",
            stringify!(label)
        )
    );
}
impl Default for rte_flow_tunnel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Restore information structure to communicate the current packet processing"]
#[doc = " state when some of the processing pipeline is done in hardware and should"]
#[doc = " continue in software."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_restore_info {
    #[doc = " Bitwise flags (RTE_FLOW_RESTORE_INFO_*) to indicate validation of"]
    #[doc = " other fields in struct rte_flow_restore_info."]
    pub flags: u64,
    #[doc = "< Group ID where packed missed"]
    pub group_id: u32,
    #[doc = "< Tunnel information."]
    pub tunnel: rte_flow_tunnel,
}
#[test]
fn bindgen_test_layout_rte_flow_restore_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_flow_restore_info>(),
        80usize,
        concat!("Size of: ", stringify!(rte_flow_restore_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_flow_restore_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_flow_restore_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_restore_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_restore_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_restore_info>())).group_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_restore_info),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_flow_restore_info>())).tunnel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_flow_restore_info),
            "::",
            stringify!(tunnel)
        )
    );
}
impl Default for rte_flow_restore_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Allocate an array of actions to be used in rte_flow_create, to implement"]
    #[doc = " tunnel-decap-set for the given tunnel."]
    #[doc = " Sample usage:"]
    #[doc = "   actions vxlan_decap / tunnel-decap-set(tunnel properties) /"]
    #[doc = "            jump group 0 / end"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] tunnel"]
    #[doc = "   Tunnel properties."]
    #[doc = " @param[out] actions"]
    #[doc = "   Array of actions to be allocated by the PMD. This array should be"]
    #[doc = "   concatenated with the actions array provided to rte_flow_create."]
    #[doc = " @param[out] num_of_actions"]
    #[doc = "   Number of actions allocated."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_decap_set(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        actions: *mut *mut rte_flow_action,
        num_of_actions: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an array of items to be used in rte_flow_create, to implement"]
    #[doc = " tunnel-match for the given tunnel."]
    #[doc = " Sample usage:"]
    #[doc = "   pattern tunnel-match(tunnel properties) / outer-header-matches /"]
    #[doc = "           inner-header-matches / end"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] tunnel"]
    #[doc = "   Tunnel properties."]
    #[doc = " @param[out] items"]
    #[doc = "   Array of items to be allocated by the PMD. This array should be"]
    #[doc = "   concatenated with the items array provided to rte_flow_create."]
    #[doc = " @param[out] num_of_items"]
    #[doc = "   Number of items allocated."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_match(
        port_id: u16,
        tunnel: *mut rte_flow_tunnel,
        items: *mut *mut rte_flow_item,
        num_of_items: *mut u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Populate the current packet processing state, if exists, for the given mbuf."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] m"]
    #[doc = "   Mbuf struct."]
    #[doc = " @param[out] info"]
    #[doc = "   Restore information. Upon success contains the HW state."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_get_restore_info(
        port_id: u16,
        m: *mut rte_mbuf,
        info: *mut rte_flow_restore_info,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the action array as allocated by rte_flow_tunnel_decap_set."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] actions"]
    #[doc = "   Array of actions to be released."]
    #[doc = " @param[in] num_of_actions"]
    #[doc = "   Number of elements in actions array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_action_decap_release(
        port_id: u16,
        actions: *mut rte_flow_action,
        num_of_actions: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the item array as allocated by rte_flow_tunnel_match."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of Ethernet device."]
    #[doc = " @param[in] items"]
    #[doc = "   Array of items to be released."]
    #[doc = " @param[in] num_of_items"]
    #[doc = "   Number of elements in item array."]
    #[doc = " @param[out] error"]
    #[doc = "   Perform verbose error reporting if not NULL. PMDs initialize this"]
    #[doc = "   structure in case of error only."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_tunnel_item_release(
        port_id: u16,
        items: *mut rte_flow_item,
        num_of_items: u32,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to define the ntuple filter entry"]
#[doc = " to support RTE_ETH_FILTER_NTUPLE data representation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP."]
    #[doc = "The packet matched above ntuple fields and contain"]
    #[doc = "any set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,"]
    #[doc = "used when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ntuple_filter>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ntuple_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port_mask as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port_mask as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto_mask as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).tcp_flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).queue as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(queue)
        )
    );
}
pub mod rte_eth_input_set_field {
    #[doc = " Input set fields for Flow Director and Hash filters"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_INPUT_SET_UNKNOWN: Type = 0;
    pub const RTE_ETH_INPUT_SET_L2_SRC_MAC: Type = 1;
    pub const RTE_ETH_INPUT_SET_L2_DST_MAC: Type = 2;
    pub const RTE_ETH_INPUT_SET_L2_OUTER_VLAN: Type = 3;
    pub const RTE_ETH_INPUT_SET_L2_INNER_VLAN: Type = 4;
    pub const RTE_ETH_INPUT_SET_L2_ETHERTYPE: Type = 5;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP4: Type = 129;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP4: Type = 130;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP6: Type = 131;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP6: Type = 132;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TOS: Type = 133;
    pub const RTE_ETH_INPUT_SET_L3_IP4_PROTO: Type = 134;
    pub const RTE_ETH_INPUT_SET_L3_IP6_TC: Type = 135;
    pub const RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: Type = 136;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TTL: Type = 137;
    pub const RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: Type = 138;
    pub const RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: Type = 257;
    pub const RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: Type = 258;
    pub const RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: Type = 259;
    pub const RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: Type = 260;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: Type = 261;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: Type = 262;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG: Type = 263;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC: Type = 385;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC: Type = 386;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: Type = 387;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: Type = 388;
    pub const RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: Type = 389;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: Type = 641;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: Type = 642;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: Type = 643;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: Type = 644;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: Type = 645;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: Type = 646;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: Type = 647;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: Type = 648;
    pub const RTE_ETH_INPUT_SET_DEFAULT: Type = 65533;
    pub const RTE_ETH_INPUT_SET_NONE: Type = 65534;
    pub const RTE_ETH_INPUT_SET_MAX: Type = 65535;
}
pub mod rte_filter_input_set_op {
    #[doc = " Filters input set operations"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_INPUT_SET_OP_UNKNOWN: Type = 0;
    #[doc = "< select input set"]
    pub const RTE_ETH_INPUT_SET_SELECT: Type = 1;
    #[doc = "< add input set entry"]
    pub const RTE_ETH_INPUT_SET_ADD: Type = 2;
    pub const RTE_ETH_INPUT_SET_OP_MAX: Type = 3;
}
#[doc = " A structure used to define the input set configuration for"]
#[doc = " flow director and hash filters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field::Type; 128usize],
    pub op: rte_filter_input_set_op::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_input_set_conf>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_input_set_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).inset_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(inset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).op as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(op)
        )
    );
}
impl Default for rte_eth_input_set_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_flow>())).ether_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_flow),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv4_flow>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).tos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).ttl as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv4_flow>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).verify_tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv6_flow>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).tc as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_eth_ipv6_flow), "::", stringify!(tc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).proto as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).hop_limits as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(hop_limits)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv6_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).verify_tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_vlan_flow>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_vlan_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_vlan_flow>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_vlan_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
pub mod rte_eth_fdir_tunnel_type {
    #[doc = " Tunnel type for flow director."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_FDIR_TUNNEL_TYPE_UNKNOWN: Type = 0;
    pub const RTE_FDIR_TUNNEL_TYPE_NVGRE: Type = 1;
    pub const RTE_FDIR_TUNNEL_TYPE_VXLAN: Type = 2;
}
#[doc = " A structure used to define the input for tunnel flow, now it's VxLAN or"]
#[doc = " NVGRE"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type::Type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_eth_tunnel_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An union contains the inputs for all types of flow"]
#[doc = " Items in flows need to be in big endian"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).l2_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(l2_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ip4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ip4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ipv6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ipv6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).mac_vlan_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(mac_vlan_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tunnel_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tunnel_flow)
        )
    );
}
impl Default for rte_eth_fdir_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow_ext>(),
        22usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow_ext>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).flexbytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(flexbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).is_vf as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).dst_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(dst_id)
        )
    );
}
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_input>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_input>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_ext)
        )
    );
}
impl Default for rte_eth_fdir_input {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_fdir_behavior {
    #[doc = " Behavior will be taken if FDIR match"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_FDIR_ACCEPT: Type = 0;
    pub const RTE_ETH_FDIR_REJECT: Type = 1;
    pub const RTE_ETH_FDIR_PASSTHRU: Type = 2;
}
pub mod rte_eth_fdir_status {
    #[doc = " Flow director report status"]
    #[doc = " It defines what will be reported if FDIR entry is matched."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Report nothing."]
    pub const RTE_ETH_FDIR_NO_REPORT_STATUS: Type = 0;
    #[doc = "< Only report FD ID."]
    pub const RTE_ETH_FDIR_REPORT_ID: Type = 1;
    #[doc = "< Report FD ID and 4 flex bytes."]
    pub const RTE_ETH_FDIR_REPORT_ID_FLEX_4: Type = 2;
    #[doc = "< Report 8 flex bytes."]
    pub const RTE_ETH_FDIR_REPORT_FLEX_8: Type = 3;
}
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior::Type,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status::Type,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_action>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).rx_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).behavior as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).report_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(report_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).flex_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(flex_off)
        )
    );
}
impl Default for rte_eth_fdir_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to define the flow director filter entry by filter_ctrl API."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter>(),
        92usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).soft_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(soft_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).input as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).action as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(action)
        )
    );
}
impl Default for rte_eth_fdir_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "  A structure used to configure FDIR masks that are used by the device"]
#[doc = "  to match the various fields of RX packet headers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit mask for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the"]
    #[doc = "first byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,"]
    #[doc = "0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_masks>(),
        68usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_masks>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).vlan_tci_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(vlan_tci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv4_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv4_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv6_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv6_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).src_port_mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).dst_port_mask as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).mac_addr_byte_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(mac_addr_byte_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_id_mask as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_id_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_type_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_type_mask)
        )
    );
}
pub mod rte_eth_payload_type {
    #[doc = " Payload type"]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_PAYLOAD_UNKNOWN: Type = 0;
    pub const RTE_ETH_RAW_PAYLOAD: Type = 1;
    pub const RTE_ETH_L2_PAYLOAD: Type = 2;
    pub const RTE_ETH_L3_PAYLOAD: Type = 3;
    pub const RTE_ETH_L4_PAYLOAD: Type = 4;
    pub const RTE_ETH_PAYLOAD_MAX: Type = 8;
}
#[doc = " A structure used to select bytes extracted from the protocol layers to"]
#[doc = " flexible payload for filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type::Type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_payload_cfg>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_payload_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).src_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(src_offset)
        )
    );
}
impl Default for rte_eth_flex_payload_cfg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to define FDIR masks for flexible payload"]
#[doc = " for each flow type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_mask>(),
        18usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_mask>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).mask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(mask)
        )
    );
}
#[doc = " A structure used to define all flexible payload related setting"]
#[doc = " include flex payload and flex mask"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 24usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_conf>(),
        724usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_payloads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_payloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_flexmasks as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_flexmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_mask as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_mask)
        )
    );
}
impl Default for rte_eth_fdir_flex_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_fdir_mode {
    #[doc = "  Flow Director setting modes: none, signature or perfect."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Disable FDIR support."]
    pub const RTE_FDIR_MODE_NONE: Type = 0;
    #[doc = "< Enable FDIR signature filter mode."]
    pub const RTE_FDIR_MODE_SIGNATURE: Type = 1;
    #[doc = "< Enable FDIR perfect filter mode."]
    pub const RTE_FDIR_MODE_PERFECT: Type = 2;
    #[doc = "< Enable FDIR filter mode - MAC VLAN."]
    pub const RTE_FDIR_MODE_PERFECT_MAC_VLAN: Type = 3;
    #[doc = "< Enable FDIR filter mode - tunnel."]
    pub const RTE_FDIR_MODE_PERFECT_TUNNEL: Type = 4;
}
#[doc = " A structure used to get the information of flow director filter."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation."]
#[doc = " It includes the mode, flexible payload configuration information,"]
#[doc = " capabilities and supported flow types, flexible payload characters."]
#[doc = " It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode::Type,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u64; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex"]
    #[doc = "payload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments."]
    #[doc = "Each segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that"]
    #[doc = "src_offset[i] in struct rte_eth_flex_payload_cfg should be less"]
    #[doc = "than this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a"]
    #[doc = "multiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_info>(),
        840usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).guarant_spc as *const _ as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(guarant_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).best_spc as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(best_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flow_types_mask as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flow_types_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flexpayload as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flexpayload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_unit as *const _ as usize },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_payload_segment_num as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_payload_segment_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_limit as *const _ as usize },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_bitmask_unit as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_bitmask_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_bitmask_num as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_bitmask_num)
        )
    );
}
impl Default for rte_eth_fdir_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to define the statistics of flow director."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_stats>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).collision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(collision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).free as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).add as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_add as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).guarant_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(guarant_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).best_cnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(best_cnt)
        )
    );
}
pub mod rte_fdir_pballoc_type {
    #[doc = "  Memory space that can be configured to store Flow Director filters"]
    #[doc = "  in the board memory."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< 64k."]
    pub const RTE_FDIR_PBALLOC_64K: Type = 0;
    #[doc = "< 128k."]
    pub const RTE_FDIR_PBALLOC_128K: Type = 1;
    #[doc = "< 256k."]
    pub const RTE_FDIR_PBALLOC_256K: Type = 2;
}
pub mod rte_fdir_status_mode {
    #[doc = "  Select report mode of FDIR hash information in RX descriptors."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Never report FDIR hash."]
    pub const RTE_FDIR_NO_REPORT_STATUS: Type = 0;
    #[doc = "< Only report FDIR hash for matching pkts."]
    pub const RTE_FDIR_REPORT_STATUS: Type = 1;
    #[doc = "< Always report FDIR hash."]
    pub const RTE_FDIR_REPORT_STATUS_ALWAYS: Type = 2;
}
#[doc = " A structure used to configure the Flow Director (FDIR) feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " If mode is RTE_FDIR_MODE_NONE, the pballoc value is ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_fdir_conf {
    #[doc = "< Flow Director mode."]
    pub mode: rte_fdir_mode::Type,
    #[doc = "< Space for FDIR filters."]
    pub pballoc: rte_fdir_pballoc_type::Type,
    #[doc = "< How to report FDIR hash."]
    pub status: rte_fdir_status_mode::Type,
    #[doc = " RX queue of packets matching a \"drop\" filter in perfect mode."]
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_fdir_conf>(),
        808usize,
        concat!("Size of: ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fdir_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mode as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).pballoc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(pballoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).status as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).drop_queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(drop_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mask as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_fdir_conf), "::", stringify!(mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).flex_conf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(flex_conf)
        )
    );
}
impl Default for rte_fdir_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " UDP tunneling configuration."]
#[doc = " Used to config the UDP port for a type of tunnel."]
#[doc = " NICs need the UDP port to identify the tunnel type."]
#[doc = " Normally a type of tunnel has a default UDP port, this structure can be used"]
#[doc = " in case if the users want to change or support more UDP port."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. Defined in rte_eth_tunnel_type."]
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udp_tunnel>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udp_tunnel>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).udp_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).prot_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(prot_type)
        )
    );
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_intr_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_conf))
    );
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port."]
#[doc = " Depending upon the RX multi-queue mode, extra advanced"]
#[doc = " configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of ETH_LINK_SPEED_XXX of speeds to be"]
    #[doc = "used. ETH_LINK_SPEED_FIXED disables link"]
    #[doc = "autonegotiation, and a unique speed shall be"]
    #[doc = "set. Otherwise, the bitmap defines the set of"]
    #[doc = "speeds to be advertised. If the special value"]
    #[doc = "ETH_LINK_SPEED_AUTONEG (0) is used, all speeds"]
    #[doc = "supported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port RX configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port TX configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value"]
    #[doc = "is 0, meaning the loopback mode is disabled."]
    #[doc = "Read the datasheet of given ethernet controller"]
    #[doc = "for details. The possible values of this field"]
    #[doc = "are defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port RX filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port TX DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC"]
    #[doc = "is needed,and the variable must be set ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< FDIR configuration. DEPRECATED"]
    pub fdir_conf: rte_fdir_conf,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2120usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).rss_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_dcb_conf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).dcb_rx_conf as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_rx_conf as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_dcb_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).dcb_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_tx_conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        3080usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).link_speeds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rxmode as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_eth_conf), "::", stringify!(rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).txmode as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_eth_conf), "::", stringify!(txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).lpbk_mode as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rx_adv_conf as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).tx_adv_conf as *const _ as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).dcb_capability_en as *const _ as usize },
        2260usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).fdir_conf as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(fdir_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).intr_conf as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
impl Default for rte_eth_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Preferred Rx/Tx port parameters."]
#[doc = " There are separate instances of this structure for transmission"]
#[doc = " and reception respectively."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_portconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_portconf>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_portconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).burst_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(burst_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).ring_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).nb_queues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(nb_queues)
        )
    );
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain id"]
    pub domain_id: u16,
    pub port_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_switch_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_switch_info>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_switch_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).domain_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).port_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(port_id)
        )
    );
}
impl Default for rte_eth_switch_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this structure may change without prior notice."]
#[doc = ""]
#[doc = " Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg_capa() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg_capa>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg_capa))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg_capa>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg_capa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_capa>())).max_nseg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_capa),
            "::",
            stringify!(max_nseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxseg_capa>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_capa),
            "::",
            stringify!(reserved)
        )
    );
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to retrieve the contextual information of"]
#[doc = " an Ethernet device, such as the controlling driver of the"]
#[doc = " device, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none."]
    #[doc = "Use if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = "< Minimum size of RX buffer."]
    pub min_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of RX pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of RX queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of TX queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    #[doc = " Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default RX configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default TX configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDQ pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDQ pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDQ pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< RX descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< TX descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a"]
    #[doc = " embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        344usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).driver_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).if_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_mtu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mtu as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_rx_bufsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_pktlen as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_lro_pkt_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_queues as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_tx_queues as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mac_addrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_hash_mac_addrs as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vfs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vmdq_pools as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_seg_capa as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_seg_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_offload_capa as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_offload_capa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_queue_offload_capa as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_queue_offload_capa as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reta_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).hash_key_size as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).flow_type_rss_offloads as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxconf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txconf as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_base as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_num as *const _ as usize },
        242usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_pool_base as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_desc_lim as *const _ as usize },
        246usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_desc_lim as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).speed_capa as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_rx_queues as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_tx_queues as *const _ as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxportconf as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txportconf as *const _ as usize },
        282usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_capa as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).switch_info as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(switch_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reserved_64s as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reserved_ptrs as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Ethernet device RX queue information structure."]
#[doc = " Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets RX supported."]
    pub scattered_rx: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    #[doc = "< hardware receive buffer size."]
    pub rx_buf_size: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxq_info>(),
        128usize,
        concat!("Size of: ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).mp as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_rxq_info), "::", stringify!(mp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).scattered_rx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(scattered_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).nb_desc as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(nb_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).rx_buf_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(rx_buf_size)
        )
    );
}
impl Default for rte_eth_rxq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Ethernet device TX queue information structure."]
#[doc = " Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).nb_desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
impl Default for rte_eth_txq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Ethernet device RX/TX queue packet burst mode information structure."]
#[doc = " Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_rte_eth_burst_mode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_burst_mode>(),
        1032usize,
        concat!("Size of: ", stringify!(rte_eth_burst_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_burst_mode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_burst_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_burst_mode>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_burst_mode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_burst_mode>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_burst_mode),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_burst_mode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " An Ethernet device extended statistic structure"]
#[doc = ""]
#[doc = " This structure is used by rte_eth_xstats_get() to provide"]
#[doc = " statistics that are not provided in the generic *rte_eth_stats*"]
#[doc = " structure."]
#[doc = " It maps a name id, corresponding to an index in the array returned"]
#[doc = " by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_xstat), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).value as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_eth_xstat), "::", stringify!(value))
    );
}
#[doc = " A name element for extended statistics."]
#[doc = ""]
#[doc = " An array of this structure is returned by rte_eth_xstats_get_names()."]
#[doc = " It lists the names of extended statistics for a PMD. The *rte_eth_xstat*"]
#[doc = " structure references these names by their array index."]
#[doc = ""]
#[doc = " The xstats should follow a common naming scheme."]
#[doc = " Some names are standardized in rte_stats_strings."]
#[doc = " Examples:"]
#[doc = "     - rx_missed_errors"]
#[doc = "     - tx_q3_bytes"]
#[doc = "     - tx_size_128_to_255_packets"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat_name>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat_name>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat_name>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat_name),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_xstat_name {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to get the information of queue and"]
#[doc = " TC mapping on both TX and RX paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u16,
    pub nb_queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).nb_queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u16,
    pub nb_queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).nb_queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>(),
        4096usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_rxq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_rxq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_txq as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_txq)
        )
    );
}
impl Default for rte_eth_dcb_tc_queue_mapping {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A structure used to get the information of DCB."]
#[doc = " It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< TX BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_info>(),
        4114usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_info>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).prio_tc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_bws as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_bws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_queue as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_queue)
        )
    );
}
impl Default for rte_eth_dcb_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_fec_mode {
    #[doc = " This enum indicates the possible Forward Error Correction (FEC) modes"]
    #[doc = " of an ethdev port."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< FEC is off"]
    pub const RTE_ETH_FEC_NOFEC: Type = 0;
    #[doc = "< FEC autonegotiation modes"]
    pub const RTE_ETH_FEC_AUTO: Type = 1;
    #[doc = "< FEC using common algorithm"]
    pub const RTE_ETH_FEC_BASER: Type = 2;
    #[doc = "< FEC using RS algorithm"]
    pub const RTE_ETH_FEC_RS: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fec_capa {
    #[doc = "< Link speed (see ETH_SPEED_NUM_*)"]
    pub speed: u32,
    #[doc = "< FEC capabilities bitmask"]
    pub capa: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fec_capa() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fec_capa>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_fec_capa))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fec_capa>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fec_capa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fec_capa>())).speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fec_capa),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fec_capa>())).capa as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fec_capa),
            "::",
            stringify!(capa)
        )
    );
}
#[doc = " Function type used for RX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on RX with a burst of packets that have"]
#[doc = " been received on the given port and queue."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which RX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to receive the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that have just been received."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param max_pkts"]
#[doc = "   The max number of packets that can be stored in the \"pkts\" array."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for TX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on TX with a burst of packets immediately"]
#[doc = " before the packets are put onto the hardware queue for transmission."]
#[doc = ""]
#[doc = " @param port_id"]
#[doc = "   The Ethernet port on which TX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to transmit the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that are about to be transmitted."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
pub mod rte_eth_dev_state {
    #[doc = " Possible states of an ethdev port."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Device is unused before being probed."]
    pub const RTE_ETH_DEV_UNUSED: Type = 0;
    #[doc = " Device is attached when allocated in probing."]
    pub const RTE_ETH_DEV_ATTACHED: Type = 1;
    #[doc = " Device is in removed state when plug-out is detected."]
    pub const RTE_ETH_DEV_REMOVED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_sriov>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_sriov>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).nb_q_per_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(nb_q_per_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_vmdq_idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_vmdq_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_pool_q_idx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_pool_q_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_owner() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_owner>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_owner>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev_owner), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_dev_owner {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The id of the next possible valid owned port."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = "  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports."]
    #[doc = " @return"]
    #[doc = "   Next valid port id owned by owner_id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The id of the next possible valid port."]
    #[doc = " @return"]
    #[doc = "   Next valid port id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Iterates over ethdev ports of a specified device."]
    #[doc = ""]
    #[doc = " @param port_id_start"]
    #[doc = "   The id of the next possible valid port."]
    #[doc = " @param parent"]
    #[doc = "   The generic device behind the ports to iterate."]
    #[doc = " @return"]
    #[doc = "   Next port id of the device, possibly port_id_start,"]
    #[doc = "   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_of(port_id_start: u16, parent: *const rte_device) -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Iterates over sibling ethdev ports (i.e. sharing the same rte_device)."]
    #[doc = ""]
    #[doc = " @param port_id_start"]
    #[doc = "   The id of the next possible valid sibling port."]
    #[doc = " @param ref_port_id"]
    #[doc = "   The id of a reference port to compare rte_device with."]
    #[doc = " @return"]
    #[doc = "   Next sibling port id, possibly port_id_start or ref_port_id itself,"]
    #[doc = "   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_sibling(port_id_start: u16, ref_port_id: u16) -> u16;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get a new unique owner identifier."]
    #[doc = " An owner identifier is used to owns Ethernet devices by only one DPDK entity"]
    #[doc = " to avoid multiple management of device by different entities."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "   Owner identifier pointer."]
    #[doc = " @return"]
    #[doc = "   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Set an Ethernet device owner."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of the port to own."]
    #[doc = " @param\towner"]
    #[doc = "  The owner pointer."]
    #[doc = " @return"]
    #[doc = "  Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_set(port_id: u16, owner: *const rte_eth_dev_owner) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Unset Ethernet device owner to make the device ownerless."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The identifier of port to make ownerless."]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Remove owner from all Ethernet devices owned by a specific owner."]
    #[doc = ""]
    #[doc = " @param\towner_id"]
    #[doc = "  The owner identifier."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_delete(owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get the owner of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param\tport_id"]
    #[doc = "  The port identifier."]
    #[doc = " @param\towner"]
    #[doc = "  The owner structure pointer to fill."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative errno value on error.."]
    pub fn rte_eth_dev_owner_get(port_id: u16, owner: *mut rte_eth_dev_owner) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of ports which are usable for the application."]
    #[doc = ""]
    #[doc = " These devices must be iterated by using the macro"]
    #[doc = " ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``"]
    #[doc = " to deal with non-contiguous ranges of devices."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    #[doc = " Get the total number of ports which are allocated."]
    #[doc = ""]
    #[doc = " Some devices may not be available for the application."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The total count of Ethernet devices."]
    pub fn rte_eth_dev_count_total() -> u16;
}
extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in"]
    #[doc = " the bitmap link_speeds of the struct rte_eth_conf"]
    #[doc = ""]
    #[doc = " @param speed"]
    #[doc = "   Numerical speed value in Mbps"]
    #[doc = " @param duplex"]
    #[doc = "   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)"]
    #[doc = " @return"]
    #[doc = "   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = " Get DEV_RX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get DEV_TX_OFFLOAD_* flag name."]
    #[doc = ""]
    #[doc = " @param offload"]
    #[doc = "   Offload flag."]
    #[doc = " @return"]
    #[doc = "   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Configure an Ethernet device."]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " Ethernet API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device to configure."]
    #[doc = " @param nb_rx_queue"]
    #[doc = "   The number of receive queues to set up for the Ethernet device."]
    #[doc = " @param nb_tx_queue"]
    #[doc = "   The number of transmit queues to set up for the Ethernet device."]
    #[doc = " @param eth_conf"]
    #[doc = "   The pointer to the configuration data to be used for the Ethernet device."]
    #[doc = "   The *rte_eth_conf* structure includes:"]
    #[doc = "     -  the hardware offload features to activate, with dedicated fields for"]
    #[doc = "        each statically configurable offload hardware feature provided by"]
    #[doc = "        Ethernet devices, such as IP checksum or VLAN tag stripping for"]
    #[doc = "        example."]
    #[doc = "        The Rx offload bitfield API is obsolete and will be deprecated."]
    #[doc = "        Applications should set the ignore_bitfield_offloads bit on *rxmode*"]
    #[doc = "        structure and use offloads field to set per-port offloads instead."]
    #[doc = "     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within"]
    #[doc = "        the [rt]x_offload_capa returned from rte_eth_dev_info_get()."]
    #[doc = "        Any type of device supported offloading set in the input argument"]
    #[doc = "        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled"]
    #[doc = "        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()"]
    #[doc = "     -  the Receive Side Scaling (RSS) configuration when using multiple RX"]
    #[doc = "        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf"]
    #[doc = "        must be within the flow_type_rss_offloads provided by drivers via"]
    #[doc = "        rte_eth_dev_info_get() API."]
    #[doc = ""]
    #[doc = "   Embedding all configuration information in a single data structure"]
    #[doc = "   is the more flexible method that allows the addition of new features"]
    #[doc = "   without changing the syntax of the API."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Check if an Ethernet device was physically removed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   1 when the Ethernet device is removed, otherwise 0."]
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function allocates a contiguous block of memory for *nb_rx_desc*"]
    #[doc = " receive descriptors from a memory zone associated with *socket_id*"]
    #[doc = " and initializes each receive descriptor with a network buffer allocated"]
    #[doc = " from the memory pool *mb_pool*."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the receive descriptors of the ring."]
    #[doc = " @param rx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the receive queue."]
    #[doc = "   NULL value is allowed, in which case default RX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *rx_conf* structure contains an *rx_thresh* structure with the values"]
    #[doc = "   of the Prefetch, Host, and Write-Back threshold registers of the receive"]
    #[doc = "   ring."]
    #[doc = "   In addition it contains the hardware offloads features to activate using"]
    #[doc = "   the DEV_RX_OFFLOAD_* flags."]
    #[doc = "   If an offloading set in rx_conf->offloads"]
    #[doc = "   hasn't been set in the input argument eth_conf->rxmode.offloads"]
    #[doc = "   to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "   per-queue type and it is enabled for the queue."]
    #[doc = "   No need to repeat any bit in rx_conf->offloads which has already been"]
    #[doc = "   enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "   at port level can't be disabled at queue level."]
    #[doc = "   The configuration structure also contains the pointer to the array"]
    #[doc = "   of the receiving buffer segment descriptions, see rx_seg and rx_nseg"]
    #[doc = "   fields, this extended configuration might be used by split offloads like"]
    #[doc = "   RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT. If mp_pool is not NULL,"]
    #[doc = "   the extended configuration fields must be set to NULL and zero."]
    #[doc = " @param mb_pool"]
    #[doc = "   The pointer to the memory pool from which to allocate *rte_mbuf* network"]
    #[doc = "   memory buffers to populate each descriptor of the receive ring. There are"]
    #[doc = "   two options to provide Rx buffer configuration:"]
    #[doc = "   - single pool:"]
    #[doc = "     mb_pool is not NULL, rx_conf.rx_nseg is 0."]
    #[doc = "   - multiple segments description:"]
    #[doc = "     mb_pool is NULL, rx_conf.rx_seg is not NULL, rx_conf.rx_nseg is not 0."]
    #[doc = "     Taken only if flag RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT is set in offloads."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success, receive queue correctly set up."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The memory pool pointer is null or the size of network buffers"]
    #[doc = "      which can be allocated from this memory pool does not fit the various"]
    #[doc = "      buffer sizes allowed by the device controller."]
    #[doc = "   - -ENOMEM: Unable to allocate the receive ring descriptors or to"]
    #[doc = "      allocate network memory buffers from the memory pool when"]
    #[doc = "      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Allocate and set up a hairpin receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function set up the selected queue to be used in hairpin."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = "   0 means the PMD will use default value."]
    #[doc = " @param conf"]
    #[doc = "   The pointer to the hairpin configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_rx_hairpin_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the transmit descriptors of the ring."]
    #[doc = " @param tx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the transmit queue."]
    #[doc = "   NULL value is allowed, in which case default TX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *tx_conf* structure contains the following data:"]
    #[doc = "   - The *tx_thresh* structure with the values of the Prefetch, Host, and"]
    #[doc = "     Write-Back threshold registers of the transmit ring."]
    #[doc = "     When setting Write-Back threshold to the value greater then zero,"]
    #[doc = "     *tx_rs_thresh* value should be explicitly set to one."]
    #[doc = "   - The *tx_free_thresh* value indicates the [minimum] number of network"]
    #[doc = "     buffers that must be pending in the transmit ring to trigger their"]
    #[doc = "     [implicit] freeing by the driver transmit function."]
    #[doc = "   - The *tx_rs_thresh* value indicates the [minimum] number of transmit"]
    #[doc = "     descriptors that must be pending in the transmit ring before setting the"]
    #[doc = "     RS bit on a descriptor by the driver transmit function."]
    #[doc = "     The *tx_rs_thresh* value should be less or equal then"]
    #[doc = "     *tx_free_thresh* value, and both of them should be less then"]
    #[doc = "     *nb_tx_desc* - 3."]
    #[doc = "   - The *offloads* member contains Tx offloads to be enabled."]
    #[doc = "     If an offloading set in tx_conf->offloads"]
    #[doc = "     hasn't been set in the input argument eth_conf->txmode.offloads"]
    #[doc = "     to rte_eth_dev_configure(), it is a new added offloading, it must be"]
    #[doc = "     per-queue type and it is enabled for the queue."]
    #[doc = "     No need to repeat any bit in tx_conf->offloads which has already been"]
    #[doc = "     enabled in rte_eth_dev_configure() at port level. An offloading enabled"]
    #[doc = "     at port level can't be disabled at queue level."]
    #[doc = ""]
    #[doc = "     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces"]
    #[doc = "     the transmit function to use default values."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is correctly set up."]
    #[doc = "   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Allocate and set up a transmit hairpin queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = "   0 to set default PMD value."]
    #[doc = " @param conf"]
    #[doc = "   The hairpin configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_tx_hairpin_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get all the hairpin peer Rx / Tx ports of the current port."]
    #[doc = " The caller should ensure that the array is large enough to save the ports"]
    #[doc = " list."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param peer_ports"]
    #[doc = "   Pointer to the array to store the peer ports list."]
    #[doc = " @param len"]
    #[doc = "   Length of the array to store the port identifiers."]
    #[doc = " @param direction"]
    #[doc = "   Current port to peer port direction"]
    #[doc = "   positive - current used as Tx to get all peer Rx ports."]
    #[doc = "   zero - current used as Rx to get all peer Tx ports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0 or positive) actual peer ports number."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-ENODEV) if *port_id* invalid"]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMD drivers."]
    pub fn rte_eth_hairpin_get_peer_ports(
        port_id: u16,
        peer_ports: *mut u16,
        len: usize,
        direction: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Bind all hairpin Tx queues of one port to the Rx queues of the peer port."]
    #[doc = " It is only allowed to call this function after all hairpin queues are"]
    #[doc = " configured properly and the devices are in started state."]
    #[doc = ""]
    #[doc = " @param tx_port"]
    #[doc = "   The identifier of the Tx port."]
    #[doc = " @param rx_port"]
    #[doc = "   The identifier of peer Rx port."]
    #[doc = "   RTE_MAX_ETHPORTS is allowed for the traversal of all devices."]
    #[doc = "   Rx port ID could have the same value as Tx port ID."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if Tx port ID is invalid."]
    #[doc = "   - (-EBUSY) if device is not in started state."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMD drivers."]
    pub fn rte_eth_hairpin_bind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Unbind all hairpin Tx queues of one port from the Rx queues of the peer port."]
    #[doc = " This should be called before closing the Tx or Rx devices, if the bind"]
    #[doc = " function is called before."]
    #[doc = " After unbinding the hairpin ports pair, it is allowed to bind them again."]
    #[doc = " Changing queues configuration should be after stopping the device(s)."]
    #[doc = ""]
    #[doc = " @param tx_port"]
    #[doc = "   The identifier of the Tx port."]
    #[doc = " @param rx_port"]
    #[doc = "   The identifier of peer Rx port."]
    #[doc = "   RTE_MAX_ETHPORTS is allowed for traversal of all devices."]
    #[doc = "   Rx port ID could have the same value as Tx port ID."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if Tx port ID is invalid."]
    #[doc = "   - (-EBUSY) if device is in stopped state."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - Others detailed errors from PMD drivers."]
    pub fn rte_eth_hairpin_unbind(tx_port: u16, rx_port: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   The NUMA socket id to which the Ethernet device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -1 is returned is the port_id value is out of range."]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if port_id of device is attached"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - 0 if port is out of range or not attached"]
    #[doc = "   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start specified RX queue of a port. It is used when rx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is started."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified RX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is stopped."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start TX for specified queue of a port. It is used when tx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is started."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified TX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is stopped."]
    #[doc = "   - -ENODEV: if *port_id* is invalid."]
    #[doc = "   - -EINVAL: The queue_id out of range or belong to hairpin."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an Ethernet device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the configured"]
    #[doc = " offload features and in starting the transmit and the receive units of the"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before"]
    #[doc = " PMD port start callback function is invoked."]
    #[doc = ""]
    #[doc = " On success, all basic functions exported by the Ethernet API (link status,"]
    #[doc = " receive/transmit, and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device started."]
    #[doc = "   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to"]
    #[doc = " rte_eth_dev_start()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device stopped."]
    #[doc = "   - <0: Error code of the driver device stop function."]
    pub fn rte_eth_dev_stop(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link up an Ethernet device."]
    #[doc = ""]
    #[doc = " Set device link up will re-enable the device rx/tx"]
    #[doc = " functionality after it is previously set device linked down."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device linked up."]
    #[doc = "   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link down an Ethernet device."]
    #[doc = " The device rx/tx functionality will be disabled if success,"]
    #[doc = " and it can be re-enabled with a call to"]
    #[doc = " rte_eth_dev_set_link_up()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!"]
    #[doc = " The function frees all port resources."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - Zero if the port is closed successfully."]
    #[doc = "   - Negative if something went wrong."]
    pub fn rte_eth_dev_close(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a Ethernet device and keep its port id."]
    #[doc = ""]
    #[doc = " When a port has to be reset passively, the DPDK application can invoke"]
    #[doc = " this function. For example when a PF is reset, all its VFs should also"]
    #[doc = " be reset. Normally a DPDK application can invoke this function when"]
    #[doc = " RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start"]
    #[doc = " a port reset in other circumstances."]
    #[doc = ""]
    #[doc = " When this function is called, it first stops the port and then calls the"]
    #[doc = " PMD specific dev_uninit( ) and dev_init( ) to return the port to initial"]
    #[doc = " state, in which no Tx and Rx queues are setup, as if the port has been"]
    #[doc = " reset and not started. The port keeps the port id it had before the"]
    #[doc = " function call."]
    #[doc = ""]
    #[doc = " After calling rte_eth_dev_reset( ), the application should use"]
    #[doc = " rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),"]
    #[doc = " rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )"]
    #[doc = " to reconfigure the device as appropriate."]
    #[doc = ""]
    #[doc = " Note: To avoid unexpected behavior, the application should stop calling"]
    #[doc = " Tx and Rx functions before calling rte_eth_dev_reset( ). For thread"]
    #[doc = " safety, all these controlling functions should be called from the same"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this function."]
    #[doc = "   - (-EPERM) if not ran from the primary process."]
    #[doc = "   - (-EIO) if re-initialisation failed or device is removed."]
    #[doc = "   - (-ENOMEM) if the reset failed due to OOM."]
    #[doc = "   - (-EAGAIN) if the reset temporarily failed and should be retried later."]
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for promiscuous_enable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for promiscuous_disable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if promiscuous is enabled"]
    #[doc = "   - (0) if promiscuous is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for allmulticast_enable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for allmulticast_disable() does not exist"]
    #[doc = "     for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if allmulticast is enabled"]
    #[doc = "   - (0) if allmulticast is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),"]
    #[doc = " the negotiation (auto/fixed), and if available, the speed (Mbps)."]
    #[doc = ""]
    #[doc = " It might need to wait up to 9 seconds."]
    #[doc = " @see rte_eth_link_get_nowait."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   Link information written back."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if the function is not supported in PMD driver."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the link status (up/down), the duplex mode (half/full),"]
    #[doc = " the negotiation (auto/fixed), and if available, the speed (Mbps)."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   Link information written back."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if the function is not supported in PMD driver."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " The function converts a link_speed to a string. It handles all special"]
    #[doc = " values like unknown or none speed."]
    #[doc = ""]
    #[doc = " @param link_speed"]
    #[doc = "   link_speed of rte_eth_link struct"]
    #[doc = " @return"]
    #[doc = "   Link speed in textual format. It's pointer to immutable memory."]
    #[doc = "   No free is required."]
    pub fn rte_eth_link_speed_to_str(link_speed: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " The function converts a rte_eth_link struct representing a link status to"]
    #[doc = " a string."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   A pointer to a string to be filled with textual representation of"]
    #[doc = "   device status. At least ETH_LINK_MAX_STR_LEN bytes should be allocated to"]
    #[doc = "   store default link status text."]
    #[doc = " @param len"]
    #[doc = "   Length of available memory at 'str' string."]
    #[doc = " @param eth_link"]
    #[doc = "   Link status returned by rte_eth_link_get function"]
    #[doc = " @return"]
    #[doc = "   Number of bytes written to str array."]
    pub fn rte_eth_link_to_str(
        str_: *mut ::std::os::raw::c_char,
        len: usize,
        eth_link: *const rte_eth_link,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param stats"]
    #[doc = "   A pointer to a structure of type *rte_eth_stats* to be filled with"]
    #[doc = "   the values of device counters for the following set of statistics:"]
    #[doc = "   - *ipackets* with the total of successfully received packets."]
    #[doc = "   - *opackets* with the total of successfully transmitted packets."]
    #[doc = "   - *ibytes*   with the total of successfully received bytes."]
    #[doc = "   - *obytes*   with the total of successfully transmitted bytes."]
    #[doc = "   - *ierrors*  with the total of erroneous received packets."]
    #[doc = "   - *oerrors*  with the total of failed transmitted packets."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if device notified to reset stats."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (<0): Error code of the driver stats reset function."]
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that 'xstat_names' and 'xstats' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of 'struct rte_eth_xstat':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " There is an assumption that 'xstat_names' and 'xstats' arrays are matched"]
    #[doc = " by array index:"]
    #[doc = "  xstats_names[i].name => xstats[i].value"]
    #[doc = ""]
    #[doc = " And the array index is same with id field of 'struct rte_eth_xstat':"]
    #[doc = "  xstats[i].id == i"]
    #[doc = ""]
    #[doc = " This assumption makes key-value pair matching less flexible but simpler."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats"]
    #[doc = "   A pointer to a table of structure of type *rte_eth_xstat*"]
    #[doc = "   to be filled with device statistics ids and values."]
    #[doc = "   This parameter can be set to NULL if n is 0."]
    #[doc = " @param n"]
    #[doc = "   The size of the xstats array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to n: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than n: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param ids"]
    #[doc = "   IDs array given by app to retrieve specific statistics"]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ids"]
    #[doc = "   A pointer to an ids array passed by application. This tells which"]
    #[doc = "   statistics values function should retrieve. This parameter"]
    #[doc = "   can be set to NULL if size is 0. In this case function will retrieve"]
    #[doc = "   all available statistics."]
    #[doc = " @param values"]
    #[doc = "   A pointer to a table to be filled with device statistics values."]
    #[doc = " @param size"]
    #[doc = "   The size of the ids array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the ID of a statistic from its name."]
    #[doc = ""]
    #[doc = " This function searches for the statistics using string compares, and"]
    #[doc = " as such should not be used on the fast-path. For fast-path retrieval of"]
    #[doc = " specific statistics, store the ID as provided in *id* from this function,"]
    #[doc = " and pass the ID to rte_eth_xstats_get()"]
    #[doc = ""]
    #[doc = " @param port_id The port to look up statistics from"]
    #[doc = " @param xstat_name The name of the statistic to return"]
    #[doc = " @param[out] id A pointer to an app-supplied uint64_t which should be"]
    #[doc = "                set to the ID of the stat if the stat exists."]
    #[doc = " @return"]
    #[doc = "    0 on success"]
    #[doc = "    -ENODEV for invalid port_id,"]
    #[doc = "    -EIO if device is removed,"]
    #[doc = "    -EINVAL if the xstat_name doesn't exist in port_id"]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if device notified to reset extended stats."]
    #[doc = "   - (-ENOTSUP) if pmd doesn't support both"]
    #[doc = "     extended stats and basic stats reset."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (<0): Error code of the driver xstats reset function."]
    pub fn rte_eth_xstats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the transmit"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = "   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the receive"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1]."]
    #[doc = "   Max RTE_ETHDEV_QUEUE_STAT_CNTRS being 256."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   A pointer to a structure of type *ether_addr* to be filled with"]
    #[doc = "   the Ethernet address of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_macaddr_get(port_id: u16, mac_addr: *mut rte_ether_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device."]
    #[doc = ""]
    #[doc = " As part of this function, a number of of fields in dev_info will be"]
    #[doc = " initialized as follows:"]
    #[doc = ""]
    #[doc = " rx_desc_lim = lim"]
    #[doc = " tx_desc_lim = lim"]
    #[doc = ""]
    #[doc = " Where lim is defined within the rte_eth_dev_info_get as"]
    #[doc = ""]
    #[doc = "  const struct rte_eth_desc_lim lim = {"]
    #[doc = "      .nb_max = UINT16_MAX,"]
    #[doc = "      .nb_min = 0,"]
    #[doc = "      .nb_align = 1,"]
    #[doc = "\t.nb_seg_max = UINT16_MAX,"]
    #[doc = "\t.nb_mtu_seg_max = UINT16_MAX,"]
    #[doc = "  };"]
    #[doc = ""]
    #[doc = " device = dev->device"]
    #[doc = " min_mtu = RTE_ETHER_MIN_MTU"]
    #[doc = " max_mtu = UINT16_MAX"]
    #[doc = ""]
    #[doc = " The following fields will be populated if support for dev_infos_get()"]
    #[doc = " exists for the device and the rte_eth_dev 'dev' has been populated"]
    #[doc = " successfully with a call to it:"]
    #[doc = ""]
    #[doc = " driver_name = dev->device->driver->name"]
    #[doc = " nb_rx_queues = dev->data->nb_rx_queues"]
    #[doc = " nb_tx_queues = dev->data->nb_tx_queues"]
    #[doc = " dev_flags = &dev->data->dev_flags"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dev_info"]
    #[doc = "   A pointer to a structure of type *rte_eth_dev_info* to be filled with"]
    #[doc = "   the contextual information of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if support for dev_infos_get() does not exist for the device."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_info_get(port_id: u16, dev_info: *mut rte_eth_dev_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the firmware version of a device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param fw_version"]
    #[doc = "   A pointer to a string array storing the firmware version of a device,"]
    #[doc = "   the string includes terminating null. This pointer is allocated by caller."]
    #[doc = " @param fw_size"]
    #[doc = "   The size of the string array pointed by fw_version, which should be"]
    #[doc = "   large enough to store firmware version of the device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (>0) if *fw_size* is not enough to store firmware version, return"]
    #[doc = "          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device."]
    #[doc = ""]
    #[doc = " When a packet type is announced as supported, it *must* be recognized by"]
    #[doc = " the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = " and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following"]
    #[doc = " packet types for these packets:"]
    #[doc = " - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER"]
    #[doc = " - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = ""]
    #[doc = " When a packet is received by a PMD, the most precise type must be"]
    #[doc = " returned among the ones supported. However a PMD is allowed to set"]
    #[doc = " packet type that is not in the supported list, at the condition that it"]
    #[doc = " is more precise. Therefore, a PMD announcing no supported packet types"]
    #[doc = " can still set a matching packet type in a received packet."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Better to invoke this API after the device is already started or rx burst"]
    #[doc = "   function is decided, to obtain correct supported ptypes."]
    #[doc = " @note"]
    #[doc = "   if a given PMD does not report what ptypes it supports, then the supported"]
    #[doc = "   ptype count is reported as 0."]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   A hint of what kind of packet type which the caller is interested in."]
    #[doc = " @param ptypes"]
    #[doc = "   An array pointer to store adequate packet types, allocated by caller."]
    #[doc = " @param num"]
    #[doc = "  Size of the array pointed by param ptypes."]
    #[doc = " @return"]
    #[doc = "   - (>=0) Number of supported ptypes. If the number of types exceeds num,"]
    #[doc = "           only num entries will be filled into the ptypes array, but the full"]
    #[doc = "           count of supported ptypes will be returned."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Inform Ethernet device about reduced range of packet types to handle."]
    #[doc = ""]
    #[doc = " Application can use this function to set only specific ptypes that it's"]
    #[doc = " interested. This information can be used by the PMD to optimize Rx path."]
    #[doc = ""]
    #[doc = " The function accepts an array `set_ptypes` allocated by the caller to"]
    #[doc = " store the packet types set by the driver, the last element of the array"]
    #[doc = " is set to RTE_PTYPE_UNKNOWN. The size of the `set_ptype` array should be"]
    #[doc = " `rte_eth_dev_get_supported_ptypes() + 1` else it might only be filled"]
    #[doc = " partially."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   The ptype family that application is interested in should be bitwise OR of"]
    #[doc = "   RTE_PTYPE_*_MASK or 0."]
    #[doc = " @param set_ptypes"]
    #[doc = "   An array pointer to store set packet types, allocated by caller. The"]
    #[doc = "   function marks the end of array with RTE_PTYPE_UNKNOWN."]
    #[doc = " @param num"]
    #[doc = "   Size of the array pointed by param ptypes."]
    #[doc = "   Should be rte_eth_dev_get_supported_ptypes() + 1 to accommodate the"]
    #[doc = "   set ptypes."]
    #[doc = " @return"]
    #[doc = "   - (0) if Success."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *ptype_mask* is invalid (or) set_ptypes is NULL and"]
    #[doc = "     num > 0."]
    pub fn rte_eth_dev_set_ptypes(
        port_id: u16,
        ptype_mask: u32,
        set_ptypes: *mut u32,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A pointer to a uint16_t where the retrieved MTU is to be stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A uint16_t for the MTU to be applied."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if *mtu* invalid, validation of mtu can occur within"]
    #[doc = "     rte_eth_dev_set_mtu if dev_infos_get is supported by the device or"]
    #[doc = "     when the mtu is set using dev->dev_ops->mtu_set."]
    #[doc = "   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received"]
    #[doc = " VLAN packets tagged with a given VLAN Tag Identifier."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_id"]
    #[doc = "   The VLAN Tag Identifier whose filtering must be enabled or disabled."]
    #[doc = " @param on"]
    #[doc = "   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = "   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOSYS) if VLAN filtering on *port_id* disabled."]
    #[doc = "   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(port_id: u16, vlan_id: u16, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param on"]
    #[doc = "   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = "   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN stripping not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to"]
    #[doc = " the VLAN header."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_type"]
    #[doc = "   The vlan type."]
    #[doc = " @param tag_type"]
    #[doc = "   The Tag Protocol ID"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN TPID setup is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type::Type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param offload_mask"]
    #[doc = "   The VLAN Offload bit mask can be mixed use with \"OR\""]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "       ETH_QINQ_STRIP_OFFLOAD"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_offload(port_id: u16, offload_mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>0) if successful. Bit mask to indicate"]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "       ETH_QINQ_STRIP_OFFLOAD"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set port based TX VLAN insertion on or off."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param pvid"]
    #[doc = "  Port based TX VLAN identifier together with user priority."]
    #[doc = " @param on"]
    #[doc = "  Turn on or off the port based TX VLAN insertion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(port_id: u16, pvid: u16, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(unsent: *mut *mut rte_mbuf, count: u16, userdata: *mut ::std::os::raw::c_void),
>;
#[doc = " Structure used to buffer packets for future TX"]
#[doc = " Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_tx_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_tx_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_tx_buffer>())).error_callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_tx_buffer),
            "::",
            stringify!(error_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_tx_buffer>())).error_userdata as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_tx_buffer),
            "::",
            stringify!(error_userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_tx_buffer>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_tx_buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_tx_buffer>())).length as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_tx_buffer),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_tx_buffer>())).pkts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_tx_buffer),
            "::",
            stringify!(pkts)
        )
    );
}
impl Default for rte_eth_dev_tx_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Initialize default values for buffered transmitting"]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   Tx buffer to be initialized."]
    #[doc = " @param size"]
    #[doc = "   Buffer size"]
    #[doc = " @return"]
    #[doc = "   0 if no error"]
    pub fn rte_eth_tx_buffer_init(buffer: *mut rte_eth_dev_tx_buffer, size: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent"]
    #[doc = ""]
    #[doc = " Register a specific callback to be called when an attempt is made to send"]
    #[doc = " all packets buffered on an ethernet port, but not all packets can"]
    #[doc = " successfully be sent. The callback registered here will be called only"]
    #[doc = " from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs."]
    #[doc = " The default callback configured for each queue by default just frees the"]
    #[doc = " packets back to the calling mempool. If additional behaviour is required,"]
    #[doc = " for example, to count dropped packets, or to retry transmission of packets"]
    #[doc = " which cannot be sent, this function should be used to register a suitable"]
    #[doc = " callback function to implement the desired behaviour."]
    #[doc = " The example callback \"rte_eth_count_unsent_packet_callback()\" is also"]
    #[doc = " provided as reference."]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param callback"]
    #[doc = "   The function to be used as the callback."]
    #[doc = " @param userdata"]
    #[doc = "   Arbitrary parameter to be passed to the callback function"]
    #[doc = " @return"]
    #[doc = "   0 on success, or -1 on error with rte_errno set appropriately"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets silently and is used by tx buffered"]
    #[doc = " operations as default behavior."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets, but also updates a user-supplied counter"]
    #[doc = " to track the overall number of packets dropped. The counter should be an"]
    #[doc = " uint64_t variable."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The"]
    #[doc = " driver will only free the mbuf if it is no longer in use. It is the"]
    #[doc = " application's responsibility to ensure rte_eth_tx_buffer_flush(..) is"]
    #[doc = " called if needed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param free_cnt"]
    #[doc = "   Maximum number of packets to free. Use 0 to indicate all possible packets"]
    #[doc = "   should be freed. Note that a packet may be using multiple mbufs."]
    #[doc = " @return"]
    #[doc = "   Failure: < 0"]
    #[doc = "     -ENODEV: Invalid interface"]
    #[doc = "     -EIO: device is removed"]
    #[doc = "     -ENOTSUP: Driver does not support function"]
    #[doc = "   Success: >= 0"]
    #[doc = "     0-n: Number of packets freed. More packets may still remain in ring that"]
    #[doc = "     are in use."]
    pub fn rte_eth_tx_done_cleanup(port_id: u16, queue_id: u16, free_cnt: u32) -> ::std::os::raw::c_int;
}
pub mod rte_eth_event_ipsec_subtype {
    #[doc = " Subtypes for IPsec offload event(@ref RTE_ETH_EVENT_IPSEC) raised by"]
    #[doc = " eth device."]
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_ETH_EVENT_IPSEC_UNKNOWN: Type = 0;
    pub const RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW: Type = 1;
    pub const RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY: Type = 2;
    pub const RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY: Type = 3;
    pub const RTE_ETH_EVENT_IPSEC_MAX: Type = 4;
}
#[doc = " Descriptor for @ref RTE_ETH_EVENT_IPSEC event. Used by eth dev to send extra"]
#[doc = " information of the IPsec offload event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_event_ipsec_desc {
    pub subtype: rte_eth_event_ipsec_subtype::Type,
    pub metadata: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_event_ipsec_desc() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_event_ipsec_desc>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_event_ipsec_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).subtype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).metadata as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(metadata)
        )
    );
}
impl Default for rte_eth_event_ipsec_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_event_type {
    #[doc = " The eth device event type for interrupt, and maybe others in the future."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< unknown event type"]
    pub const RTE_ETH_EVENT_UNKNOWN: Type = 0;
    #[doc = "< lsc interrupt event"]
    pub const RTE_ETH_EVENT_INTR_LSC: Type = 1;
    pub const RTE_ETH_EVENT_QUEUE_STATE: Type = 2;
    pub const RTE_ETH_EVENT_INTR_RESET: Type = 3;
    #[doc = "< message from the VF received by PF"]
    pub const RTE_ETH_EVENT_VF_MBOX: Type = 4;
    #[doc = "< MACsec offload related event"]
    pub const RTE_ETH_EVENT_MACSEC: Type = 5;
    #[doc = "< device removal event"]
    pub const RTE_ETH_EVENT_INTR_RMV: Type = 6;
    #[doc = "< port is probed"]
    pub const RTE_ETH_EVENT_NEW: Type = 7;
    #[doc = "< port is released"]
    pub const RTE_ETH_EVENT_DESTROY: Type = 8;
    #[doc = "< IPsec offload related event"]
    pub const RTE_ETH_EVENT_IPSEC: Type = 9;
    #[doc = "< New aged-out flows is detected"]
    pub const RTE_ETH_EVENT_FLOW_AGED: Type = 10;
    #[doc = "< max value of this enum"]
    pub const RTE_ETH_EVENT_MAX: Type = 11;
}
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register a callback function for port event."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port id."]
    #[doc = "  RTE_ETH_ALL means register the event for all port ids."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a callback function for port event."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port id."]
    #[doc = "  RTE_ETH_ALL means unregister the event for all port ids."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback. -1 means to"]
    #[doc = "  remove all for the same callback address and same event."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When there is no rx packet coming in Rx Queue for a long time, we can"]
    #[doc = " sleep lcore related to RX Queue for power saving, and enable rx interrupt"]
    #[doc = " to be triggered when Rx packet arrives."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_enable() function enables rx queue"]
    #[doc = " interrupt on specific rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When lcore wakes up from rx interrupt indicating packet coming, disable rx"]
    #[doc = " interrupt and returns to polling mode."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_disable() function disables rx queue"]
    #[doc = " interrupt on specific rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RX Interrupt control per port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RX Interrupt control per queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get interrupt fd per Rx queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (>=0) the interrupt fd associated to the requested Rx queue if"]
    #[doc = "           successful."]
    #[doc = "   - (-1) on error."]
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn on the LED on the Ethernet device."]
    #[doc = " This function turns on the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn off the LED on the Ethernet device."]
    #[doc = " This function turns off the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get Forward Error Correction(FEC) capability."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param speed_fec_capa"]
    #[doc = "   speed_fec_capa is out only with per-speed capabilities."]
    #[doc = "   If set to NULL, the function returns the required number"]
    #[doc = "   of required array entries."]
    #[doc = " @param num"]
    #[doc = "   a number of elements in an speed_fec_capa array."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - A non-negative value lower or equal to num: success. The return value"]
    #[doc = "     is the number of entries filled in the fec capa array."]
    #[doc = "   - A non-negative value higher than num: error, the given fec capa array"]
    #[doc = "     is too small. The return value corresponds to the num that should"]
    #[doc = "     be given to succeed. The entries in fec capa array are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "     that operation."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if *num* or *speed_fec_capa* invalid"]
    pub fn rte_eth_fec_get_capability(
        port_id: u16,
        speed_fec_capa: *mut rte_eth_fec_capa,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Get current Forward Error Correction(FEC) mode."]
    #[doc = " If link is down and AUTO is enabled, AUTO is returned, otherwise,"]
    #[doc = " configured FEC mode is returned."]
    #[doc = " If link is up, current FEC mode is returned."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fec_capa"]
    #[doc = "   A bitmask of enabled FEC modes. If AUTO bit is set, other"]
    #[doc = "   bits specify FEC modes which may be negotiated. If AUTO"]
    #[doc = "   bit is clear, specify FEC modes to be used (only one valid"]
    #[doc = "   mode per speed may be set)."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "     that operation."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_get(port_id: u16, fec_capa: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Set Forward Error Correction(FEC) mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fec_capa"]
    #[doc = "   A bitmask of allowed FEC modes. If AUTO bit is set, other"]
    #[doc = "   bits specify FEC modes which may be negotiated. If AUTO"]
    #[doc = "   bit is clear, specify FEC modes to be used (only one valid"]
    #[doc = "   mode per speed may be set)."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-EINVAL) if the FEC mode is not valid."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_fec_set(port_id: u16, fec_capa: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current status of the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure where to store the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EIO)  if device is removed."]
    pub fn rte_eth_dev_flow_ctrl_get(port_id: u16, fc_conf: *mut rte_eth_fc_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure of the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_flow_ctrl_set(port_id: u16, fc_conf: *mut rte_eth_fc_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet priority flow control under DCB environment"]
    #[doc = " for Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = " The port identifier of the Ethernet device."]
    #[doc = " @param pfc_conf"]
    #[doc = " The pointer to the structure of the priority flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support priority flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_priority_flow_ctrl_set(port_id: u16, pfc_conf: *mut rte_eth_pfc_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a MAC address to the set used for filtering incoming packets."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   The MAC address to add."]
    #[doc = " @param pool"]
    #[doc = "   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is"]
    #[doc = "   not enabled, this should be set to 0."]
    #[doc = " @return"]
    #[doc = "   - (0) if successfully added or *mac_addr* was already added."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port* is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOSPC) if no more MAC addresses can be added."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_add(port_id: u16, mac_addr: *mut rte_ether_addr, pool: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a MAC address from the internal array of addresses."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   MAC address to remove."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EADDRINUSE) if attempting to remove the default MAC address"]
    pub fn rte_eth_dev_mac_addr_remove(port_id: u16, mac_addr: *mut rte_ether_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default MAC address."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   New default MAC address."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_default_mac_addr_set(port_id: u16, mac_addr: *mut rte_ether_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to update."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to query. For each requested reta entry, corresponding bit"]
    #[doc = "   in mask must be set."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    #[doc = "   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates unicast hash table for receiving packet with the given destination"]
    #[doc = " MAC address, and the packet is routed to all VFs for which the RX mode is"]
    #[doc = " accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param addr"]
    #[doc = "   Unicast MAC address."]
    #[doc = " @param on"]
    #[doc = "    1 - Set an unicast hash bit for receiving packets with the MAC address."]
    #[doc = "    0 - Clear an unicast hash bit."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_hash_table_set(port_id: u16, addr: *mut rte_ether_addr, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates all unicast hash bitmaps for receiving packet with any Unicast"]
    #[doc = " Ethernet MAC addresses,the packet is routed to all VFs for which the RX"]
    #[doc = " mode is accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param on"]
    #[doc = "    1 - Set all unicast hash bitmaps for receiving all the Ethernet"]
    #[doc = "         MAC addresses"]
    #[doc = "    0 - Clear all unicast hash bitmaps"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a traffic mirroring rule on an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mirror_conf"]
    #[doc = "   The pointer to the traffic mirroring structure describing the mirroring rule."]
    #[doc = "   The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,"]
    #[doc = "   destination pool and the value of rule if enable vlan or pool mirroring."]
    #[doc = ""]
    #[doc = " @param rule_id"]
    #[doc = "   The index of traffic mirroring rule, we support four separated rules."]
    #[doc = " @param on"]
    #[doc = "   1 - Enable a mirroring rule."]
    #[doc = "   0 - Disable a mirroring rule."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if the mr_conf information is not correct."]
    pub fn rte_eth_mirror_rule_set(
        port_id: u16,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a traffic mirroring rule on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rule_id"]
    #[doc = "   The index of traffic mirroring rule, we support four separated rules."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_mirror_rule_reset(port_id: u16, rule_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the rate limitation for a queue on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_idx"]
    #[doc = "   The queue id."]
    #[doc = " @param tx_rate"]
    #[doc = "   The tx rate in Mbps. Allocated from the total port link speed."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_set_queue_rate_limit(port_id: u16, queue_idx: u16, tx_rate: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configuration of Receive Side Scaling hash computation of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   The new configuration to use for RSS hash computation on the port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_update(port_id: u16, rss_conf: *mut rte_eth_rss_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve current configuration of Receive Side Scaling hash computation"]
    #[doc = " of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   Where to store the current RSS hash configuration of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support RSS."]
    pub fn rte_eth_dev_rss_hash_conf_get(port_id: u16, rss_conf: *mut rte_eth_rss_conf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add UDP tunneling port for a specific type of tunnel."]
    #[doc = " The packets with this UDP port will be identified as this type of tunnel."]
    #[doc = " Before enabling any offloading function for a tunnel, users can call this API"]
    #[doc = " to change or add more UDP port for the tunnel. So the offloading function"]
    #[doc = " can take effect on the packets with the specific UDP port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_add(port_id: u16, tunnel_udp: *mut rte_eth_udp_tunnel) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete UDP tunneling port a specific type of tunnel."]
    #[doc = " The packets with this UDP port will not be identified as this type of tunnel"]
    #[doc = " any more."]
    #[doc = " Before enabling any offloading function for a tunnel, users can call this API"]
    #[doc = " to delete a UDP port for the tunnel. So the offloading function will not take"]
    #[doc = " effect on the packets with the specific UDP port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get DCB information on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dcb_info"]
    #[doc = "   dcb information."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    pub fn rte_eth_dev_get_dcb_info(port_id: u16, dcb_info: *mut rte_eth_dcb_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a callback to be called on packet RX on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Add a callback that must be called first on packet RX on a given port"]
    #[doc = " and queue."]
    #[doc = ""]
    #[doc = " This API configures a first function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Add a callback to be called on packet TX on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets sent on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_tx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue. Inter-thread synchronization"]
    #[doc = "   of any user data changes is the responsibility of the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    #[doc = " Remove an RX packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing RX/TX"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete. Alternately, the RCU mechanism can be"]
    #[doc = "   used to detect when data plane threads have ceased referencing the"]
    #[doc = "   callback memory."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a TX packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing RX/TX"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete. Alternately, the RCU mechanism can be"]
    #[doc = "   used to detect when data plane threads have ceased referencing the"]
    #[doc = "   callback memory."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's RX queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The RX queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the queue"]
    #[doc = "               is hairpin queue."]
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's TX queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The TX queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range, or the queue"]
    #[doc = "               is hairpin queue."]
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about the Rx packet burst mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Rx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param mode"]
    #[doc = "   A pointer to a structure of type *rte_eth_burst_mode* to be filled"]
    #[doc = "   with the information of the packet burst mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_rx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about the Tx packet burst mode."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The Tx queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param mode"]
    #[doc = "   A pointer to a structure of type *rte_eth_burst_mode* to be filled"]
    #[doc = "   with the information of the packet burst mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENODEV:  If *port_id* is invalid."]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The queue_id is out of range."]
    pub fn rte_eth_tx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve device registers and register attributes (number of registers and"]
    #[doc = " register size)"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   Pointer to rte_dev_reg_info structure to fill in. If info->data is"]
    #[doc = "   NULL the function fills in the width and length fields. If non-NULL"]
    #[doc = "   the registers are put into the buffer pointed at by the data field."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info(port_id: u16, info: *mut rte_dev_reg_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve size of device EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>=0) EEPROM size if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve EEPROM and EEPROM attribute"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes buffer for return EEPROM data and"]
    #[doc = "   EEPROM attributes to be filled."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom(port_id: u16, info: *mut rte_dev_eeprom_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Program EEPROM with provided data"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes EEPROM data for programming and"]
    #[doc = "   EEPROM attributes to be filled"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_set_eeprom(port_id: u16, info: *mut rte_dev_eeprom_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the type and size of plugin module EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param modinfo"]
    #[doc = "   The type and size of plugin module EEPROM."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_info(port_id: u16, modinfo: *mut rte_eth_dev_module_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Retrieve the data of plugin module EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes the plugin module EEPROM attributes, and the"]
    #[doc = "   buffer for return plugin module EEPROM data."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_eeprom(port_id: u16, info: *mut rte_dev_eeprom_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the list of multicast addresses to filter on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mc_addr_set"]
    #[doc = "   The array of multicast addresses to set. Equal to NULL when the function"]
    #[doc = "   is invoked to flush the set of filtered addresses."]
    #[doc = " @param nb_mc_addr"]
    #[doc = "   The number of multicast addresses in the *mc_addr_set* array. Equal to 0"]
    #[doc = "   when the function is invoked to flush the set of filtered addresses."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EIO) if device is removed."]
    #[doc = "   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering."]
    #[doc = "   - (-ENOSPC) if *port_id* has not enough multicast filtering resources."]
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS RX timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = " @param flags"]
    #[doc = "   Device specific flags. Used to pass the RX timesync register index to"]
    #[doc = "   i40e. Unused in igb/ixgbe, pass 0 instead."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS TX timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_tx_timestamp(port_id: u16, timestamp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param delta"]
    #[doc = "   The adjustment in nanoseconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the time from the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the time of the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -EIO: if device is removed."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_write_time(port_id: u16, time: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Read the current clock counter of an Ethernet device"]
    #[doc = ""]
    #[doc = " This returns the current raw clock value of an Ethernet device. It is"]
    #[doc = " a raw amount of ticks, with no given time reference."]
    #[doc = " The value returned here is from the same clock than the one"]
    #[doc = " filling timestamp field of Rx packets when using hardware timestamp"]
    #[doc = " offload. Therefore it can be used to compute a precise conversion of"]
    #[doc = " the device clock to the real time."]
    #[doc = ""]
    #[doc = " E.g, a simple heuristic to derivate the frequency would be:"]
    #[doc = " uint64_t start, end;"]
    #[doc = " rte_eth_read_clock(port, start);"]
    #[doc = " rte_delay_ms(100);"]
    #[doc = " rte_eth_read_clock(port, end);"]
    #[doc = " double freq = (end - start) * 10;"]
    #[doc = ""]
    #[doc = " Compute a common reference with:"]
    #[doc = " uint64_t base_time_sec = current_time();"]
    #[doc = " uint64_t base_clock;"]
    #[doc = " rte_eth_read_clock(port, base_clock);"]
    #[doc = ""]
    #[doc = " Then, convert the raw mbuf timestamp with:"]
    #[doc = " base_time_sec + (double)(*timestamp_dynfield(mbuf) - base_clock) / freq;"]
    #[doc = ""]
    #[doc = " This simple example will not provide a very good accuracy. One must"]
    #[doc = " at least measure multiple times the frequency and do a regression."]
    #[doc = " To avoid deviation from the system time, the common reference can"]
    #[doc = " be repeated from time to time. The integer division can also be"]
    #[doc = " converted by a multiplication and a shift for better performance."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param clock"]
    #[doc = "   Pointer to the uint64_t that holds the raw clock value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_read_clock(port_id: u16, clock: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the port id from device name. The device name should be specified"]
    #[doc = " as below:"]
    #[doc = " - PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0"]
    #[doc = " - SoC device name, for example- fsl-gmac0"]
    #[doc = " - vdev dpdk name, for example- net_[pcap0|null0|tap0]"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  pci address or name of the device"]
    #[doc = " @param port_id"]
    #[doc = "   pointer to port identifier of the device"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful and port_id is filled."]
    #[doc = "   - (-ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the device name from port id. The device name is specified as below:"]
    #[doc = " - PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0"]
    #[doc = " - SoC device name, for example- fsl-gmac0"]
    #[doc = " - vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the device."]
    #[doc = " @param name"]
    #[doc = "   Buffer of size RTE_ETH_NAME_MAX_LEN to store the name."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* is invalid."]
    #[doc = "   - (-EINVAL) on failure."]
    pub fn rte_eth_dev_get_name_by_port(port_id: u16, name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check that numbers of Rx and Tx descriptors satisfy descriptors limits from"]
    #[doc = " the ethernet device information, otherwise adjust them to boundaries."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of receive"]
    #[doc = "   descriptors stored."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of transmit"]
    #[doc = "   descriptors stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP, -ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if a port supports specific mempool ops."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the Ethernet device."]
    #[doc = " @param [in] pool"]
    #[doc = "   The name of the pool operations to test."]
    #[doc = " @return"]
    #[doc = "   - 0: best mempool ops choice for this port."]
    #[doc = "   - 1: mempool ops are supported for this port."]
    #[doc = "   - -ENOTSUP: mempool ops not supported for this port."]
    #[doc = "   - -ENODEV: Invalid port Identifier."]
    #[doc = "   - -EINVAL: Pool param is null."]
    pub fn rte_eth_dev_pool_ops_supported(port_id: u16, pool: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the security context for the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   Port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - NULL on error."]
    #[doc = "   - pointer to security context on success."]
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change, or be removed, without prior notice"]
    #[doc = ""]
    #[doc = " Query the device hairpin capabilities."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param cap"]
    #[doc = "   Pointer to a structure that will hold the hairpin capabilities."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    pub fn rte_eth_dev_hairpin_capability_get(port_id: u16, cap: *mut rte_eth_hairpin_cap) -> ::std::os::raw::c_int;
}
#[doc = " @file"]
#[doc = ""]
#[doc = " RTE Ethernet Device internal header."]
#[doc = ""]
#[doc = " This header contains internal data types. But they are still part of the"]
#[doc = " public API because they are used by inline functions in the published API."]
#[doc = ""]
#[doc = " Applications should not use these directly."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_cb_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_cb_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_eth_dev_cb_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, rx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16,
>;
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, tx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16,
>;
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, tx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16,
>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int>;
pub type eth_rx_descriptor_status_t =
    ::std::option::Option<unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int>;
pub type eth_tx_descriptor_status_t =
    ::std::option::Option<unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int>;
#[doc = " @internal"]
#[doc = " Structure used to hold information about the callbacks to be called for a"]
#[doc = " queue on RX and TX."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxtx_callback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).rx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).tx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
}
impl Default for rte_eth_rxtx_callback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(param)
        )
    );
}
impl Default for rte_eth_rxtx_callback {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @internal"]
#[doc = " The generic data structure associated with each ethernet device."]
#[doc = ""]
#[doc = " Pointers to burst-oriented packet receive and transmit functions are"]
#[doc = " located at the beginning of the structure, along with the pointer to"]
#[doc = " where all the data elements for the particular device are stored in shared"]
#[doc = " memory. This split allows the function pointer and driver data to be per-"]
#[doc = " process, while the actual configuration data for the device is shared."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    #[doc = "< Pointer to PMD receive function."]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = "< Pointer to PMD transmit function."]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = "< Pointer to PMD transmit prepare function."]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = "< Get the number of used RX descriptors."]
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = "< Check rxd DD bit."]
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    #[doc = "< Check the status of a Rx descriptor."]
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    #[doc = "< Check the status of a Tx descriptor."]
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = "< Pointer to device data."]
    pub data: *mut rte_eth_dev_data,
    #[doc = "< Pointer to per-process device data."]
    pub process_private: *mut ::std::os::raw::c_void,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *mut eth_dev_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = " User application callbacks for NIC interrupts"]
    pub link_intr_cbs: rte_eth_dev_cb_list,
    #[doc = " User-supplied functions called from rx_burst to post-process"]
    #[doc = " received packets before passing them to the user"]
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = " User-supplied functions called from tx_burst to pre-process"]
    #[doc = " received packets before passing them to the driver for transmission."]
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = "< Flag indicating the port state"]
    pub state: rte_eth_dev_state::Type,
    #[doc = "< Context for security ops"]
    pub security_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 4usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev>(),
        16576usize,
        concat!("Size of: ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_pkt_burst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_prepare as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_queue_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_descriptor_done as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_descriptor_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_descriptor_status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_descriptor_status as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).data as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).process_private as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(process_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).dev_ops as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev), "::", stringify!(dev_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).device as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev), "::", stringify!(device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).intr_handle as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(intr_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).link_intr_cbs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(link_intr_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).post_rx_burst_cbs as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(post_rx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).pre_tx_burst_cbs as *const _ as usize },
        8304usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(pre_tx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).state as *const _ as usize },
        16496usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).security_ctx as *const _ as usize },
        16504usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(security_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).reserved_64s as *const _ as usize },
        16512usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).reserved_ptrs as *const _ as usize },
        16544usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " @internal"]
#[doc = " The data part, with no function pointers, associated with each ethernet device."]
#[doc = ""]
#[doc = " This structure is safe to place in shared memory to be common among different"]
#[doc = " processes in a multi-process configuration."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Array of pointers to RX queues."]
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Array of pointers to TX queues."]
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
    #[doc = "< SRIOV data"]
    pub sriov: rte_eth_dev_sriov,
    pub dev_private: *mut ::std::os::raw::c_void,
    #[doc = "< Link-level information & status."]
    pub dev_link: rte_eth_link,
    #[doc = "< Configuration applied to device."]
    pub dev_conf: rte_eth_conf,
    #[doc = "< Maximum Transmission Unit."]
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    #[doc = "< RX ring mbuf allocation failures."]
    pub rx_mbuf_alloc_failed: u64,
    pub mac_addrs: *mut rte_ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    pub hash_mac_addrs: *mut rte_ether_addr,
    #[doc = "< Device [external] port identifier."]
    pub port_id: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rx_queue_state: [u8; 1024usize],
    pub tx_queue_state: [u8; 1024usize],
    #[doc = "< Capabilities."]
    pub dev_flags: u32,
    #[doc = "< NUMA node connection."]
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
    #[doc = "< The port owner."]
    pub owner: rte_eth_dev_owner,
    pub representor_id: u16,
    #[doc = "< rte_flow ops mutex."]
    pub flow_ops_mutex: pthread_mutex_t,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 4usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_data>(),
        7040usize,
        concat!("Size of: ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_data>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queues as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queues as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_rx_queues as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_tx_queues as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).sriov as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(sriov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_private as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_link as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_conf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mtu as *const _ as usize },
        3192usize,
        concat!("Offset of field: ", stringify!(rte_eth_dev_data), "::", stringify!(mtu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).min_rx_buf_size as *const _ as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(min_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_mbuf_alloc_failed as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_mbuf_alloc_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_addrs as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_pool_sel as *const _ as usize },
        3216usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_pool_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).hash_mac_addrs as *const _ as usize },
        4240usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).port_id as *const _ as usize },
        4248usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queue_state as *const _ as usize },
        4251usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queue_state as *const _ as usize },
        5275usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_flags as *const _ as usize },
        6300usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).numa_node as *const _ as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).vlan_filter_conf as *const _ as usize },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(vlan_filter_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).owner as *const _ as usize },
        6824usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).representor_id as *const _ as usize },
        6896usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(representor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).flow_ops_mutex as *const _ as usize },
        6904usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(flow_ops_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).reserved_64s as *const _ as usize },
        6944usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).reserved_ptrs as *const _ as usize },
        6976usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl Default for rte_eth_dev_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
pub mod rte_kni_req_id {
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_KNI_REQ_UNKNOWN: Type = 0;
    pub const RTE_KNI_REQ_CHANGE_MTU: Type = 1;
    pub const RTE_KNI_REQ_CFG_NETWORK_IF: Type = 2;
    pub const RTE_KNI_REQ_CHANGE_MAC_ADDR: Type = 3;
    pub const RTE_KNI_REQ_CHANGE_PROMISC: Type = 4;
    pub const RTE_KNI_REQ_CHANGE_ALLMULTI: Type = 5;
    pub const RTE_KNI_REQ_MAX: Type = 6;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_kni_request {
    #[doc = "< Request id"]
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    #[doc = "< Result for processing request"]
    pub result: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_kni_request__bindgen_ty_1 {
    #[doc = "< New MTU"]
    pub new_mtu: u32,
    #[doc = "< 1: interface up, 0: interface down"]
    pub if_up: u8,
    #[doc = "< MAC address for interface"]
    pub mac_addr: [u8; 6usize],
    #[doc = "< 1: promisc mode enable, 0: disable"]
    pub promiscusity: u8,
    #[doc = "< 1: all-multicast mode enable, 0: disable"]
    pub allmulti: u8,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_rte_kni_request__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).new_mtu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(new_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).if_up as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(if_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).promiscusity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(promiscusity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).allmulti as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(allmulti)
        )
    );
}
impl Default for rte_kni_request__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_kni_request() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_request))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_kni_request))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).req_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(req_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).result as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(result)
        )
    );
}
impl Default for rte_kni_request {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_kni_fifo {
    #[doc = "< Next position to be written"]
    pub write: ::std::os::raw::c_uint,
    #[doc = "< Next position to be read"]
    pub read: ::std::os::raw::c_uint,
    #[doc = "< Circular buffer length"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< Pointer size - for 32/64 bit OS"]
    pub elem_size: ::std::os::raw::c_uint,
    #[doc = "< The buffer contains mbuf pointers"]
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_fifo>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_fifo))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_fifo>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_fifo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_fifo>())).write as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_kni_fifo), "::", stringify!(write))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_fifo>())).read as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_kni_fifo), "::", stringify!(read))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_fifo>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rte_kni_fifo), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_fifo>())).elem_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_fifo),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_fifo>())).buffer as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_kni_fifo), "::", stringify!(buffer))
    );
}
impl Default for rte_kni_fifo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_iova: u64,
    #[doc = "< Start address of data in segment buffer."]
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    #[doc = "< Number of segments."]
    pub nb_segs: u16,
    pub pad4: [::std::os::raw::c_char; 2usize],
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    #[doc = "< Total pkt len: sum of all segment data_len."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    pub pad3: [::std::os::raw::c_char; 14usize],
    pub pool: *mut ::std::os::raw::c_void,
    #[doc = "< Physical address of next mbuf in kernel."]
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_kni_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_kni_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_kni_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_iova as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad1 as *const _ as usize },
        18usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pad1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(nb_segs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad4 as *const _ as usize },
        22usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pad4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad2 as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pad2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pkt_len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad3 as *const _ as usize },
        42usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pad3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pool as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(pool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).next as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rte_kni_mbuf), "::", stringify!(next))
    );
}
impl Default for rte_kni_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_kni_device_info {
    #[doc = "< Network device name for KNI"]
    pub name: [::std::os::raw::c_char; 16usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    #[doc = "< Group ID"]
    pub group_id: u16,
    #[doc = "< core ID to bind for kernel thread"]
    pub core_id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub min_mtu: ::std::os::raw::c_uint,
    pub max_mtu: ::std::os::raw::c_uint,
    pub mac_addr: [u8; 6usize],
    pub iova_mode: u8,
}
#[test]
fn bindgen_test_layout_rte_kni_device_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_device_info>(),
        136usize,
        concat!("Size of: ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).tx_phys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).rx_phys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(rx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).alloc_phys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(alloc_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).free_phys as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(free_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).req_phys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(req_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).resp_phys as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(resp_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_phys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_va as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_va as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_phys as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).group_id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).core_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_size as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mtu as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).min_mtu as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).max_mtu as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mac_addr as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).iova_mode as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(iova_mode)
        )
    );
}
impl Default for rte_kni_device_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni {
    _unused: [u8; 0],
}
#[doc = " Structure which has the function pointers for KNI interface."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_kni_ops {
    pub port_id: u16,
    pub change_mtu: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, new_mtu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int,
    >,
    pub config_network_if:
        ::std::option::Option<unsafe extern "C" fn(port_id: u16, if_up: u8) -> ::std::os::raw::c_int>,
    pub config_mac_address:
        ::std::option::Option<unsafe extern "C" fn(port_id: u16, mac_addr: *mut u8) -> ::std::os::raw::c_int>,
    pub config_promiscusity:
        ::std::option::Option<unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int>,
    pub config_allmulticast:
        ::std::option::Option<unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rte_kni_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_ops>(),
        48usize,
        concat!("Size of: ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).port_id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_kni_ops), "::", stringify!(port_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).change_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(change_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_network_if as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_network_if)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_mac_address as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_mac_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_promiscusity as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_promiscusity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_allmulticast as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_allmulticast)
        )
    );
}
#[doc = " Structure for configuring KNI device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 16usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mac_addr: [u8; 6usize],
    pub mtu: u16,
    pub min_mtu: u16,
    pub max_mtu: u16,
}
#[test]
fn bindgen_test_layout_rte_kni_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_conf>(),
        64usize,
        concat!("Size of: ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).core_id as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(core_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).group_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mbuf_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).addr as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).id as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mac_addr as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mtu as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(mtu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).min_mtu as *const _ as usize },
        58usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(min_mtu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).max_mtu as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(rte_kni_conf), "::", stringify!(max_mtu))
    );
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Initialize and preallocate KNI subsystem"]
    #[doc = ""]
    #[doc = " This function is to be executed on the main lcore only, after EAL"]
    #[doc = " initialization and before any KNI interface is attempted to be"]
    #[doc = " allocated"]
    #[doc = ""]
    #[doc = " @param max_kni_ifaces"]
    #[doc = "  The maximum number of KNI interfaces that can coexist concurrently"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 indicates success."]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate KNI interface according to the port id, mbuf size, mbuf pool,"]
    #[doc = " configurations and callbacks for kernel requests.The KNI interface created"]
    #[doc = " in the kernel space is the net interface the traditional Linux application"]
    #[doc = " talking to."]
    #[doc = ""]
    #[doc = " The rte_kni_alloc shall not be called before rte_kni_init() has been"]
    #[doc = " called. rte_kni_alloc is thread safe."]
    #[doc = ""]
    #[doc = " The mempool should have capacity of more than \"2 x KNI_FIFO_COUNT_MAX\""]
    #[doc = " elements for each KNI interface allocated."]
    #[doc = ""]
    #[doc = " @param pktmbuf_pool"]
    #[doc = "  The mempool for allocating mbufs for packets."]
    #[doc = " @param conf"]
    #[doc = "  The pointer to the configurations of the KNI device."]
    #[doc = " @param ops"]
    #[doc = "  The pointer to the callbacks for the KNI kernel requests."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - The pointer to the context of a KNI interface."]
    #[doc = "  - NULL indicate error."]
    pub fn rte_kni_alloc(
        pktmbuf_pool: *mut rte_mempool,
        conf: *const rte_kni_conf,
        ops: *mut rte_kni_ops,
    ) -> *mut rte_kni;
}
extern "C" {
    #[doc = " Release KNI interface according to the context. It will also release the"]
    #[doc = " paired KNI interface in kernel space. All processing on the specific KNI"]
    #[doc = " context need to be stopped before calling this interface."]
    #[doc = ""]
    #[doc = " rte_kni_release is thread safe."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The pointer to the context of an existent KNI interface."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 indicates success."]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It is used to handle the request mbufs sent from kernel space."]
    #[doc = " Then analyzes it and calls the specific actions for the specific requests."]
    #[doc = " Finally constructs the response mbuf and puts it back to the resp_q."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The pointer to the context of an existent KNI interface."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0"]
    #[doc = "  - negative value indicates failure."]
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a burst of packets from a KNI interface. The retrieved packets are"]
    #[doc = " stored in rte_mbuf structures whose pointers are supplied in the array of"]
    #[doc = " mbufs, and the maximum number is indicated by num. It handles allocating"]
    #[doc = " the mbufs for KNI interface alloc queue."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The KNI interface context."]
    #[doc = " @param mbufs"]
    #[doc = "  The array to store the pointers of mbufs."]
    #[doc = " @param num"]
    #[doc = "  The maximum number per burst."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The actual number of packets retrieved."]
    pub fn rte_kni_rx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Send a burst of packets to a KNI interface. The packets to be sent out are"]
    #[doc = " stored in rte_mbuf structures whose pointers are supplied in the array of"]
    #[doc = " mbufs, and the maximum number is indicated by num. It handles the freeing of"]
    #[doc = " the mbufs in the free queue of KNI interface."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  The KNI interface context."]
    #[doc = " @param mbufs"]
    #[doc = "  The array to store the pointers of mbufs."]
    #[doc = " @param num"]
    #[doc = "  The maximum number per burst."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The actual number of packets sent."]
    pub fn rte_kni_tx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the KNI context of its name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  pointer to the KNI device name."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On success: Pointer to KNI interface."]
    #[doc = "  On failure: NULL."]
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    #[doc = " Get the name given to a KNI device"]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "   The KNI instance to query"]
    #[doc = " @return"]
    #[doc = "   The pointer to the KNI name"]
    pub fn rte_kni_get_name(kni: *const rte_kni) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Register KNI request handling for a specified port,and it can"]
    #[doc = " be called by primary process or secondary process."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  pointer to struct rte_kni."]
    #[doc = " @param ops"]
    #[doc = "  pointer to struct rte_kni_ops."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On success: 0"]
    #[doc = "  On failure: -1"]
    pub fn rte_kni_register_handlers(kni: *mut rte_kni, ops: *mut rte_kni_ops) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Unregister KNI request handling for a specified port."]
    #[doc = ""]
    #[doc = "  @param kni"]
    #[doc = "   pointer to struct rte_kni."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "   On success: 0"]
    #[doc = "   On failure: -1"]
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update link carrier state for KNI port."]
    #[doc = ""]
    #[doc = " Update the linkup/linkdown state of a KNI interface in the kernel."]
    #[doc = ""]
    #[doc = " @param kni"]
    #[doc = "  pointer to struct rte_kni."]
    #[doc = " @param linkup"]
    #[doc = "  New link state:"]
    #[doc = "  0 for linkdown."]
    #[doc = "  > 0 for linkup."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  On failure: -1"]
    #[doc = "  Previous link state == linkdown: 0"]
    #[doc = "  Previous link state == linkup: 1"]
    pub fn rte_kni_update_link(kni: *mut rte_kni, linkup: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Close KNI device."]
    pub fn rte_kni_close();
}
extern "C" {
    #[doc = " Create a bonded rte_eth_dev device"]
    #[doc = ""]
    #[doc = " @param name\t\t\tName of new link bonding device."]
    #[doc = " @param mode\t\t\tMode to initialize bonding device in."]
    #[doc = " @param socket_id\t\tSocket Id on which to allocate eth_dev resources."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tPort Id of created rte_eth_dev on success, negative value otherwise"]
    pub fn rte_eth_bond_create(name: *const ::std::os::raw::c_char, mode: u8, socket_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a bonded rte_eth_dev device"]
    #[doc = ""]
    #[doc = " @param name\t\t\tName of the link bonding device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_free(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a rte_eth_dev device as a slave to the bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param slave_port_id\t\tPort ID of slave device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_slave_add(bonded_port_id: u16, slave_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a slave rte_eth_dev device from the bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param slave_port_id\t\tPort ID of slave device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_slave_remove(bonded_port_id: u16, slave_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set link bonding mode of bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param mode\t\t\t\tBonding mode to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_mode_set(bonded_port_id: u16, mode: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get link bonding mode of bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tlink bonding mode on success, negative value otherwise"]
    pub fn rte_eth_bond_mode_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set slave rte_eth_dev as primary slave of bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param slave_port_id\t\tPort ID of slave device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_primary_set(bonded_port_id: u16, slave_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get primary slave of bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tPort Id of primary slave on success, -1 on failure"]
    pub fn rte_eth_bond_primary_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Populate an array with list of the slaves port id's of the bonded device"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded eth_dev to interrogate"]
    #[doc = " @param slaves\t\t\tArray to be populated with the current active slaves"]
    #[doc = " @param len\t\t\t\tLength of slaves array"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tNumber of slaves associated with bonded device on success,"]
    #[doc = "\tnegative value otherwise"]
    pub fn rte_eth_bond_slaves_get(bonded_port_id: u16, slaves: *mut u16, len: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Populate an array with list of the active slaves port id's of the bonded"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded eth_dev to interrogate"]
    #[doc = " @param slaves\t\t\tArray to be populated with the current active slaves"]
    #[doc = " @param len\t\t\t\tLength of slaves array"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tNumber of active slaves associated with bonded device on success,"]
    #[doc = "\tnegative value otherwise"]
    pub fn rte_eth_bond_active_slaves_get(bonded_port_id: u16, slaves: *mut u16, len: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set explicit MAC address to use on bonded device and it's slaves."]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param mac_addr\t\t\tMAC Address to use on bonded device overriding"]
    #[doc = "\t\t\t\t\t\t\tslaves MAC addresses"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_mac_address_set(bonded_port_id: u16, mac_addr: *mut rte_ether_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset bonded device to use MAC from primary slave on bonded device and it's"]
    #[doc = " slaves."]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise"]
    pub fn rte_eth_bond_mac_address_reset(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the transmit policy for bonded device to use when it is operating in"]
    #[doc = " balance mode, this parameter is otherwise ignored in other modes of"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param policy\t\t\tBalance mode transmission policy."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise."]
    pub fn rte_eth_bond_xmit_policy_set(bonded_port_id: u16, policy: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the transmit policy set on bonded device for balance mode operation"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tBalance transmit policy on success, negative value otherwise."]
    pub fn rte_eth_bond_xmit_policy_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the link monitoring frequency (in ms) for monitoring the link status of"]
    #[doc = " slave devices"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param internal_ms\t\tMonitoring interval in milliseconds"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t0 on success, negative value otherwise."]
    pub fn rte_eth_bond_link_monitoring_set(bonded_port_id: u16, internal_ms: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current link monitoring frequency (in ms) for monitoring of the link"]
    #[doc = " status of slave devices"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\tMonitoring interval on success, negative value otherwise."]
    pub fn rte_eth_bond_link_monitoring_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the period in milliseconds for delaying the disabling of a bonded link"]
    #[doc = " when the link down status has been detected"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param delay_ms\t\t\tDelay period in milliseconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success, negative value otherwise."]
    pub fn rte_eth_bond_link_down_prop_delay_set(bonded_port_id: u16, delay_ms: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the period in milliseconds set for delaying the disabling of a bonded"]
    #[doc = " link when the link down status has been detected"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Delay period on success, negative value otherwise."]
    pub fn rte_eth_bond_link_down_prop_delay_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the period in milliseconds for delaying the enabling of a bonded link"]
    #[doc = " when the link up status has been detected"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = " @param delay_ms\t\t\tDelay period in milliseconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success, negative value otherwise."]
    pub fn rte_eth_bond_link_up_prop_delay_set(bonded_port_id: u16, delay_ms: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the period in milliseconds set for delaying the enabling of a bonded"]
    #[doc = " link when the link up status has been detected"]
    #[doc = ""]
    #[doc = " @param bonded_port_id\tPort ID of bonded device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Delay period on success, negative value otherwise."]
    pub fn rte_eth_bond_link_up_prop_delay_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
#[doc = " VXLAN protocol header."]
#[doc = " Contains the 8-bit flag, 24-bit VXLAN Network Identifier and"]
#[doc = " Reserved fields (24 bits and 8 bits)"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_vxlan_hdr {
    #[doc = "< flag (8) + Reserved (24)."]
    pub vx_flags: u32,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_rte_vxlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_vxlan_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_vxlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vxlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_vxlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_hdr>())).vx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vxlan_hdr),
            "::",
            stringify!(vx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_hdr>())).vx_vni as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(rte_vxlan_hdr), "::", stringify!(vx_vni))
    );
}
#[doc = " VXLAN-GPE protocol header (draft-ietf-nvo3-vxlan-gpe-05)."]
#[doc = " Contains the 8-bit flag, 8-bit next-protocol, 24-bit VXLAN Network"]
#[doc = " Identifier and Reserved fields (16 bits and 8 bits)."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_vxlan_gpe_hdr {
    #[doc = "< flag (8)."]
    pub vx_flags: u8,
    #[doc = "< Reserved (16)."]
    pub reserved: [u8; 2usize],
    #[doc = "< next-protocol (8)."]
    pub proto: u8,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_rte_vxlan_gpe_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_vxlan_gpe_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_vxlan_gpe_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vxlan_gpe_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_vxlan_gpe_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_gpe_hdr>())).vx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vxlan_gpe_hdr),
            "::",
            stringify!(vx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_gpe_hdr>())).reserved as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vxlan_gpe_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_gpe_hdr>())).proto as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vxlan_gpe_hdr),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vxlan_gpe_hdr>())).vx_vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vxlan_gpe_hdr),
            "::",
            stringify!(vx_vni)
        )
    );
}
#[doc = " This structure is the header of a cirbuf type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cirbuf {
    #[doc = "< total len of the fifo (number of elements)"]
    pub maxlen: ::std::os::raw::c_uint,
    #[doc = "< indice of the first elt"]
    pub start: ::std::os::raw::c_uint,
    #[doc = "< indice of the last elt"]
    pub end: ::std::os::raw::c_uint,
    #[doc = "< current len of fifo"]
    pub len: ::std::os::raw::c_uint,
    pub buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cirbuf() {
    assert_eq!(
        ::std::mem::size_of::<cirbuf>(),
        24usize,
        concat!("Size of: ", stringify!(cirbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<cirbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(cirbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).maxlen as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cirbuf), "::", stringify!(maxlen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).start as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cirbuf), "::", stringify!(start))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).end as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cirbuf), "::", stringify!(end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).len as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cirbuf), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).buf as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cirbuf), "::", stringify!(buf))
    );
}
impl Default for cirbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut cmdline_vt100_commands: [*const ::std::os::raw::c_char; 0usize];
}
pub mod cmdline_vt100_parser_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const CMDLINE_VT100_INIT: Type = 0;
    pub const CMDLINE_VT100_ESCAPE: Type = 1;
    pub const CMDLINE_VT100_ESCAPE_CSI: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_vt100 {
    pub bufpos: u8,
    pub buf: [::std::os::raw::c_char; 8usize],
    pub state: cmdline_vt100_parser_state::Type,
}
#[test]
fn bindgen_test_layout_cmdline_vt100() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_vt100>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_vt100))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_vt100>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_vt100))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).bufpos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cmdline_vt100), "::", stringify!(bufpos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).buf as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(cmdline_vt100), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).state as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cmdline_vt100), "::", stringify!(state))
    );
}
impl Default for cmdline_vt100 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rdline_status {
    pub type Type = ::std::os::raw::c_uint;
    pub const RDLINE_INIT: Type = 0;
    pub const RDLINE_RUNNING: Type = 1;
    pub const RDLINE_EXITED: Type = 2;
}
pub type rdline_write_char_t = ::std::option::Option<
    unsafe extern "C" fn(rdl: *mut rdline, arg1: ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
pub type rdline_validate_t = ::std::option::Option<
    unsafe extern "C" fn(rdl: *mut rdline, buf: *const ::std::os::raw::c_char, size: ::std::os::raw::c_uint),
>;
pub type rdline_complete_t = ::std::option::Option<
    unsafe extern "C" fn(
        rdl: *mut rdline,
        buf: *const ::std::os::raw::c_char,
        dstbuf: *mut ::std::os::raw::c_char,
        dstsize: ::std::os::raw::c_uint,
        state: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdline {
    pub status: rdline_status::Type,
    pub left: cirbuf,
    pub right: cirbuf,
    pub left_buf: [::std::os::raw::c_char; 514usize],
    pub right_buf: [::std::os::raw::c_char; 512usize],
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub prompt_size: ::std::os::raw::c_uint,
    pub kill_buf: [::std::os::raw::c_char; 512usize],
    pub kill_size: ::std::os::raw::c_uint,
    pub history: cirbuf,
    pub history_buf: [::std::os::raw::c_char; 8192usize],
    pub history_cur_line: ::std::os::raw::c_int,
    pub write_char: rdline_write_char_t,
    pub validate: rdline_validate_t,
    pub complete: rdline_complete_t,
    pub vt100: cmdline_vt100,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rdline() {
    assert_eq!(
        ::std::mem::size_of::<rdline>(),
        9912usize,
        concat!("Size of: ", stringify!(rdline))
    );
    assert_eq!(
        ::std::mem::align_of::<rdline>(),
        8usize,
        concat!("Alignment of ", stringify!(rdline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).status as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).left as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(left))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).right as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(right))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).left_buf as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(left_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).right_buf as *const _ as usize },
        570usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(right_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).prompt as *const _ as usize },
        1082usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(prompt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).prompt_size as *const _ as usize },
        1116usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(prompt_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).kill_buf as *const _ as usize },
        1120usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(kill_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).kill_size as *const _ as usize },
        1632usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(kill_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history as *const _ as usize },
        1640usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(history))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history_buf as *const _ as usize },
        1664usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(history_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history_cur_line as *const _ as usize },
        9856usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(history_cur_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).write_char as *const _ as usize },
        9864usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(write_char))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).validate as *const _ as usize },
        9872usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(validate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).complete as *const _ as usize },
        9880usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(complete))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).vt100 as *const _ as usize },
        9888usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(vt100))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).opaque as *const _ as usize },
        9904usize,
        concat!("Offset of field: ", stringify!(rdline), "::", stringify!(opaque))
    );
}
impl Default for rdline {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Stores a pointer to the ops struct, and the offset: the place to"]
#[doc = " write the parsed result in the destination structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_hdr {
    pub ops: *mut cmdline_token_ops,
    pub offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cmdline_token_hdr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_hdr>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_hdr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_hdr>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_hdr),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for cmdline_token_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_hdr_t = cmdline_token_hdr;
#[doc = " A token is defined by this structure."]
#[doc = ""]
#[doc = " parse() takes the token as first argument, then the source buffer"]
#[doc = " starting at the token we want to parse. The 3rd arg is a pointer"]
#[doc = " where we store the parsed data (as binary). It returns the number of"]
#[doc = " parsed chars on success and a negative value on error."]
#[doc = ""]
#[doc = " complete_get_nb() returns the number of possible values for this"]
#[doc = " token if completion is possible. If it is NULL or if it returns 0,"]
#[doc = " no completion is possible."]
#[doc = ""]
#[doc = " complete_get_elt() copy in dstbuf (the size is specified in the"]
#[doc = " parameter) the i-th possible completion for this token.  returns 0"]
#[doc = " on success or and a negative value on error."]
#[doc = ""]
#[doc = " get_help() fills the dstbuf with the help for the token. It returns"]
#[doc = " -1 on error and 0 on success."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cmdline_token_ops {
    #[doc = " parse(token ptr, buf, res pts, buf len)"]
    pub parse: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " return the num of possible choices for this token"]
    pub complete_get_nb:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut cmdline_parse_token_hdr_t) -> ::std::os::raw::c_int>,
    #[doc = " return the elt x for this token (token, idx, dstbuf, size)"]
    pub complete_get_elt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get help for this token (token, dstbuf, size)"]
    pub get_help: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_cmdline_token_ops() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ops>(),
        32usize,
        concat!("Size of: ", stringify!(cmdline_token_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).parse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).complete_get_nb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(complete_get_nb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).complete_get_elt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(complete_get_elt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).get_help as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(get_help)
        )
    );
}
#[doc = " Store a instruction, which is a pointer to a callback function and"]
#[doc = " its parameter that is called when the instruction is parsed, a help"]
#[doc = " string, and a list of token composing this instruction."]
#[doc = ""]
#[doc = " When no tokens are defined (tokens[0] == NULL), they are retrieved"]
#[doc = " dynamically by calling f() as follows:"]
#[doc = ""]
#[doc = " @code"]
#[doc = ""]
#[doc = " f((struct cmdline_token_hdr **)&token_p,"]
#[doc = "   NULL,"]
#[doc = "   (struct cmdline_token_hdr **)&inst->tokens[num]);"]
#[doc = ""]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " The address of the resulting token is expected at the location pointed by"]
#[doc = " the first argument. Can be set to NULL to end the list."]
#[doc = ""]
#[doc = " The cmdline argument (struct cmdline *) is always NULL."]
#[doc = ""]
#[doc = " The last argument points to the inst->tokens[] entry to retrieve, which"]
#[doc = " is not necessarily inside allocated memory and should neither be read nor"]
#[doc = " written. Its sole purpose is to deduce the token entry index of interest"]
#[doc = " as described in the example below."]
#[doc = ""]
#[doc = " Note about constraints:"]
#[doc = ""]
#[doc = " - Only the address of these tokens is dynamic, their storage should be"]
#[doc = "   static like normal tokens."]
#[doc = " - Dynamic token lists that need to maintain an internal context (e.g. in"]
#[doc = "   order to determine the next token) must store it statically also. This"]
#[doc = "   context must be reinitialized when the first token is requested, that"]
#[doc = "   is, when &inst->tokens[0] is provided as the third argument."]
#[doc = " - Dynamic token lists must be NULL-terminated to generate usable"]
#[doc = "   commands."]
#[doc = ""]
#[doc = " @code"]
#[doc = ""]
#[doc = " // Assuming first and third arguments are respectively named \"token_p\""]
#[doc = " // and \"token\":"]
#[doc = ""]
#[doc = " int index = token - inst->tokens;"]
#[doc = ""]
#[doc = " if (!index) {"]
#[doc = "     [...] // Clean up internal context if any."]
#[doc = " }"]
#[doc = " [...] // Then set up dyn_token according to index."]
#[doc = ""]
#[doc = " if (no_more_tokens)"]
#[doc = "     *token_p = NULL;"]
#[doc = " else"]
#[doc = "     *token_p = &dyn_token;"]
#[doc = ""]
#[doc = " @endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cmdline_inst {
    pub f: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut cmdline, arg3: *mut ::std::os::raw::c_void),
    >,
    pub data: *mut ::std::os::raw::c_void,
    pub help_str: *const ::std::os::raw::c_char,
    pub tokens: __IncompleteArrayField<*mut cmdline_parse_token_hdr_t>,
}
#[test]
fn bindgen_test_layout_cmdline_inst() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_inst>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_inst))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_inst>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_inst))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_inst>())).f as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cmdline_inst), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_inst>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cmdline_inst), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_inst>())).help_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_inst),
            "::",
            stringify!(help_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_inst>())).tokens as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(cmdline_inst), "::", stringify!(tokens))
    );
}
impl Default for cmdline_inst {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_inst_t = cmdline_inst;
#[doc = " A context is identified by its name, and contains a list of"]
#[doc = " instruction"]
#[doc = ""]
pub type cmdline_parse_ctx_t = *mut cmdline_parse_inst_t;
extern "C" {
    #[doc = " Try to parse a buffer according to the specified context. The"]
    #[doc = " argument buf must ends with \"\\n\\0\". The function returns"]
    #[doc = " CMDLINE_PARSE_AMBIGUOUS, CMDLINE_PARSE_NOMATCH or"]
    #[doc = " CMDLINE_PARSE_BAD_ARGS on error. Else it calls the associated"]
    #[doc = " function (defined in the context) and returns 0"]
    #[doc = " (CMDLINE_PARSE_SUCCESS)."]
    pub fn cmdline_parse(cl: *mut cmdline, buf: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " complete() must be called with *state==0 (try to complete) or"]
    #[doc = " with *state==-1 (just display choices), then called without"]
    #[doc = " modifying *state until it returns CMDLINE_PARSE_COMPLETED_BUFFER or"]
    #[doc = " CMDLINE_PARSE_COMPLETED_BUFFER."]
    #[doc = ""]
    #[doc = " It returns < 0 on error."]
    #[doc = ""]
    #[doc = " Else it returns:"]
    #[doc = "   - CMDLINE_PARSE_COMPLETED_BUFFER on completion (one possible"]
    #[doc = "     choice). In this case, the chars are appended in dst buffer."]
    #[doc = "   - CMDLINE_PARSE_COMPLETE_AGAIN if there is several possible"]
    #[doc = "     choices. In this case, you must call the function again,"]
    #[doc = "     keeping the value of state intact."]
    #[doc = "   - CMDLINE_PARSE_COMPLETED_BUFFER when the iteration is"]
    #[doc = "     finished. The dst is not valid for this last call."]
    #[doc = ""]
    #[doc = " The returned dst buf ends with \\0."]
    pub fn cmdline_complete(
        cl: *mut cmdline,
        buf: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendoftoken(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendofcommand(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_etheraddr {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_etheraddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_etheraddr>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_etheraddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_etheraddr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_etheraddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_etheraddr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_etheraddr),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for cmdline_token_etheraddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_etheraddr_t = cmdline_token_etheraddr;
extern "C" {
    pub static mut cmdline_token_etheraddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_etheraddr(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_etheraddr(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmdline_ipaddr {
    pub family: u8,
    pub addr: cmdline_ipaddr__bindgen_ty_1,
    pub prefixlen: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmdline_ipaddr__bindgen_ty_1 {
    pub ipv4: in_addr,
    pub ipv6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_ipaddr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_ipaddr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_ipaddr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_ipaddr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr__bindgen_ty_1>())).ipv4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr__bindgen_ty_1>())).ipv6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
}
impl Default for cmdline_ipaddr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_ipaddr>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_ipaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_ipaddr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_ipaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).addr as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cmdline_ipaddr), "::", stringify!(addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).prefixlen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr),
            "::",
            stringify!(prefixlen)
        )
    );
}
impl Default for cmdline_ipaddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_ipaddr_t = cmdline_ipaddr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cmdline_token_ipaddr_data {
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ipaddr_data>(),
        1usize,
        concat!("Size of: ", stringify!(cmdline_token_ipaddr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ipaddr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(cmdline_token_ipaddr_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ipaddr_data>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr_data),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_ipaddr {
    pub hdr: cmdline_token_hdr,
    pub ipaddr_data: cmdline_token_ipaddr_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ipaddr>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_ipaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ipaddr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_ipaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ipaddr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ipaddr>())).ipaddr_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr),
            "::",
            stringify!(ipaddr_data)
        )
    );
}
impl Default for cmdline_token_ipaddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_ipaddr_t = cmdline_token_ipaddr;
extern "C" {
    pub static mut cmdline_token_ipaddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_ipaddr(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_ipaddr(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod cmdline_numtype {
    pub type Type = ::std::os::raw::c_uint;
    pub const RTE_UINT8: Type = 0;
    pub const RTE_UINT16: Type = 1;
    pub const RTE_UINT32: Type = 2;
    pub const RTE_UINT64: Type = 3;
    pub const RTE_INT8: Type = 4;
    pub const RTE_INT16: Type = 5;
    pub const RTE_INT32: Type = 6;
    pub const RTE_INT64: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_num_data {
    pub type_: cmdline_numtype::Type,
}
#[test]
fn bindgen_test_layout_cmdline_token_num_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_num_data>(),
        4usize,
        concat!("Size of: ", stringify!(cmdline_token_num_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_num_data>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_token_num_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num_data>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num_data),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for cmdline_token_num_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_num {
    pub hdr: cmdline_token_hdr,
    pub num_data: cmdline_token_num_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_num() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_num>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_num))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_num>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num>())).num_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num),
            "::",
            stringify!(num_data)
        )
    );
}
impl Default for cmdline_token_num {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_num_t = cmdline_token_num;
extern "C" {
    pub static mut cmdline_token_num_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_num(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_num(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cmdline_portlist {
    pub map: u32,
}
#[test]
fn bindgen_test_layout_cmdline_portlist() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_portlist>(),
        4usize,
        concat!("Size of: ", stringify!(cmdline_portlist))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_portlist>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_portlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_portlist>())).map as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cmdline_portlist), "::", stringify!(map))
    );
}
pub type cmdline_portlist_t = cmdline_portlist;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_portlist {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_portlist() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_portlist>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_portlist))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_portlist>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_portlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_portlist>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_portlist),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for cmdline_token_portlist {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_portlist_t = cmdline_token_portlist;
extern "C" {
    pub static mut cmdline_token_portlist_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_portlist(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_portlist(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type cmdline_fixed_string_t = [::std::os::raw::c_char; 128usize];
pub type cmdline_multi_string_t = [::std::os::raw::c_char; 4096usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_string_data {
    pub str_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cmdline_token_string_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_string_data>(),
        8usize,
        concat!("Size of: ", stringify!(cmdline_token_string_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_string_data>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_string_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_string_data>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string_data),
            "::",
            stringify!(str_)
        )
    );
}
impl Default for cmdline_token_string_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_string {
    pub hdr: cmdline_token_hdr,
    pub string_data: cmdline_token_string_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_string() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_string>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_string))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_string>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_string>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_string>())).string_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string),
            "::",
            stringify!(string_data)
        )
    );
}
impl Default for cmdline_token_string {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_string_t = cmdline_token_string;
extern "C" {
    pub static mut cmdline_token_string_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_string(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_nb_string(tk: *mut cmdline_parse_token_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_elt_string(
        tk: *mut cmdline_parse_token_hdr_t,
        idx: ::std::os::raw::c_int,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_string(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        60usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_iflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_oflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_cflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_lflag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_line as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_line))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        17usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_cc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ispeed as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_ispeed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ospeed as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(termios), "::", stringify!(c_ospeed))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmdline {
    pub s_in: ::std::os::raw::c_int,
    pub s_out: ::std::os::raw::c_int,
    pub ctx: *mut cmdline_parse_ctx_t,
    pub rdl: rdline,
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub oldterm: termios,
}
#[test]
fn bindgen_test_layout_cmdline() {
    assert_eq!(
        ::std::mem::size_of::<cmdline>(),
        10024usize,
        concat!("Size of: ", stringify!(cmdline))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).s_in as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(s_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).s_out as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(s_out))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).ctx as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).rdl as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(rdl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).prompt as *const _ as usize },
        9928usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(prompt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).oldterm as *const _ as usize },
        9960usize,
        concat!("Offset of field: ", stringify!(cmdline), "::", stringify!(oldterm))
    );
}
impl Default for cmdline {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn cmdline_new(
        ctx: *mut cmdline_parse_ctx_t,
        prompt: *const ::std::os::raw::c_char,
        s_in: ::std::os::raw::c_int,
        s_out: ::std::os::raw::c_int,
    ) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_set_prompt(cl: *mut cmdline, prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cmdline_free(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_printf(cl: *const cmdline, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cmdline_in(
        cl: *mut cmdline,
        buf: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_write_char(rdl: *mut rdline, c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_rdline(cl: *mut cmdline) -> *mut rdline;
}
extern "C" {
    #[doc = " This function is nonblocking equivalent of ``cmdline_interact()``. It polls"]
    #[doc = " *cl* for one character and interpret it. If return value is *RDLINE_EXITED*"]
    #[doc = " it mean that ``cmdline_quit()`` was invoked."]
    #[doc = ""]
    #[doc = " @param cl"]
    #[doc = "   The command line object."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success return object status - one of *enum rdline_status*."]
    #[doc = "   On error return negative value."]
    pub fn cmdline_poll(cl: *mut cmdline) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_interact(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_quit(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_file_new(
        ctx: *mut cmdline_parse_ctx_t,
        prompt: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_new(ctx: *mut cmdline_parse_ctx_t, prompt: *const ::std::os::raw::c_char) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_exit(cl: *mut cmdline);
}
extern "C" {
    #[doc = " Seed the pseudo-random generator."]
    #[doc = ""]
    #[doc = " The generator is automatically seeded by the EAL init with a timer"]
    #[doc = " value. It may need to be re-seeded by the user with a real random"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " @param seedval"]
    #[doc = "   The value of the seed."]
    pub fn _rte_srand(seedval: u64);
}
extern "C" {
    #[doc = " Get a pseudo-random value."]
    #[doc = ""]
    #[doc = " This function generates pseudo-random numbers using the linear"]
    #[doc = " congruential algorithm and 48-bit integer arithmetic, called twice"]
    #[doc = " to generate a 64-bit value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pseudo-random value between 0 and (1<<64)-1."]
    pub fn _rte_rand() -> u64;
}
extern "C" {
    #[doc = " Bitmap initialization"]
    #[doc = ""]
    #[doc = " @param n_bits"]
    #[doc = "   Number of pre-allocated bits in array2."]
    #[doc = " @param mem"]
    #[doc = "   Base address of array1 and array2."]
    #[doc = " @param mem_size"]
    #[doc = "   Minimum expected size of bitmap."]
    #[doc = " @return"]
    #[doc = "   Handle to bitmap instance."]
    pub fn _rte_bitmap_init(n_bits: u32, mem: *mut u8, mem_size: u32) -> *mut rte_bitmap;
}
extern "C" {
    #[doc = " Bitmap free"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn _rte_bitmap_free(bmp: *mut rte_bitmap) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bitmap reset"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    pub fn _rte_bitmap_reset(bmp: *mut rte_bitmap);
}
extern "C" {
    #[doc = " Bitmap location prefetch into CPU L1 cache"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   Bit position"]
    #[doc = " @return"]
    #[doc = "   0 upon success, error code otherwise"]
    pub fn _rte_bitmap_prefetch0(bmp: *mut rte_bitmap, pos: u32);
}
extern "C" {
    #[doc = " Bitmap bit get"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   Bit position"]
    #[doc = " @return"]
    #[doc = "   0 when bit is cleared, non-zero when bit is set"]
    pub fn _rte_bitmap_get(bmp: *mut rte_bitmap, pos: u32) -> u64;
}
extern "C" {
    #[doc = " Bitmap bit set"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   Bit position"]
    pub fn _rte_bitmap_set(bmp: *mut rte_bitmap, pos: u32);
}
extern "C" {
    #[doc = " Bitmap slab set"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   Bit position identifying the array2 slab"]
    #[doc = " @param slab"]
    #[doc = "   Value to be assigned to the 64-bit slab in array2"]
    pub fn _rte_bitmap_set_slab(bmp: *mut rte_bitmap, pos: u32, slab: u64);
}
extern "C" {
    #[doc = " Bitmap bit clear"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   Bit position"]
    pub fn _rte_bitmap_clear(bmp: *mut rte_bitmap, pos: u32);
}
extern "C" {
    #[doc = " Bitmap scan (with automatic wrap-around)"]
    #[doc = ""]
    #[doc = " @param bmp"]
    #[doc = "   Handle to bitmap instance"]
    #[doc = " @param pos"]
    #[doc = "   When function call returns 1, pos contains the position of the next set"]
    #[doc = "   bit, otherwise not modified"]
    #[doc = " @param slab"]
    #[doc = "   When function call returns 1, slab contains the value of the entire 64-bit"]
    #[doc = "   slab where the bit indicated by pos is located. Slabs are always 64-bit"]
    #[doc = "   aligned, so the position of the first bit of the slab (this bit is not"]
    #[doc = "   necessarily set) is pos / 64. Once a slab has been returned by the bitmap"]
    #[doc = "   scan operation, the internal pointers of the bitmap are updated to point"]
    #[doc = "   after this slab, so the same slab will not be returned again if it"]
    #[doc = "   contains more than one bit which is set. When function call returns 0,"]
    #[doc = "   slab is not modified."]
    #[doc = " @return"]
    #[doc = "   0 if there is no bit set in the bitmap, 1 otherwise"]
    pub fn _rte_bitmap_scan(bmp: *mut rte_bitmap, pos: *mut u32, slab: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bitmap memory footprint calculation"]
    #[doc = ""]
    #[doc = " @param n_bits"]
    #[doc = "   Number of bits in the bitmap"]
    #[doc = " @return"]
    #[doc = "   Bitmap memory footprint measured in bytes on success, 0 on error"]
    pub fn _rte_bitmap_get_memory_footprint(n_bits: u32) -> u32;
}
extern "C" {
    #[doc = " Initialize the spinlock to an unlocked state."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    pub fn _rte_spinlock_init(sl: *mut rte_spinlock_t);
}
extern "C" {
    #[doc = " Take the spinlock."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    pub fn _rte_spinlock_lock(sl: *mut rte_spinlock_t);
}
extern "C" {
    #[doc = " Release the spinlock."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    pub fn _rte_spinlock_unlock(sl: *mut rte_spinlock_t);
}
extern "C" {
    #[doc = " Try to take the lock."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    #[doc = " @return"]
    #[doc = "   1 if the lock is successfully taken; 0 otherwise."]
    pub fn _rte_spinlock_trylock(sl: *mut rte_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if hardware transactional memory (lock elision) is supported"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if the hardware transactional memory is supported; 0 otherwise."]
    pub fn _rte_tm_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to execute critical section in a hardware memory transaction,"]
    #[doc = " if it fails or not available take the spinlock."]
    #[doc = ""]
    #[doc = " NOTE: An attempt to perform a HW I/O operation inside a hardware memory"]
    #[doc = " transaction always aborts the transaction since the CPU is not able to"]
    #[doc = " roll-back should the transaction fail. Therefore, hardware transactional"]
    #[doc = " locks are not advised to be used around rte_eth_rx_burst() and"]
    #[doc = " rte_eth_tx_burst() calls."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    pub fn _rte_spinlock_lock_tm(sl: *mut rte_spinlock_t);
}
extern "C" {
    #[doc = " Try to execute critical section in a hardware memory transaction,"]
    #[doc = " if it fails or not available try to take the lock."]
    #[doc = ""]
    #[doc = " NOTE: An attempt to perform a HW I/O operation inside a hardware memory"]
    #[doc = " transaction always aborts the transaction since the CPU is not able to"]
    #[doc = " roll-back should the transaction fail. Therefore, hardware transactional"]
    #[doc = " locks are not advised to be used around rte_eth_rx_burst() and"]
    #[doc = " rte_eth_tx_burst() calls."]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    #[doc = " @return"]
    #[doc = "   1 if the hardware memory transaction is successfully started"]
    #[doc = "   or lock is successfully taken; 0 otherwise."]
    pub fn _rte_spinlock_trylock_tm(sl: *mut rte_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Commit hardware memory transaction or release the spinlock if"]
    #[doc = " the spinlock is used as a fall-back"]
    #[doc = ""]
    #[doc = " @param sl"]
    #[doc = "   A pointer to the spinlock."]
    pub fn _rte_spinlock_unlock_tm(sl: *mut rte_spinlock_t);
}
extern "C" {
    #[doc = " Initialize the recursive spinlock to an unlocked state."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    pub fn _rte_spinlock_recursive_init(slr: *mut rte_spinlock_recursive_t);
}
extern "C" {
    #[doc = " Take the recursive spinlock."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    pub fn _rte_spinlock_recursive_lock(slr: *mut rte_spinlock_recursive_t);
}
extern "C" {
    #[doc = " Release the recursive spinlock."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    pub fn _rte_spinlock_recursive_unlock(slr: *mut rte_spinlock_recursive_t);
}
extern "C" {
    #[doc = " Try to take the recursive lock."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    #[doc = " @return"]
    #[doc = "   1 if the lock is successfully taken; 0 otherwise."]
    pub fn _rte_spinlock_recursive_trylock(slr: *mut rte_spinlock_recursive_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to execute critical section in a hardware memory transaction,"]
    #[doc = " if it fails or not available take the recursive spinlocks"]
    #[doc = ""]
    #[doc = " NOTE: An attempt to perform a HW I/O operation inside a hardware memory"]
    #[doc = " transaction always aborts the transaction since the CPU is not able to"]
    #[doc = " roll-back should the transaction fail. Therefore, hardware transactional"]
    #[doc = " locks are not advised to be used around rte_eth_rx_burst() and"]
    #[doc = " rte_eth_tx_burst() calls."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    pub fn _rte_spinlock_recursive_lock_tm(slr: *mut rte_spinlock_recursive_t);
}
extern "C" {
    #[doc = " Commit hardware memory transaction or release the recursive spinlock"]
    #[doc = " if the recursive spinlock is used as a fall-back"]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    pub fn _rte_spinlock_recursive_unlock_tm(slr: *mut rte_spinlock_recursive_t);
}
extern "C" {
    #[doc = " Try to execute critical section in a hardware memory transaction,"]
    #[doc = " if it fails or not available try to take the recursive lock"]
    #[doc = ""]
    #[doc = " NOTE: An attempt to perform a HW I/O operation inside a hardware memory"]
    #[doc = " transaction always aborts the transaction since the CPU is not able to"]
    #[doc = " roll-back should the transaction fail. Therefore, hardware transactional"]
    #[doc = " locks are not advised to be used around rte_eth_rx_burst() and"]
    #[doc = " rte_eth_tx_burst() calls."]
    #[doc = ""]
    #[doc = " @param slr"]
    #[doc = "   A pointer to the recursive spinlock."]
    #[doc = " @return"]
    #[doc = "   1 if the hardware memory transaction is successfully started"]
    #[doc = "   or lock is successfully taken; 0 otherwise."]
    pub fn _rte_spinlock_recursive_trylock_tm(slr: *mut rte_spinlock_recursive_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the Application thread ID of the execution unit."]
    #[doc = ""]
    #[doc = " Note: in most cases the lcore id returned here will also correspond"]
    #[doc = "   to the processor id of the CPU on which the thread is pinned, this"]
    #[doc = "   will not be the case if the user has explicitly changed the thread to"]
    #[doc = "   core affinities using --lcores EAL argument e.g. --lcores '(0-3)@10'"]
    #[doc = "   to run threads with lcore IDs 0, 1, 2 and 3 on physical core 10.."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  Logical core ID (in EAL thread) or LCORE_ID_ANY (in non-EAL thread)"]
    pub fn _rte_lcore_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Error number value, stored per-thread, which can be queried after"]
    #[doc = " calls to certain functions to determine why those functions failed."]
    #[doc = ""]
    #[doc = " Uses standard values from errno.h wherever possible, with a small number"]
    #[doc = " of additional possible values for RTE-specific conditions."]
    pub fn _rte_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of TSC cycles since boot"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   the number of cycles"]
    pub fn _rte_get_tsc_cycles() -> u64;
}
extern "C" {
    #[doc = " Get the number of cycles since boot from the default timer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of cycles"]
    pub fn _rte_get_timer_cycles() -> u64;
}
extern "C" {
    #[doc = " Get the number of cycles in one second for the default timer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of cycles in one second."]
    pub fn _rte_get_timer_hz() -> u64;
}
extern "C" {
    #[doc = " Wait at least ms milliseconds."]
    #[doc = ""]
    #[doc = " @param ms"]
    #[doc = "   The number of milliseconds to wait."]
    pub fn _rte_delay_ms(ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _rte_rdtsc() -> u64;
}
extern "C" {
    pub fn _rte_rdtsc_precise() -> u64;
}
extern "C" {
    #[doc = " Return a pointer to the mempool owning this object."]
    #[doc = ""]
    #[doc = " @param obj"]
    #[doc = "   An object that is owned by a pool. If this is not the case,"]
    #[doc = "   the behavior is undefined."]
    #[doc = " @return"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn _rte_mempool_from_obj(obj: *mut ::std::os::raw::c_void) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Return the IO address of elt, which is an element of the pool mp."]
    #[doc = ""]
    #[doc = " @param elt"]
    #[doc = "   A pointer (virtual address) to the element of the pool."]
    #[doc = " @return"]
    #[doc = "   The IO address of the elt element."]
    #[doc = "   If the mempool was created with MEMPOOL_F_NO_IOVA_CONTIG, the"]
    #[doc = "   returned value is RTE_BAD_IOVA."]
    pub fn _rte_mempool_virt2iova(elt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    #[doc = " Return a pointer to the private data in an mempool structure."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   A pointer to the private data."]
    pub fn _rte_mempool_get_priv(mp: *mut rte_mempool) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Flush a user-owned mempool cache to the specified mempool."]
    #[doc = ""]
    #[doc = " @param cache"]
    #[doc = "   A pointer to the mempool cache."]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool."]
    pub fn _rte_mempool_cache_flush(cache: *mut rte_mempool_cache, mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Get a pointer to the per-lcore default mempool cache."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param lcore_id"]
    #[doc = "   The logical core id."]
    #[doc = " @return"]
    #[doc = "   A pointer to the mempool cache or NULL if disabled or non-EAL thread."]
    pub fn _rte_mempool_default_cache(mp: *mut rte_mempool, lcore_id: ::std::os::raw::c_uint)
        -> *mut rte_mempool_cache;
}
extern "C" {
    #[doc = " Put several objects back in the mempool."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj_table"]
    #[doc = "   A pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   The number of objects to add in the mempool from the obj_table."]
    #[doc = " @param cache"]
    #[doc = "   A pointer to a mempool cache structure. May be NULL if not needed."]
    pub fn _rte_mempool_generic_put(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        cache: *mut rte_mempool_cache,
    );
}
extern "C" {
    #[doc = " Put several objects back in the mempool."]
    #[doc = ""]
    #[doc = " This function calls the multi-producer or the single-producer"]
    #[doc = " version depending on the default behavior that was specified at"]
    #[doc = " mempool creation time (see flags)."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj_table"]
    #[doc = "   A pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   The number of objects to add in the mempool from obj_table."]
    pub fn _rte_mempool_put_bulk(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Put one object back in the mempool."]
    #[doc = ""]
    #[doc = " This function calls the multi-producer or the single-producer"]
    #[doc = " version depending on the default behavior that was specified at"]
    #[doc = " mempool creation time (see flags)."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj"]
    #[doc = "   A pointer to the object to be added."]
    pub fn _rte_mempool_put(mp: *mut rte_mempool, obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Get several objects from the mempool."]
    #[doc = ""]
    #[doc = " If cache is enabled, objects will be retrieved first from cache,"]
    #[doc = " subsequently from the common pool. Note that it can return -ENOENT when"]
    #[doc = " the local cache and common pool are empty, even if cache from other"]
    #[doc = " lcores are full."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj_table"]
    #[doc = "   A pointer to a table of void * pointers (objects) that will be filled."]
    #[doc = " @param n"]
    #[doc = "   The number of objects to get from mempool to obj_table."]
    #[doc = " @param cache"]
    #[doc = "   A pointer to a mempool cache structure. May be NULL if not needed."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; objects taken."]
    #[doc = "   - -ENOENT: Not enough entries in the mempool; no object is retrieved."]
    pub fn _rte_mempool_generic_get(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        cache: *mut rte_mempool_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get several objects from the mempool."]
    #[doc = ""]
    #[doc = " This function calls the multi-consumers or the single-consumer"]
    #[doc = " version, depending on the default behaviour that was specified at"]
    #[doc = " mempool creation time (see flags)."]
    #[doc = ""]
    #[doc = " If cache is enabled, objects will be retrieved first from cache,"]
    #[doc = " subsequently from the common pool. Note that it can return -ENOENT when"]
    #[doc = " the local cache and common pool are empty, even if cache from other"]
    #[doc = " lcores are full."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj_table"]
    #[doc = "   A pointer to a table of void * pointers (objects) that will be filled."]
    #[doc = " @param n"]
    #[doc = "   The number of objects to get from the mempool to obj_table."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; objects taken"]
    #[doc = "   - -ENOENT: Not enough entries in the mempool; no object is retrieved."]
    pub fn _rte_mempool_get_bulk(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get one object from the mempool."]
    #[doc = ""]
    #[doc = " This function calls the multi-consumers or the single-consumer"]
    #[doc = " version, depending on the default behavior that was specified at"]
    #[doc = " mempool creation (see flags)."]
    #[doc = ""]
    #[doc = " If cache is enabled, objects will be retrieved first from cache,"]
    #[doc = " subsequently from the common pool. Note that it can return -ENOENT when"]
    #[doc = " the local cache and common pool are empty, even if cache from other"]
    #[doc = " lcores are full."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param obj_p"]
    #[doc = "   A pointer to a void * pointer (object) that will be filled."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; objects taken."]
    #[doc = "   - -ENOENT: Not enough entries in the mempool; no object is retrieved."]
    pub fn _rte_mempool_get(mp: *mut rte_mempool, obj_p: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Get a contiguous blocks of objects from the mempool."]
    #[doc = ""]
    #[doc = " If cache is enabled, consider to flush it first, to reuse objects"]
    #[doc = " as soon as possible."]
    #[doc = ""]
    #[doc = " The application should check that the driver supports the operation"]
    #[doc = " by calling rte_mempool_ops_get_info() and checking that `contig_block_size`"]
    #[doc = " is not zero."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param first_obj_table"]
    #[doc = "   A pointer to a pointer to the first object in each block."]
    #[doc = " @param n"]
    #[doc = "   The number of blocks to get from mempool."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; blocks taken."]
    #[doc = "   - -ENOBUFS: Not enough entries in the mempool; no object is retrieved."]
    #[doc = "   - -EOPNOTSUPP: The mempool driver does not support block dequeue"]
    pub fn _rte_mempool_get_contig_blocks(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prefetch the first part of the mbuf"]
    #[doc = ""]
    #[doc = " The first 64 bytes of the mbuf corresponds to fields that are used early"]
    #[doc = " in the receive path. If the cache line of the architecture is higher than"]
    #[doc = " 64B, the second part will also be prefetched."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pointer to the mbuf."]
    pub fn _rte_mbuf_prefetch_part1(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Prefetch the second part of the mbuf"]
    #[doc = ""]
    #[doc = " The next 64 bytes of the mbuf corresponds to fields that are used in the"]
    #[doc = " transmit path. If the cache line of the architecture is higher than 64B,"]
    #[doc = " this function does nothing as it is expected that the full mbuf is"]
    #[doc = " already in cache."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pointer to the mbuf."]
    pub fn _rte_mbuf_prefetch_part2(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Return the IO address of the beginning of the mbuf data"]
    #[doc = ""]
    #[doc = " @param mb"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @return"]
    #[doc = "   The IO address of the beginning of the mbuf data"]
    pub fn _rte_mbuf_data_iova(mb: *const rte_mbuf) -> rte_iova_t;
}
extern "C" {
    #[doc = " Return the default IO address of the beginning of the mbuf data"]
    #[doc = ""]
    #[doc = " This function is used by drivers in their receive function, as it"]
    #[doc = " returns the location where data should be written by the NIC, taking"]
    #[doc = " the default headroom in account."]
    #[doc = ""]
    #[doc = " @param mb"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @return"]
    #[doc = "   The IO address of the beginning of the mbuf data"]
    pub fn _rte_mbuf_data_iova_default(mb: *const rte_mbuf) -> rte_iova_t;
}
extern "C" {
    #[doc = " Return the mbuf owning the data buffer address of an indirect mbuf."]
    #[doc = ""]
    #[doc = " @param mi"]
    #[doc = "   The pointer to the indirect mbuf."]
    #[doc = " @return"]
    #[doc = "   The address of the direct mbuf corresponding to buffer_addr."]
    pub fn _rte_mbuf_from_indirect(mi: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Return the buffer address embedded in the given mbuf."]
    #[doc = ""]
    #[doc = " @param md"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @return"]
    #[doc = "   The address of the data buffer owned by the mbuf."]
    pub fn _rte_mbuf_to_baddr(md: *mut rte_mbuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the starting address of the private data area embedded in"]
    #[doc = " the given mbuf."]
    #[doc = ""]
    #[doc = " Note that no check is made to ensure that a private data area"]
    #[doc = " actually exists in the supplied mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @return"]
    #[doc = "   The starting address of the private data area of the given mbuf."]
    pub fn _rte_mbuf_to_priv(m: *mut rte_mbuf) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reads the value of an mbuf's refcnt."]
    #[doc = " @param m"]
    #[doc = "   Mbuf to read"]
    #[doc = " @return"]
    #[doc = "   Reference count number."]
    pub fn _rte_mbuf_refcnt_read(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Sets an mbuf's refcnt to a defined value."]
    #[doc = " @param m"]
    #[doc = "   Mbuf to update"]
    #[doc = " @param new_value"]
    #[doc = "   Value set"]
    pub fn _rte_mbuf_refcnt_set(m: *mut rte_mbuf, new_value: u16);
}
extern "C" {
    #[doc = " Adds given value to an mbuf's refcnt and returns its new value."]
    #[doc = " @param m"]
    #[doc = "   Mbuf to update"]
    #[doc = " @param value"]
    #[doc = "   Value to add/subtract"]
    #[doc = " @return"]
    #[doc = "   Updated value"]
    pub fn _rte_mbuf_refcnt_update(m: *mut rte_mbuf, value: i16) -> u16;
}
extern "C" {
    #[doc = " Reads the refcnt of an external buffer."]
    #[doc = ""]
    #[doc = " @param shinfo"]
    #[doc = "   Shared data of the external buffer."]
    #[doc = " @return"]
    #[doc = "   Reference count number."]
    pub fn _rte_mbuf_ext_refcnt_read(shinfo: *const rte_mbuf_ext_shared_info) -> u16;
}
extern "C" {
    #[doc = " Set refcnt of an external buffer."]
    #[doc = ""]
    #[doc = " @param shinfo"]
    #[doc = "   Shared data of the external buffer."]
    #[doc = " @param new_value"]
    #[doc = "   Value set"]
    pub fn _rte_mbuf_ext_refcnt_set(shinfo: *mut rte_mbuf_ext_shared_info, new_value: u16);
}
extern "C" {
    #[doc = " Add given value to refcnt of an external buffer and return its new"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " @param shinfo"]
    #[doc = "   Shared data of the external buffer."]
    #[doc = " @param value"]
    #[doc = "   Value to add/subtract"]
    #[doc = " @return"]
    #[doc = "   Updated value"]
    pub fn _rte_mbuf_ext_refcnt_update(shinfo: *mut rte_mbuf_ext_shared_info, value: i16) -> u16;
}
extern "C" {
    #[doc = " Allocate an uninitialized mbuf from mempool *mp*."]
    #[doc = ""]
    #[doc = " This function can be used by PMDs (especially in RX functions) to"]
    #[doc = " allocate an uninitialized mbuf. The driver is responsible of"]
    #[doc = " initializing all the required fields. See rte_pktmbuf_reset()."]
    #[doc = " For standard needs, prefer rte_pktmbuf_alloc()."]
    #[doc = ""]
    #[doc = " The caller can expect that the following fields of the mbuf structure"]
    #[doc = " are initialized: buf_addr, buf_iova, buf_len, refcnt=1, nb_segs=1,"]
    #[doc = " next=NULL, pool, priv_size. The other fields must be initialized"]
    #[doc = " by the caller."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbuf is allocated."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new mbuf on success."]
    #[doc = "   - NULL if allocation failed."]
    pub fn _rte_mbuf_raw_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Put mbuf back into its original mempool."]
    #[doc = ""]
    #[doc = " The caller must ensure that the mbuf is direct and properly"]
    #[doc = " reinitialized (refcnt=1, next=NULL, nb_segs=1), as done by"]
    #[doc = " rte_pktmbuf_prefree_seg()."]
    #[doc = ""]
    #[doc = " This function should be used with care, when optimization is"]
    #[doc = " required. For standard needs, prefer rte_pktmbuf_free() or"]
    #[doc = " rte_pktmbuf_free_seg()."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be freed."]
    pub fn _rte_mbuf_raw_free(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Get the data room size of mbufs stored in a pktmbuf_pool"]
    #[doc = ""]
    #[doc = " The data room size is the amount of data that can be stored in a"]
    #[doc = " mbuf including the headroom (RTE_PKTMBUF_HEADROOM)."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The packet mbuf pool."]
    #[doc = " @return"]
    #[doc = "   The data room size of mbufs stored in this mempool."]
    pub fn _rte_pktmbuf_data_room_size(mp: *mut rte_mempool) -> u16;
}
extern "C" {
    #[doc = " Get the application private size of mbufs stored in a pktmbuf_pool"]
    #[doc = ""]
    #[doc = " The private size of mbuf is a zone located between the rte_mbuf"]
    #[doc = " structure and the data buffer where an application can store data"]
    #[doc = " associated to a packet."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The packet mbuf pool."]
    #[doc = " @return"]
    #[doc = "   The private size of mbufs stored in this mempool."]
    pub fn _rte_pktmbuf_priv_size(mp: *mut rte_mempool) -> u16;
}
extern "C" {
    #[doc = " Reset the data_off field of a packet mbuf to its default value."]
    #[doc = ""]
    #[doc = " The given mbuf must have only one segment, which should be empty."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf's data_off field has to be reset."]
    pub fn _rte_pktmbuf_reset_headroom(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Reset the fields of a packet mbuf to their default values."]
    #[doc = ""]
    #[doc = " The given mbuf must have only one segment."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be resetted."]
    pub fn _rte_pktmbuf_reset(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Allocate a new mbuf from a mempool."]
    #[doc = ""]
    #[doc = " This new mbuf contains one segment, which has a length of 0. The pointer"]
    #[doc = " to data is initialized to have some bytes of headroom in the buffer"]
    #[doc = " (if buffer size allows)."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the mbuf is allocated."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new mbuf on success."]
    #[doc = "   - NULL if allocation failed."]
    pub fn _rte_pktmbuf_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Allocate a bulk of mbufs, initialize refcnt and reset the fields to default"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = "  @param pool"]
    #[doc = "    The mempool from which mbufs are allocated."]
    #[doc = "  @param mbufs"]
    #[doc = "    Array of pointers to mbufs"]
    #[doc = "  @param count"]
    #[doc = "    Array size"]
    #[doc = "  @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOENT: Not enough entries in the mempool; no mbufs are retrieved."]
    pub fn _rte_pktmbuf_alloc_bulk(
        pool: *mut rte_mempool,
        mbufs: *mut *mut rte_mbuf,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize shared data at the end of an external buffer before attaching"]
    #[doc = " to a mbuf by ``rte_pktmbuf_attach_extbuf()``. This is not a mandatory"]
    #[doc = " initialization but a helper function to simply spare a few bytes at the"]
    #[doc = " end of the buffer for shared data. If shared data is allocated"]
    #[doc = " separately, this should not be called but application has to properly"]
    #[doc = " initialize the shared data according to its need."]
    #[doc = ""]
    #[doc = " Free callback and its argument is saved and the refcnt is set to 1."]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " The value of buf_len will be reduced to RTE_PTR_DIFF(shinfo, buf_addr)"]
    #[doc = " after this initialization. This shall be used for"]
    #[doc = " ``rte_pktmbuf_attach_extbuf()``"]
    #[doc = ""]
    #[doc = " @param buf_addr"]
    #[doc = "   The pointer to the external buffer."]
    #[doc = " @param [in,out] buf_len"]
    #[doc = "   The pointer to length of the external buffer. Input value must be"]
    #[doc = "   larger than the size of ``struct rte_mbuf_ext_shared_info`` and"]
    #[doc = "   padding for alignment. If not enough, this function will return NULL."]
    #[doc = "   Adjusted buffer length will be returned through this pointer."]
    #[doc = " @param free_cb"]
    #[doc = "   Free callback function to call when the external buffer needs to be"]
    #[doc = "   freed."]
    #[doc = " @param fcb_opaque"]
    #[doc = "   Argument for the free callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pointer to the initialized shared data on success, return NULL"]
    #[doc = "   otherwise."]
    pub fn _rte_pktmbuf_ext_shinfo_init_helper(
        buf_addr: *mut ::std::os::raw::c_void,
        buf_len: *mut u16,
        free_cb: rte_mbuf_extbuf_free_callback_t,
        fcb_opaque: *mut ::std::os::raw::c_void,
    ) -> *mut rte_mbuf_ext_shared_info;
}
extern "C" {
    #[doc = " Attach an external buffer to a mbuf."]
    #[doc = ""]
    #[doc = " User-managed anonymous buffer can be attached to an mbuf. When attaching"]
    #[doc = " it, corresponding free callback function and its argument should be"]
    #[doc = " provided via shinfo. This callback function will be called once all the"]
    #[doc = " mbufs are detached from the buffer (refcnt becomes zero)."]
    #[doc = ""]
    #[doc = " The headroom for the attaching mbuf will be set to zero and this can be"]
    #[doc = " properly adjusted after attachment. For example, ``rte_pktmbuf_adj()``"]
    #[doc = " or ``rte_pktmbuf_reset_headroom()`` might be used."]
    #[doc = ""]
    #[doc = " More mbufs can be attached to the same external buffer by"]
    #[doc = " ``rte_pktmbuf_attach()`` once the external buffer has been attached by"]
    #[doc = " this API."]
    #[doc = ""]
    #[doc = " Detachment can be done by either ``rte_pktmbuf_detach_extbuf()`` or"]
    #[doc = " ``rte_pktmbuf_detach()``."]
    #[doc = ""]
    #[doc = " Memory for shared data must be provided and user must initialize all of"]
    #[doc = " the content properly, escpecially free callback and refcnt. The pointer"]
    #[doc = " of shared data will be stored in m->shinfo."]
    #[doc = " ``rte_pktmbuf_ext_shinfo_init_helper`` can help to simply spare a few"]
    #[doc = " bytes at the end of buffer for the shared data, store free callback and"]
    #[doc = " its argument and set the refcnt to 1. The following is an example:"]
    #[doc = ""]
    #[doc = "   struct rte_mbuf_ext_shared_info *shinfo ="]
    #[doc = "          rte_pktmbuf_ext_shinfo_init_helper(buf_addr, &buf_len,"]
    #[doc = "                                             free_cb, fcb_arg);"]
    #[doc = "   rte_pktmbuf_attach_extbuf(m, buf_addr, buf_iova, buf_len, shinfo);"]
    #[doc = "   rte_pktmbuf_reset_headroom(m);"]
    #[doc = "   rte_pktmbuf_adj(m, data_len);"]
    #[doc = ""]
    #[doc = " Attaching an external buffer is quite similar to mbuf indirection in"]
    #[doc = " replacing buffer addresses and length of a mbuf, but a few differences:"]
    #[doc = " - When an indirect mbuf is attached, refcnt of the direct mbuf would be"]
    #[doc = "   2 as long as the direct mbuf itself isn't freed after the attachment."]
    #[doc = "   In such cases, the buffer area of a direct mbuf must be read-only. But"]
    #[doc = "   external buffer has its own refcnt and it starts from 1. Unless"]
    #[doc = "   multiple mbufs are attached to a mbuf having an external buffer, the"]
    #[doc = "   external buffer is writable."]
    #[doc = " - There's no need to allocate buffer from a mempool. Any buffer can be"]
    #[doc = "   attached with appropriate free callback and its IO address."]
    #[doc = " - Smaller metadata is required to maintain shared data such as refcnt."]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: This API may change without prior notice."]
    #[doc = " Once external buffer is enabled by allowing experimental API,"]
    #[doc = " ``RTE_MBUF_DIRECT()`` and ``RTE_MBUF_INDIRECT()`` are no longer"]
    #[doc = " exclusive. A mbuf can be considered direct if it is neither indirect nor"]
    #[doc = " having external buffer."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @param buf_addr"]
    #[doc = "   The pointer to the external buffer."]
    #[doc = " @param buf_iova"]
    #[doc = "   IO address of the external buffer."]
    #[doc = " @param buf_len"]
    #[doc = "   The size of the external buffer."]
    #[doc = " @param shinfo"]
    #[doc = "   User-provided memory for shared data of the external buffer."]
    pub fn _rte_pktmbuf_attach_extbuf(
        m: *mut rte_mbuf,
        buf_addr: *mut ::std::os::raw::c_void,
        buf_iova: rte_iova_t,
        buf_len: u16,
        shinfo: *mut rte_mbuf_ext_shared_info,
    );
}
extern "C" {
    #[doc = " Attach packet mbuf to another packet mbuf."]
    #[doc = ""]
    #[doc = " If the mbuf we are attaching to isn't a direct buffer and is attached to"]
    #[doc = " an external buffer, the mbuf being attached will be attached to the"]
    #[doc = " external buffer instead of mbuf indirection."]
    #[doc = ""]
    #[doc = " Otherwise, the mbuf will be indirectly attached. After attachment we"]
    #[doc = " refer the mbuf we attached as 'indirect', while mbuf we attached to as"]
    #[doc = " 'direct'.  The direct mbuf's reference counter is incremented."]
    #[doc = ""]
    #[doc = " Right now, not supported:"]
    #[doc = "  - attachment for already indirect mbuf (e.g. - mi has to be direct)."]
    #[doc = "  - mbuf we trying to attach (mi) is used by someone else"]
    #[doc = "    e.g. it's reference counter is greater then 1."]
    #[doc = ""]
    #[doc = " @param mi"]
    #[doc = "   The indirect packet mbuf."]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf we're attaching to."]
    pub fn _rte_pktmbuf_attach(mi: *mut rte_mbuf, m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Detach a packet mbuf from external buffer or direct buffer."]
    #[doc = ""]
    #[doc = "  - decrement refcnt and free the external/direct buffer if refcnt"]
    #[doc = "    becomes zero."]
    #[doc = "  - restore original mbuf address and length values."]
    #[doc = "  - reset pktmbuf data and data_len to their default values."]
    #[doc = ""]
    #[doc = " All other fields of the given packet mbuf will be left intact."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The indirect attached packet mbuf."]
    pub fn _rte_pktmbuf_detach(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Decrease reference counter and unlink a mbuf segment"]
    #[doc = ""]
    #[doc = " This function does the same than a free, except that it does not"]
    #[doc = " return the segment to its pool."]
    #[doc = " It decreases the reference counter, and if it reaches 0, it is"]
    #[doc = " detached from its parent for an indirect mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be unlinked"]
    #[doc = " @return"]
    #[doc = "   - (m) if it is the last reference. It can be recycled or freed."]
    #[doc = "   - (NULL) if the mbuf still has remaining references on it."]
    pub fn _rte_pktmbuf_prefree_seg(m: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Free a segment of a packet mbuf into its original mempool."]
    #[doc = ""]
    #[doc = " Free an mbuf, without parsing other segments in case of chained"]
    #[doc = " buffers."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf segment to be freed."]
    pub fn _rte_pktmbuf_free_seg(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Free a packet mbuf back into its original mempool."]
    #[doc = ""]
    #[doc = " Free an mbuf, and all its segments in case of chained buffers. Each"]
    #[doc = " segment is added back into its original mempool."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be freed. If NULL, the function does nothing."]
    pub fn _rte_pktmbuf_free(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Creates a \"clone\" of the given packet mbuf."]
    #[doc = ""]
    #[doc = " Walks through all segments of the given packet mbuf, and for each of them:"]
    #[doc = "  - Creates a new packet mbuf from the given pool."]
    #[doc = "  - Attaches newly created mbuf to the segment."]
    #[doc = " Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values"]
    #[doc = " from the original packet mbuf."]
    #[doc = ""]
    #[doc = " @param md"]
    #[doc = "   The packet mbuf to be cloned."]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the \"clone\" mbufs are allocated."]
    #[doc = " @return"]
    #[doc = "   - The pointer to the new \"clone\" mbuf on success."]
    #[doc = "   - NULL if allocation fails."]
    pub fn _rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Adds given value to the refcnt of all packet mbuf segments."]
    #[doc = ""]
    #[doc = " Walks through all segments of given packet mbuf and for each of them"]
    #[doc = " invokes rte_mbuf_refcnt_update()."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf whose refcnt to be updated."]
    #[doc = " @param v"]
    #[doc = "   The value to add to the mbuf's segments refcnt."]
    pub fn _rte_pktmbuf_refcnt_update(m: *mut rte_mbuf, v: i16);
}
extern "C" {
    #[doc = " Get the headroom in a packet mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   The length of the headroom."]
    pub fn _rte_pktmbuf_headroom(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Get the tailroom of a packet mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   The length of the tailroom."]
    pub fn _rte_pktmbuf_tailroom(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Get the last segment of the packet."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   The last segment of the given mbuf."]
    pub fn _rte_pktmbuf_lastseg(m: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Prepend len bytes to an mbuf data area."]
    #[doc = ""]
    #[doc = " Returns a pointer to the new"]
    #[doc = " data start address. If there is not enough headroom in the first"]
    #[doc = " segment, the function will return NULL, without modifying the mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pkt mbuf."]
    #[doc = " @param len"]
    #[doc = "   The amount of data to prepend (in bytes)."]
    #[doc = " @return"]
    #[doc = "   A pointer to the start of the newly prepended data, or"]
    #[doc = "   NULL if there is not enough headroom space in the first segment"]
    pub fn _rte_pktmbuf_prepend(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append len bytes to an mbuf."]
    #[doc = ""]
    #[doc = " Append len bytes to an mbuf and return a pointer to the start address"]
    #[doc = " of the added data. If there is not enough tailroom in the last"]
    #[doc = " segment, the function will return NULL, without modifying the mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param len"]
    #[doc = "   The amount of data to append (in bytes)."]
    #[doc = " @return"]
    #[doc = "   A pointer to the start of the newly appended data, or"]
    #[doc = "   NULL if there is not enough tailroom space in the last segment"]
    pub fn _rte_pktmbuf_append(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove len bytes at the beginning of an mbuf."]
    #[doc = ""]
    #[doc = " Returns a pointer to the start address of the new data area. If the"]
    #[doc = " length is greater than the length of the first segment, then the"]
    #[doc = " function will fail and return NULL, without modifying the mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param len"]
    #[doc = "   The amount of data to remove (in bytes)."]
    #[doc = " @return"]
    #[doc = "   A pointer to the new start of the data."]
    pub fn _rte_pktmbuf_adj(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove len bytes of data at the end of the mbuf."]
    #[doc = ""]
    #[doc = " If the length is greater than the length of the last segment, the"]
    #[doc = " function will fail and return -1 without modifying the mbuf."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param len"]
    #[doc = "   The amount of data to remove (in bytes)."]
    #[doc = " @return"]
    #[doc = "   - 0: On success."]
    #[doc = "   - -1: On error."]
    pub fn _rte_pktmbuf_trim(m: *mut rte_mbuf, len: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if mbuf data is contiguous."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   - 1, if all data is contiguous (one segment)."]
    #[doc = "   - 0, if there is several segments."]
    pub fn _rte_pktmbuf_is_contiguous(m: *const rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read len data bytes in a mbuf at specified offset."]
    #[doc = ""]
    #[doc = " If the data is contiguous, return the pointer in the mbuf data, else"]
    #[doc = " copy the data in the buffer provided by the user and return its"]
    #[doc = " pointer."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The pointer to the mbuf."]
    #[doc = " @param off"]
    #[doc = "   The offset of the data in the mbuf."]
    #[doc = " @param len"]
    #[doc = "   The amount of bytes to read."]
    #[doc = " @param buf"]
    #[doc = "   The buffer where data is copied if it is not contiguous in mbuf"]
    #[doc = "   data. Its length should be at least equal to the len parameter."]
    #[doc = " @return"]
    #[doc = "   The pointer to the data, either in the mbuf if it is contiguous,"]
    #[doc = "   or in the user buffer. If mbuf is too small, NULL is returned."]
    pub fn _rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Chain an mbuf to another, thereby creating a segmented packet."]
    #[doc = ""]
    #[doc = " Note: The implementation will do a linear walk over the segments to find"]
    #[doc = " the tail entry. For cases when there are many segments, it's better to"]
    #[doc = " chain the entries manually."]
    #[doc = ""]
    #[doc = " @param head"]
    #[doc = "   The head of the mbuf chain (the first packet)"]
    #[doc = " @param tail"]
    #[doc = "   The mbuf to put last in the chain"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0, on success."]
    #[doc = "   - -EOVERFLOW, if the chain segment limit exceeded"]
    pub fn _rte_pktmbuf_chain(head: *mut rte_mbuf, tail: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Validate general requirements for Tx offload in mbuf."]
    #[doc = ""]
    #[doc = " This function checks correctness and completeness of Tx offload settings."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf to be validated."]
    #[doc = " @return"]
    #[doc = "   0 if packet is valid"]
    pub fn _rte_validate_tx_offload(m: *const rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Linearize data in mbuf."]
    #[doc = ""]
    #[doc = " This function moves the mbuf data in the first segment if there is enough"]
    #[doc = " tailroom. The subsequent segments are unchained and freed."]
    #[doc = ""]
    #[doc = " @param mbuf"]
    #[doc = "   mbuf to linearize"]
    #[doc = " @return"]
    #[doc = "   - 0, on success"]
    #[doc = "   - -1, on error"]
    pub fn _rte_pktmbuf_linearize(mbuf: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a burst of input packets from a receive queue of an Ethernet"]
    #[doc = " device. The retrieved packets are stored in *rte_mbuf* structures whose"]
    #[doc = " pointers are supplied in the *rx_pkts* array."]
    #[doc = ""]
    #[doc = " The rte_eth_rx_burst() function loops, parsing the RX ring of the"]
    #[doc = " receive queue, up to *nb_pkts* packets, and for each completed RX"]
    #[doc = " descriptor in the ring, it performs the following operations:"]
    #[doc = ""]
    #[doc = " - Initialize the *rte_mbuf* data structure associated with the"]
    #[doc = "   RX descriptor according to the information provided by the NIC into"]
    #[doc = "   that RX descriptor."]
    #[doc = ""]
    #[doc = " - Store the *rte_mbuf* data structure into the next entry of the"]
    #[doc = "   *rx_pkts* array."]
    #[doc = ""]
    #[doc = " - Replenish the RX descriptor with a new *rte_mbuf* buffer"]
    #[doc = "   allocated from the memory pool associated with the receive queue at"]
    #[doc = "   initialization time."]
    #[doc = ""]
    #[doc = " When retrieving an input packet that was scattered by the controller"]
    #[doc = " into multiple receive descriptors, the rte_eth_rx_burst() function"]
    #[doc = " appends the associated *rte_mbuf* buffers to the first buffer of the"]
    #[doc = " packet."]
    #[doc = ""]
    #[doc = " The rte_eth_rx_burst() function returns the number of packets"]
    #[doc = " actually retrieved, which is the number of *rte_mbuf* data structures"]
    #[doc = " effectively supplied into the *rx_pkts* array."]
    #[doc = " A return value equal to *nb_pkts* indicates that the RX queue contained"]
    #[doc = " at least *rx_pkts* packets, and this is likely to signify that other"]
    #[doc = " received packets remain in the input queue. Applications implementing"]
    #[doc = " a \"retrieve as much received packets as possible\" policy can check this"]
    #[doc = " specific case and keep invoking the rte_eth_rx_burst() function until"]
    #[doc = " a value less than *nb_pkts* is returned."]
    #[doc = ""]
    #[doc = " This receive method has the following advantages:"]
    #[doc = ""]
    #[doc = " - It allows a run-to-completion network stack engine to retrieve and"]
    #[doc = "   to immediately process received packets in a fast burst-oriented"]
    #[doc = "   approach, avoiding the overhead of unnecessary intermediate packet"]
    #[doc = "   queue/dequeue operations."]
    #[doc = ""]
    #[doc = " - Conversely, it also allows an asynchronous-oriented processing"]
    #[doc = "   method to retrieve bursts of received packets and to immediately"]
    #[doc = "   queue them for further parallel processing by another logical core,"]
    #[doc = "   for instance. However, instead of having received packets being"]
    #[doc = "   individually queued by the driver, this approach allows the caller"]
    #[doc = "   of the rte_eth_rx_burst() function to queue a burst of retrieved"]
    #[doc = "   packets at a time and therefore dramatically reduce the cost of"]
    #[doc = "   enqueue/dequeue operations per packet."]
    #[doc = ""]
    #[doc = " - It allows the rte_eth_rx_burst() function of the driver to take"]
    #[doc = "   advantage of burst-oriented hardware features (CPU cache,"]
    #[doc = "   prefetch instructions, and so on) to minimize the number of CPU"]
    #[doc = "   cycles per packet."]
    #[doc = ""]
    #[doc = " To summarize, the proposed receive API enables many"]
    #[doc = " burst-oriented optimizations in both synchronous and asynchronous"]
    #[doc = " packet processing environments with no overhead in both cases."]
    #[doc = ""]
    #[doc = " The rte_eth_rx_burst() function does not provide any error"]
    #[doc = " notification to avoid the corresponding overhead. As a hint, the"]
    #[doc = " upper-level application might check the status of the device link once"]
    #[doc = " being systematically returned a 0 value for a given number of tries."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param rx_pkts"]
    #[doc = "   The address of an array of pointers to *rte_mbuf* structures that"]
    #[doc = "   must be large enough to store *nb_pkts* pointers in it."]
    #[doc = " @param nb_pkts"]
    #[doc = "   The maximum number of packets to retrieve."]
    #[doc = " @return"]
    #[doc = "   The number of packets actually retrieved, which is the number"]
    #[doc = "   of pointers to *rte_mbuf* structures effectively supplied to the"]
    #[doc = "   *rx_pkts* array."]
    pub fn _rte_eth_rx_burst(port_id: u16, queue_id: u16, rx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16;
}
extern "C" {
    #[doc = " Get the number of used descriptors of a rx queue"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "  The queue id on the specific port."]
    #[doc = " @return"]
    #[doc = "  The number of used descriptors in the specific queue, or:"]
    #[doc = "     (-EINVAL) if *port_id* or *queue_id* is invalid"]
    #[doc = "     (-ENOTSUP) if the device does not support this function"]
    pub fn _rte_eth_rx_queue_count(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the DD bit of the specific RX descriptor in the queue has been set"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "  The queue id on the specific port."]
    #[doc = " @param offset"]
    #[doc = "  The offset of the descriptor ID from tail."]
    #[doc = " @return"]
    #[doc = "  - (1) if the specific DD bit is set."]
    #[doc = "  - (0) if the specific DD bit is not set."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "  - (-ENOTSUP) if the device does not support this function"]
    pub fn _rte_eth_rx_descriptor_done(port_id: u16, queue_id: u16, offset: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the status of a Rx descriptor in the queue"]
    #[doc = ""]
    #[doc = " It should be called in a similar context than the Rx function:"]
    #[doc = " - on a dataplane core"]
    #[doc = " - not concurrently on the same queue"]
    #[doc = ""]
    #[doc = " Since it's a dataplane function, no check is performed on port_id and"]
    #[doc = " queue_id. The caller must therefore ensure that the port is enabled"]
    #[doc = " and the queue is configured and running."]
    #[doc = ""]
    #[doc = " Note: accessing to a random descriptor in the ring may trigger cache"]
    #[doc = " misses and have a performance impact."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  A valid port identifier of the Ethernet device which."]
    #[doc = " @param queue_id"]
    #[doc = "  A valid Rx queue identifier on this port."]
    #[doc = " @param offset"]
    #[doc = "  The offset of the descriptor starting from tail (0 is the next"]
    #[doc = "  packet to be received by the driver)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - (RTE_ETH_RX_DESC_AVAIL): Descriptor is available for the hardware to"]
    #[doc = "    receive a packet."]
    #[doc = "  - (RTE_ETH_RX_DESC_DONE): Descriptor is done, it is filled by hw, but"]
    #[doc = "    not yet processed by the driver (i.e. in the receive queue)."]
    #[doc = "  - (RTE_ETH_RX_DESC_UNAVAIL): Descriptor is unavailable, either hold by"]
    #[doc = "    the driver and not yet returned to hw, or reserved by the hw."]
    #[doc = "  - (-EINVAL) bad descriptor offset."]
    #[doc = "  - (-ENOTSUP) if the device does not support this function."]
    #[doc = "  - (-ENODEV) bad port or queue (only if compiled with debug)."]
    pub fn _rte_eth_rx_descriptor_status(port_id: u16, queue_id: u16, offset: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the status of a Tx descriptor in the queue."]
    #[doc = ""]
    #[doc = " It should be called in a similar context than the Tx function:"]
    #[doc = " - on a dataplane core"]
    #[doc = " - not concurrently on the same queue"]
    #[doc = ""]
    #[doc = " Since it's a dataplane function, no check is performed on port_id and"]
    #[doc = " queue_id. The caller must therefore ensure that the port is enabled"]
    #[doc = " and the queue is configured and running."]
    #[doc = ""]
    #[doc = " Note: accessing to a random descriptor in the ring may trigger cache"]
    #[doc = " misses and have a performance impact."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  A valid port identifier of the Ethernet device which."]
    #[doc = " @param queue_id"]
    #[doc = "  A valid Tx queue identifier on this port."]
    #[doc = " @param offset"]
    #[doc = "  The offset of the descriptor starting from tail (0 is the place where"]
    #[doc = "  the next packet will be send)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - (RTE_ETH_TX_DESC_FULL) Descriptor is being processed by the hw, i.e."]
    #[doc = "    in the transmit queue."]
    #[doc = "  - (RTE_ETH_TX_DESC_DONE) Hardware is done with this descriptor, it can"]
    #[doc = "    be reused by the driver."]
    #[doc = "  - (RTE_ETH_TX_DESC_UNAVAIL): Descriptor is unavailable, reserved by the"]
    #[doc = "    driver or the hardware."]
    #[doc = "  - (-EINVAL) bad descriptor offset."]
    #[doc = "  - (-ENOTSUP) if the device does not support this function."]
    #[doc = "  - (-ENODEV) bad port or queue (only if compiled with debug)."]
    pub fn _rte_eth_tx_descriptor_status(port_id: u16, queue_id: u16, offset: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a burst of output packets on a transmit queue of an Ethernet device."]
    #[doc = ""]
    #[doc = " The rte_eth_tx_burst() function is invoked to transmit output packets"]
    #[doc = " on the output queue *queue_id* of the Ethernet device designated by its"]
    #[doc = " *port_id*."]
    #[doc = " The *nb_pkts* parameter is the number of packets to send which are"]
    #[doc = " supplied in the *tx_pkts* array of *rte_mbuf* structures, each of them"]
    #[doc = " allocated from a pool created with rte_pktmbuf_pool_create()."]
    #[doc = " The rte_eth_tx_burst() function loops, sending *nb_pkts* packets,"]
    #[doc = " up to the number of transmit descriptors available in the TX ring of the"]
    #[doc = " transmit queue."]
    #[doc = " For each packet to send, the rte_eth_tx_burst() function performs"]
    #[doc = " the following operations:"]
    #[doc = ""]
    #[doc = " - Pick up the next available descriptor in the transmit ring."]
    #[doc = ""]
    #[doc = " - Free the network buffer previously sent with that descriptor, if any."]
    #[doc = ""]
    #[doc = " - Initialize the transmit descriptor with the information provided"]
    #[doc = "   in the *rte_mbuf data structure."]
    #[doc = ""]
    #[doc = " In the case of a segmented packet composed of a list of *rte_mbuf* buffers,"]
    #[doc = " the rte_eth_tx_burst() function uses several transmit descriptors"]
    #[doc = " of the ring."]
    #[doc = ""]
    #[doc = " The rte_eth_tx_burst() function returns the number of packets it"]
    #[doc = " actually sent. A return value equal to *nb_pkts* means that all packets"]
    #[doc = " have been sent, and this is likely to signify that other output packets"]
    #[doc = " could be immediately transmitted again. Applications that implement a"]
    #[doc = " \"send as many packets to transmit as possible\" policy can check this"]
    #[doc = " specific case and keep invoking the rte_eth_tx_burst() function until"]
    #[doc = " a value less than *nb_pkts* is returned."]
    #[doc = ""]
    #[doc = " It is the responsibility of the rte_eth_tx_burst() function to"]
    #[doc = " transparently free the memory buffers of packets previously sent."]
    #[doc = " This feature is driven by the *tx_free_thresh* value supplied to the"]
    #[doc = " rte_eth_dev_configure() function at device configuration time."]
    #[doc = " When the number of free TX descriptors drops below this threshold, the"]
    #[doc = " rte_eth_tx_burst() function must [attempt to] free the *rte_mbuf*  buffers"]
    #[doc = " of those packets whose transmission was effectively completed."]
    #[doc = ""]
    #[doc = " If the PMD is DEV_TX_OFFLOAD_MT_LOCKFREE capable, multiple threads can"]
    #[doc = " invoke this function concurrently on the same tx queue without SW lock."]
    #[doc = " @see rte_eth_dev_info_get, struct rte_eth_txconf::offloads"]
    #[doc = ""]
    #[doc = " @see rte_eth_tx_prepare to perform some prior checks or adjustments"]
    #[doc = " for offloads."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param tx_pkts"]
    #[doc = "   The address of an array of *nb_pkts* pointers to *rte_mbuf* structures"]
    #[doc = "   which contain the output packets."]
    #[doc = " @param nb_pkts"]
    #[doc = "   The maximum number of packets to transmit."]
    #[doc = " @return"]
    #[doc = "   The number of output packets actually stored in transmit descriptors of"]
    #[doc = "   the transmit ring. The return value can be less than the value of the"]
    #[doc = "   *tx_pkts* parameter when the transmit ring is full or has been filled up."]
    pub fn _rte_eth_tx_burst(port_id: u16, queue_id: u16, tx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16;
}
extern "C" {
    #[doc = " Process a burst of output packets on a transmit queue of an Ethernet device."]
    #[doc = ""]
    #[doc = " The rte_eth_tx_prepare() function is invoked to prepare output packets to be"]
    #[doc = " transmitted on the output queue *queue_id* of the Ethernet device designated"]
    #[doc = " by its *port_id*."]
    #[doc = " The *nb_pkts* parameter is the number of packets to be prepared which are"]
    #[doc = " supplied in the *tx_pkts* array of *rte_mbuf* structures, each of them"]
    #[doc = " allocated from a pool created with rte_pktmbuf_pool_create()."]
    #[doc = " For each packet to send, the rte_eth_tx_prepare() function performs"]
    #[doc = " the following operations:"]
    #[doc = ""]
    #[doc = " - Check if packet meets devices requirements for tx offloads."]
    #[doc = ""]
    #[doc = " - Check limitations about number of segments."]
    #[doc = ""]
    #[doc = " - Check additional requirements when debug is enabled."]
    #[doc = ""]
    #[doc = " - Update and/or reset required checksums when tx offload is set for packet."]
    #[doc = ""]
    #[doc = " Since this function can modify packet data, provided mbufs must be safely"]
    #[doc = " writable (e.g. modified data cannot be in shared segment)."]
    #[doc = ""]
    #[doc = " The rte_eth_tx_prepare() function returns the number of packets ready to be"]
    #[doc = " sent. A return value equal to *nb_pkts* means that all packets are valid and"]
    #[doc = " ready to be sent, otherwise stops processing on the first invalid packet and"]
    #[doc = " leaves the rest packets untouched."]
    #[doc = ""]
    #[doc = " When this functionality is not implemented in the driver, all packets are"]
    #[doc = " are returned untouched."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = "   The value must be a valid port id."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param tx_pkts"]
    #[doc = "   The address of an array of *nb_pkts* pointers to *rte_mbuf* structures"]
    #[doc = "   which contain the output packets."]
    #[doc = " @param nb_pkts"]
    #[doc = "   The maximum number of packets to process."]
    #[doc = " @return"]
    #[doc = "   The number of packets correct and ready to be sent. The return value can be"]
    #[doc = "   less than the value of the *tx_pkts* parameter when some packet doesn't"]
    #[doc = "   meet devices requirements with rte_errno set appropriately:"]
    #[doc = "   - -EINVAL: offload flags are not correctly set"]
    #[doc = "   - -ENOTSUP: the offload feature is not supported by the hardware"]
    #[doc = ""]
    pub fn _rte_eth_tx_prepare(port_id: u16, queue_id: u16, tx_pkts: *mut *mut rte_mbuf, nb_pkts: u16) -> u16;
}
extern "C" {
    #[doc = " Send any packets queued up for transmission on a port and HW queue"]
    #[doc = ""]
    #[doc = " This causes an explicit flush of packets previously buffered via the"]
    #[doc = " rte_eth_tx_buffer() function. It returns the number of packets successfully"]
    #[doc = " sent to the NIC, and calls the error callback for any unsent packets. Unless"]
    #[doc = " explicitly set up otherwise, the default callback simply frees the unsent"]
    #[doc = " packets back to the owning mempool."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param buffer"]
    #[doc = "   Buffer of packets to be transmit."]
    #[doc = " @return"]
    #[doc = "   The number of packets successfully sent to the Ethernet device. The error"]
    #[doc = "   callback is called for any packets which could not be sent."]
    pub fn _rte_eth_tx_buffer_flush(port_id: u16, queue_id: u16, buffer: *mut rte_eth_dev_tx_buffer) -> u16;
}
extern "C" {
    #[doc = " Buffer a single packet for future transmission on a port and queue"]
    #[doc = ""]
    #[doc = " This function takes a single mbuf/packet and buffers it for later"]
    #[doc = " transmission on the particular port and queue specified. Once the buffer is"]
    #[doc = " full of packets, an attempt will be made to transmit all the buffered"]
    #[doc = " packets. In case of error, where not all packets can be transmitted, a"]
    #[doc = " callback is called with the unsent packets as a parameter. If no callback"]
    #[doc = " is explicitly set up, the unsent packets are just freed back to the owning"]
    #[doc = " mempool. The function returns the number of packets actually sent i.e."]
    #[doc = " 0 if no buffer flush occurred, otherwise the number of packets successfully"]
    #[doc = " flushed"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param buffer"]
    #[doc = "   Buffer used to collect packets to be sent."]
    #[doc = " @param tx_pkt"]
    #[doc = "   Pointer to the packet mbuf to be sent."]
    #[doc = " @return"]
    #[doc = "   0 = packet has been buffered for later transmission"]
    #[doc = "   N > 0 = packet has been buffered, and the buffer was subsequently flushed,"]
    #[doc = "     causing N packets to be sent, and the error callback to be called for"]
    #[doc = "     the rest."]
    pub fn _rte_eth_tx_buffer(
        port_id: u16,
        queue_id: u16,
        buffer: *mut rte_eth_dev_tx_buffer,
        tx_pkt: *mut rte_mbuf,
    ) -> u16;
}
extern "C" {
    #[doc = " Extract VLAN tag information into mbuf"]
    #[doc = ""]
    #[doc = " Software version of VLAN stripping"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - 1: not a vlan packet"]
    pub fn _rte_vlan_strip(m: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert VLAN tag into mbuf."]
    #[doc = ""]
    #[doc = " Software version of VLAN unstripping"]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @return"]
    #[doc = "   - 0: On success"]
    #[doc = "   -EPERM: mbuf is is shared overwriting would be unsafe"]
    #[doc = "   -ENOSPC: not enough headroom in mbuf"]
    pub fn _rte_vlan_insert(m: *mut *mut rte_mbuf) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "< class handle."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_class {
    pub _address: u8,
}
#[doc = "< Functions exported by PMD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct eth_dev_ops {
    pub _address: u8,
}
